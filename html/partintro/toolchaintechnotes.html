<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لینوکس از صفر - نسخه ۱۲.۲ - نکات فنی زنجیره ابزار</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: #333;
        }
        a {
            color: #0066cc;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .navheader, .navfooter {
            background-color: #f4f4f4;
            padding: 10px;
            margin: 10px 0;
        }
        .admon {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
        }
        .note {
            background-color: #e6f3ff;
        }
    </style>
</head>
<body>
    <div class="navheader">
        <h4>لینوکس از صفر - نسخه ۱۲.۲</h4>
        <h3>مطالب مقدماتی مهم</h3>
        <p>
            <a href="introduction.html">قبلی</a> |
            <a href="generalinstructions.html">بعدی</a> |
            <a href="partintro.html">بالا</a> |
            <a href="../index.html">خانه</a>
        </p>
    </div>

    <h1 id="ch-tools-toolchaintechnotes">۲. نکات فنی زنجیره ابزار</h1>

    <p>این بخش برخی از دلایل و جزئیات فنی پشت روش کلی ساخت را توضیح می‌دهد. سعی نکنید بلافاصله همه چیز را در این بخش درک کنید. بیشتر این اطلاعات پس از انجام یک ساخت واقعی روشن‌تر خواهد شد. می‌توانید در هر زمان در طول فرآیند ساخت به این فصل بازگردید و آن را دوباره بخوانید.</p>

    <p>هدف کلی فصل ۵ و فصل ۶ ایجاد یک منطقه موقت حاوی مجموعه‌ای از ابزارهایی است که شناخته شده و خوب هستند و از سیستم میزبان جدا شده‌اند. با استفاده از دستور <strong>chroot</strong>، کامپایل‌ها در فصل‌های باقی‌مانده در آن محیط ایزوله خواهند شد و اطمینان حاصل می‌شود که ساخت سیستم هدف LFS تمیز و بدون مشکل انجام می‌شود. فرآیند ساخت طوری طراحی شده است که خطرات را برای خوانندگان جدید به حداقل برساند و در عین حال بیشترین ارزش آموزشی را فراهم کند.</p>

    <h2 id="cross-compile">درباره کامپایل متقابل</h2>

    <div class="admon note">
        <h3>نکته</h3>
        <p>کتاب LFS یک آموزش عمومی برای ساخت یک زنجیره ابزار متقابل (یا بومی) نیست و شامل آن نمی‌شود. از دستورات این کتاب برای ساخت یک زنجیره ابزار متقابل برای هدفی غیر از ساخت LFS استفاده نکنید، مگر اینکه واقعاً بدانید چه کاری انجام می‌دهید.</p>
    </div>

    <p>کامپایل متقابل شامل مفاهیمی است که شایسته یک بخش جداگانه هستند. اگرچه ممکن است این بخش در خواندن اول حذف شود، بازگشت به آن بعداً به شما کمک می‌کند تا درک کامل‌تری از فرآیند به دست آورید.</p>

    <p>ابتدا بیایید برخی از اصطلاحات استفاده شده در این زمینه را تعریف کنیم:</p>

    <dl>
        <dt>ساخت</dt>
        <dd>ماشینی است که در آن برنامه‌ها را می‌سازیم. توجه داشته باشید که این ماشین همچنین به عنوان "میزبان" شناخته می‌شود.</dd>

        <dt>میزبان</dt>
        <dd>ماشین/سیستمی است که برنامه‌های ساخته شده در آن اجرا خواهند شد. توجه کنید که این استفاده از "میزبان" با بخش‌های دیگر یکسان نیست.</dd>

        <dt>هدف</dt>
        <dd>فقط برای کامپایلرها استفاده می‌شود. این ماشینی است که کامپایلر برای آن کد تولید می‌کند. ممکن است با ساخت و میزبان متفاوت باشد.</dd>
    </dl>

    <p>به عنوان مثال، بیایید سناریوی زیر را تصور کنیم (گاهی به عنوان "متقابل کانادایی" شناخته می‌شود). ما فقط یک کامپایلر روی یک ماشین کند داریم، بیایید آن را ماشین A بنامیم، و کامپایلر ccA. ما همچنین یک ماشین سریع (B) داریم، اما هیچ کامپایلری برای (B) نداریم، و می‌خواهیم کد را برای یک ماشین کند سوم (C) تولید کنیم. ما یک کامپایلر برای ماشین C را در سه مرحله خواهیم ساخت.</p>

    <table>
        <tr>
            <th>مرحله</th>
            <th>ساخت</th>
            <th>میزبان</th>
            <th>هدف</th>
            <th>اقدام</th>
        </tr>
        <tr>
            <td>۱</td>
            <td>A</td>
            <td>A</td>
            <td>B</td>
            <td>ساخت کامپایلر متقابل cc1 با استفاده از ccA روی ماشین A.</td>
        </tr>
        <tr>
            <td>۲</td>
            <td>A</td>
            <td>B</td>
            <td>C</td>
            <td>ساخت کامپایلر متقابل cc2 با استفاده از cc1 روی ماشین A.</td>
        </tr>
        <tr>
            <td>۳</td>
            <td>B</td>
            <td>C</td>
            <td>C</td>
            <td>ساخت کامپایلر ccC با استفاده از cc2 روی ماشین B.</td>
        </tr>
    </table>

    <p>سپس، تمام برنامه‌های مورد نیاز ماشین C را می‌توان با استفاده از cc2 روی ماشین سریع B کامپایل کرد. توجه داشته باشید که مگر اینکه B بتواند برنامه‌های تولید شده برای C را اجرا کند، هیچ راهی برای آزمایش برنامه‌های تازه ساخته شده وجود ندارد تا زمانی که خود ماشین C در حال اجرا باشد. به عنوان مثال، برای اجرای یک مجموعه آزمون روی ccC، ممکن است بخواهیم یک مرحله چهارم اضافه کنیم:</p>

    <table>
        <tr>
            <th>مرحله</th>
            <th>ساخت</th>
            <th>میزبان</th>
            <th>هدف</th>
            <th>اقدام</th>
        </tr>
        <tr>
            <td>۴</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>بازسازی و آزمایش ccC با استفاده از ccC روی ماشین C.</td>
        </tr>
    </table>

    <p>در مثال بالا، فقط cc1 و cc2 کامپایلرهای متقابل هستند، یعنی آنها کدی برای ماشینی متفاوت از ماشینی که روی آن اجرا می‌شوند تولید می‌کنند. کامپایلرهای دیگر ccA و ccC کدی برای ماشینی که روی آن اجرا می‌شوند تولید می‌کنند. چنین کامپایلرهایی کامپایلرهای <em>بومی</em> نامیده می‌شوند.</p>

    <h2 id="lfs-cross">پیاده‌سازی کامپایل متقابل برای LFS</h2>

    <div class="admon note">
        <h3>نکته</h3>
        <p>تمام بسته‌های کامپایل متقابل در این کتاب از یک سیستم ساخت مبتنی بر autoconf استفاده می‌کنند. سیستم ساخت مبتنی بر autoconf انواع سیستم را به شکل cpu-vendor-kernel-os می‌پذیرد که به عنوان سه‌گانه سیستم شناخته می‌شود. از آنجا که فیلد فروشنده اغلب بی‌اهمیت است، autoconf به شما اجازه می‌دهد آن را حذف کنید.</p>
        
        <p>یک خواننده هوشیار ممکن است بپرسد چرا یک "سه‌گانه" به یک نام چهار جزئی اشاره دارد. فیلدهای kernel و os در ابتدا یک فیلد واحد "سیستم" بودند. چنین فرم سه فیلدی هنوز امروزه برای برخی سیستم‌ها معتبر است، برای مثال، x86_64-unknown-freebsd. اما دو سیستم می‌توانند هسته یکسانی داشته باشند و همچنان برای توصیف آنها از سه‌گانه یکسان استفاده نکنند. برای مثال، Android که روی یک تلفن همراه اجرا می‌شود کاملاً متفاوت از Ubuntu است که روی یک سرور ARM64 اجرا می‌شود، حتی اگر هر دو روی همان نوع CPU (ARM64) اجرا شوند و از همان هسته (Linux) استفاده کنند.</p>

        <p>بدون یک لایه شبیه‌سازی، نمی‌توانید یک اجرایی برای یک سرور را روی یک تلفن همراه یا برعکس اجرا کنید. بنابراین فیلد "سیستم" به فیلدهای kernel و os تقسیم شده است تا این سیستم‌ها را به طور واضح مشخص کند. در مثال ما، سیستم Android به عنوان aarch64-unknown-linux-android تعیین می‌شود و سیستم Ubuntu به عنوان aarch64-unknown-linux-gnu تعیین می‌شود.</p>

        <p>کلمه "سه‌گانه" در واژگان باقی مانده است. یک روش ساده برای تعیین سه‌گانه سیستم خود، اجرای اسکریپت config.guess است که همراه با منبع بسیاری از بسته‌ها می‌آید. منابع binutils را باز کنید، اسکریپت ./config.guess را اجرا کنید و خروجی را یادداشت کنید. برای مثال، برای یک پردازنده 32 بیتی Intel، خروجی i686-pc-linux-gnu خواهد بود. روی یک سیستم 64 بیتی، x86_64-pc-linux-gnu خواهد بود. روی اکثر سیستم‌های Linux، دستور حتی ساده‌تر gcc -dumpmachine اطلاعات مشابهی به شما خواهد داد.</p>

        <p>همچنین باید از نام لینکر پویای پلتفرم آگاه باشید که اغلب به عنوان لودر پویا شناخته می‌شود (نباید با لینکر استاندارد ld که بخشی از binutils است اشتباه گرفته شود). لینکر پوی<p>لینکر پویا که توسط بسته glibc ارائه می‌شود، کتابخانه‌های مشترک مورد نیاز یک برنامه را پیدا کرده و بارگذاری می‌کند، برنامه را برای اجرا آماده می‌کند و سپس آن را اجرا می‌کند. نام لینکر پویا برای یک ماشین 32 بیتی Intel، ld-linux.so.2 است؛ روی سیستم‌های 64 بیتی، ld-linux-x86-64.so.2 است. یک راه مطمئن برای تعیین نام لینکر پویا، بررسی یک باینری تصادفی از سیستم میزبان با اجرای: readelf -l <name of binary> | grep interpreter و توجه به خروجی است. مرجع قطعی که تمام پلتفرم‌ها را پوشش می‌دهد در <a href="https://sourceware.org/glibc/wiki/ABIList">یک صفحه ویکی Glibc</a> است.</p>
        </div>
        
        <p>برای شبیه‌سازی یک کامپایل متقابل در LFS، نام سه‌گانه میزبان با تغییر فیلد "فروشنده" در متغیر LFS_TGT به "lfs" کمی تنظیم می‌شود. ما همچنین از گزینه --with-sysroot هنگام ساخت لینکر متقابل و کامپایلر متقابل استفاده می‌کنیم تا به آنها بگوییم کجا فایل‌های میزبان مورد نیاز را پیدا کنند. این اطمینان می‌دهد که هیچ یک از برنامه‌های دیگر ساخته شده در فصل ۶ به کتابخانه‌های روی ماشین ساخت لینک نمی‌شوند. فقط دو مرحله اجباری است، به علاوه یک مرحله دیگر برای آزمون‌ها.</p>
        
        <table>
            <tr>
                <th>مرحله</th>
                <th>ساخت</th>
                <th>میزبان</th>
                <th>هدف</th>
                <th>اقدام</th>
            </tr>
            <tr>
                <td>۱</td>
                <td>pc</td>
                <td>pc</td>
                <td>lfs</td>
                <td>ساخت کامپایلر متقابل cc1 با استفاده از cc-pc روی pc.</td>
            </tr>
            <tr>
                <td>۲</td>
                <td>pc</td>
                <td>lfs</td>
                <td>lfs</td>
                <td>ساخت کامپایلر cc-lfs با استفاده از cc1 روی pc.</td>
            </tr>
            <tr>
                <td>۳</td>
                <td>lfs</td>
                <td>lfs</td>
                <td>lfs</td>
                <td>بازسازی و آزمایش cc-lfs با استفاده از cc-lfs روی lfs.</td>
            </tr>
        </table>
        
        <p>در جدول قبلی، "روی pc" به این معنی است که دستورات روی یک ماشین با استفاده از توزیع از قبل نصب شده اجرا می‌شوند. "روی lfs" به این معنی است که دستورات در یک محیط chroot اجرا می‌شوند.</p>
        
        <p>این هنوز پایان داستان نیست. زبان C فقط یک کامپایلر نیست؛ همچنین یک کتابخانه استاندارد را تعریف می‌کند. در این کتاب، از کتابخانه GNU C، به نام glibc، استفاده می‌شود (یک جایگزین، "musl" وجود دارد). این کتابخانه باید برای ماشین LFS کامپایل شود؛ یعنی با استفاده از کامپایلر متقابل cc1. اما خود کامپایلر از یک کتابخانه داخلی استفاده می‌کند که زیربرنامه‌های پیچیده‌ای برای توابعی که در مجموعه دستورالعمل اسمبلر موجود نیستند ارائه می‌دهد. این کتابخانه داخلی libgcc نامیده می‌شود و باید به کتابخانه glibc لینک شود تا کاملاً کارآمد باشد. علاوه بر این، کتابخانه استاندارد برای ++C (libstdc++) نیز باید با glibc لینک شود. راه حل این مشکل مرغ و تخم مرغ این است که ابتدا یک libgcc تنزل یافته مبتنی بر cc1 را بسازیم که فاقد برخی قابلیت‌ها مانند رشته‌ها و مدیریت استثناها است، و سپس glibc را با استفاده از این کامپایلر تنزل یافته بسازیم (خود glibc تنزل نمی‌یابد)، و همچنین libstdc++ را بسازیم. این کتابخانه آخر فاقد برخی از قابلیت‌های libgcc خواهد بود.</p>
        
        <p>نتیجه پاراگراف قبلی این است که cc1 قادر به ساخت یک libstdc++ کاملاً کارآمد با libgcc تنزل یافته نیست، اما cc1 تنها کامپایلر موجود برای ساخت کتابخانه‌های C/C++ در مرحله ۲ است. دو دلیل وجود دارد که ما فوراً از کامپایلر ساخته شده در مرحله ۲، cc-lfs، برای ساخت آن کتابخانه‌ها استفاده نمی‌کنیم.</p>
        
        <ul>
            <li>به طور کلی، cc-lfs نمی‌تواند روی pc (سیستم میزبان) اجرا شود. حتی اگر سه‌گانه‌ها برای pc و lfs با یکدیگر سازگار باشند، یک اجرایی برای lfs باید به glibc-2.40 وابسته باشد؛ توزیع میزبان ممکن است از یک پیاده‌سازی متفاوت libc (برای مثال، musl) یا یک نسخه قبلی glibc (برای مثال، glibc-2.13) استفاده کند.</li>
        
            <li>حتی اگر cc-lfs بتواند روی pc اجرا شود، استفاده از آن روی pc خطر لینک شدن به کتابخانه‌های pc را ایجاد می‌کند، زیرا cc-lfs یک کامپایلر بومی است.</li>
        </ul>
        
        <p>بنابراین وقتی gcc مرحله ۲ را می‌سازیم، به سیستم ساخت دستور می‌دهیم که libgcc و libstdc++ را با cc1 بازسازی کند، اما libstdc++ را به libgcc تازه بازسازی شده به جای نسخه قدیمی و تنزل یافته لینک می‌کنیم. این کار باعث می‌شود libstdc++ بازسازی شده کاملاً کارآمد باشد.</p>
        
        <p>در فصل ۸ (یا "مرحله ۳")، تمام بسته‌های مورد نیاز برای سیستم LFS ساخته می‌شوند. حتی اگر یک بسته قبلاً در یک فصل قبلی در سیستم LFS نصب شده باشد، ما همچنان بسته را بازسازی می‌کنیم. دلیل اصلی بازسازی این بسته‌ها این است که آنها را پایدار کنیم: اگر ما یک بسته LFS را روی یک سیستم LFS تکمیل شده دوباره نصب کنیم، محتوای دوباره نصب شده بسته باید همان محتوای همان بسته باشد که برای اولین بار در فصل ۸ نصب شده است. بسته‌های موقتی نصب شده در فصل ۶ یا فصل ۷ نمی‌توانند این الزام را برآورده کنند، زیرا برخی از آنها بدون وابستگی‌های اختیاری ساخته می‌شوند، و autoconf نمی‌تواند برخی بررسی‌های ویژگی را در فصل ۶ به دلیل کامپایل متقابل انجام دهد، که باعث می‌شود بسته‌های موقتی فاقد ویژگی‌های اختیاری باشند یا از روتین‌های کد بهینه استفاده نکنند. علاوه بر این، یک دلیل جزئی برای بازسازی بسته‌ها، اجرای مجموعه آزمون‌ها است.</p>
        
        <h2 id="other-details">سایر جزئیات رویه‌ای</h2>
        
        <p>کامپایلر متقابل در یک دایرکتوری جداگانه $LFS/tools نصب خواهد شد، زیرا بخشی از سیستم نهایی نخواهد بود.</p>
        
        <p>Binutils اول نصب می‌شود زیرا اجراهای configure هم gcc و هم glibc چندین آزمایش ویژگی روی اسمبلر و لینکر انجام می‌دهند تا تعیین کنند کدام ویژگی‌های نرم‌افزاری را فعال یا غیرفعال کنند. این مهم‌تر از آن چیزی است که ممکن است در ابتدا تصور کنید. یک gcc یا glibc نادرست پیکربندی شده می‌تواند منجر به یک زنجیره ابزار به طور ظریف خراب شود، که تأثیر چنین خرابی ممکن است تا نزدیک به پایان ساخت یک توزیع کامل نمایان نشود. یک شکست در مجموعه آزمون معمولاً این خطا را قبل از انجام کار اضافی زیاد برجسته خواهد کرد.</p>
        
        <p>Binutils اسمبلر و لینکر خود را در دو مکان نصب می‌کند، $LFS/tools/bin و $LFS/tools/$LFS_TGT/bin. ابزارها در یک مکان به صورت سخت به دیگری لینک شده‌اند. یک جنبه مهم لینکر، ترتیب جستجوی کتابخانه آن است. اطلاعات دقیق را می‌توان از ld با ارسال پرچم --verbose به آن به دست آورد. برای مثال، $LFS_TGT-ld --verbose | grep SEARCH مسیرهای جستجوی فعلی و ترتیب آنها را نشان خواهد داد. (توجه داشته باشید که این مثال را فقط زمانی می‌توان به همین صورت اجرا کرد که به عنوان کاربر lfs وارد شده باشید. اگر بعداً به این صفحه برگردید، $LFS_TGT-ld را با ld جایگزین کنید).</p>
        
        <p>بسته بعدی نصب شده gcc است. یک نمونه از آنچه می‌توان در طول اجرای configure آن دید این است:</p>
        
        <pre><code>checking what assembler to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/aschecking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld</code></pre>
        <p>این مهم است به دلایلی که در بالا ذکر شد. همچنین نشان می‌دهد که اسکریپت configure gcc در دایرکتوری‌های PATH جستجو نمی‌کند تا بفهمد از کدام ابزارها استفاده کند. با این حال، در طول عملیات واقعی gcc، لزوماً از همان مسیرهای جستجو استفاده نمی‌شود. برای فهمیدن اینکه gcc از کدام لینکر استاندارد استفاده خواهد کرد، این را اجرا کنید: $LFS_TGT-gcc -print-prog-name=ld. (دوباره، اگر بعداً به اینجا برمی‌گردید، پیشوند $LFS_TGT- را حذف کنید.)</p>

<p>اطلاعات دقیق را می‌توان از gcc با ارسال گزینه خط فرمان -v هنگام کامپایل یک برنامه به دست آورد. برای مثال، $LFS_TGT-gcc -v example.c (یا بدون $LFS_TGT- ا<p>برای مثال، $LFS_TGT-gcc -v example.c (یا بدون $LFS_TGT- اگر بعداً برمی‌گردید) اطلاعات دقیقی درباره مراحل پیش‌پردازنده، کامپایل و اسمبلی نشان خواهد داد، از جمله مسیرهای جستجوی gcc برای هدرهای شامل شده و ترتیب آنها.</p>

<p>بعدی: هدرهای API لینوکس پاکسازی شده. این‌ها به کتابخانه استاندارد C (glibc) اجازه می‌دهند با ویژگی‌هایی که هسته لینوکس ارائه خواهد کرد، ارتباط برقرار کند.</p>

<p>بعد از آن glibc می‌آید. مهم‌ترین ملاحظات برای ساخت glibc، کامپایلر، ابزارهای باینری و هدرهای هسته هستند. کامپایلر و ابزارهای باینری معمولاً مشکلی ایجاد نمی‌کنند زیرا glibc همیشه از آنهایی استفاده می‌کند که به پارامتر --host ارسال شده به اسکریپت configure آن مربوط می‌شوند؛ برای مثال، در مورد ما، کامپایلر $LFS_TGT-gcc و ابزار readelf $LFS_TGT-readelf خواهند بود. هدرهای هسته می‌توانند کمی پیچیده‌تر باشند. بنابراین، ما هیچ ریسکی نمی‌کنیم و از سوئیچ configure موجود برای اجبار انتخاب صحیح استفاده می‌کنیم. پس از اجرای configure، محتویات فایل config.make را در دایرکتوری build برای تمام جزئیات مهم بررسی کنید. این موارد جنبه مهمی از بسته glibc را برجسته می‌کنند - از نظر ماشین ساخت خود بسیار خودکفا است و عموماً به پیش‌فرض‌های زنجیره ابزار متکی نیست.</p>

<p>همانطور که در بالا ذکر شد، کتابخانه استاندارد ++C بعد از آن کامپایل می‌شود، و به دنبال آن در فصل ۶ سایر برنامه‌هایی که باید برای شکستن وابستگی‌های دوری در زمان ساخت به صورت متقابل کامپایل شوند. مرحله نصب تمام این بسته‌ها از متغیر DESTDIR برای اجبار نصب در سیستم فایل LFS استفاده می‌کند.</p>

<p>در پایان فصل ۶، کامپایلر بومی LFS نصب می‌شود. ابتدا binutils-pass2 در همان دایرکتوری DESTDIR مانند سایر برنامه‌ها ساخته می‌شود، سپس دومین گذر gcc ساخته می‌شود، با حذف برخی کتابخانه‌های غیر حیاتی. به دلیل برخی منطق عجیب در اسکریپت configure gcc، CC_FOR_TARGET به cc تبدیل می‌شود وقتی میزبان همان هدف است، اما با سیستم ساخت متفاوت است. این دلیلی است که CC_FOR_TARGET=$LFS_TGT-gcc به صراحت به عنوان یکی از گزینه‌های پیکربندی اعلام می‌شود.</p>

<p>هنگام ورود به محیط chroot در فصل ۷، نصب‌های موقت برنامه‌های مورد نیاز برای عملکرد صحیح زنجیره ابزار انجام می‌شود. از این نقطه به بعد، زنجیره ابزار اصلی خودکفا و خودمیزبان است. در فصل ۸، نسخه‌های نهایی تمام بسته‌های مورد نیاز برای یک سیستم کاملاً کارآمد ساخته، آزمایش و نصب می‌شوند.</p>

<div class="navfooter">
    <p>
        <a href="introduction.html">قبلی</a> |
        <a href="generalinstructions.html">بعدی</a> |
        <a href="partintro.html">بالا</a> |
        <a href="../index.html">خانه</a>
    </p>
</div>
</body>
</html>