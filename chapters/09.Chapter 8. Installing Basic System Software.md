# فصل ۸. نصب نرم‌افزار پایه سیستم

## ۸.۱. مقدمه

در این فصل، ما شروع به ساخت جدی سیستم LFS می‌کنیم.

نصب این نرم‌افزارها ساده است. اگرچه در بسیاری از موارد دستورالعمل‌های نصب می‌توانند کوتاه‌تر و عمومی‌تر باشند، ما تصمیم گرفته‌ایم دستورالعمل‌های کامل را برای هر بسته ارائه دهیم تا احتمال اشتباه را به حداقل برسانیم. کلید یادگیری اینکه چه چیزی باعث کار کردن یک سیستم لینوکس می‌شود، دانستن این است که هر بسته برای چه استفاده می‌شود و چرا شما (یا سیستم) ممکن است به آن نیاز داشته باشید.

ما استفاده از بهینه‌سازی‌های سفارشی را توصیه نمی‌کنیم. آنها ممکن است باعث شوند یک برنامه کمی سریع‌تر اجرا شود، اما همچنین ممکن است مشکلات کامپایل و مشکلاتی هنگام اجرای برنامه ایجاد کنند. اگر یک بسته با بهینه‌سازی سفارشی کامپایل نمی‌شود، سعی کنید آن را بدون بهینه‌سازی کامپایل کنید و ببینید آیا این مشکل را حل می‌کند. حتی اگر بسته هنگام استفاده از بهینه‌سازی سفارشی کامپایل شود، خطر این وجود دارد که به دلیل تعاملات پیچیده بین کد و ابزارهای ساخت، به اشتباه کامپایل شده باشد. همچنین توجه داشته باشید که گزینه‌های `-march` و `-mtune` با مقادیری که در کتاب مشخص نشده‌اند آزمایش نشده‌اند. این ممکن است مشکلاتی را با بسته‌های toolchain (Binutils، GCC و Glibc) ایجاد کند. دستاوردهای کوچک بالقوه حاصل از سفارشی‌سازی بهینه‌سازی‌های کامپایلر اغلب با خطرات آن جبران می‌شود. سازندگان اولیه LFS تشویق می‌شوند که بدون بهینه‌سازی‌های سفارشی بسازند.

از طرف دیگر، ما بهینه‌سازی‌های فعال شده توسط پیکربندی پیش‌فرض بسته‌ها را حفظ می‌کنیم. علاوه بر این، گاهی اوقات ما به طور صریح یک پیکربندی بهینه‌سازی شده را که توسط یک بسته ارائه شده اما به طور پیش‌فرض فعال نیست، فعال می‌کنیم. نگهدارندگان بسته‌ها قبلاً این پیکربندی‌ها را آزمایش کرده‌اند و آنها را ایمن می‌دانند، بنابراین احتمال اینکه ساخت را خراب کنند کم است. به طور کلی پیکربندی پیش‌فرض قبلاً `-O2` یا `-O3` را فعال می‌کند، بنابراین سیستم حاصل بدون هیچ بهینه‌سازی سفارشی همچنان بسیار سریع اجرا خواهد شد و در عین حال پایدار خواهد بود.

قبل از دستورالعمل‌های نصب، هر صفحه نصب اطلاعاتی درباره بسته ارائه می‌دهد، از جمله توضیح مختصری از آنچه شامل می‌شود، تقریباً چه مدت زمانی برای ساخت لازم است، و چقدر فضای دیسک در طول این فرآیند ساخت مورد نیاز است. پس از دستورالعمل‌های نصب، فهرستی از برنامه‌ها و کتابخانه‌ها (همراه با توضیحات مختصر) که بسته نصب می‌کند، وجود دارد.

**نکته**: مقادیر SBU و فضای دیسک مورد نیاز شامل داده‌های مجموعه آزمون برای تمام بسته‌های قابل اجرا در فصل 8 است. مقادیر SBU با استفاده از چهار هسته CPU (-j4) برای تمام عملیات محاسبه شده‌اند مگر اینکه به طور دیگری مشخص شده باشد.

### ۸.۱.۱. درباره کتابخانه‌ها

به طور کلی، ویراستاران LFS ساخت و نصب کتابخانه‌های استاتیک را توصیه نمی‌کنند. اکثر کتابخانه‌های استاتیک در یک سیستم لینوکس مدرن منسوخ شده‌اند. علاوه بر این، پیوند یک کتابخانه استاتیک به یک برنامه می‌تواند مضر باشد. اگر به‌روزرسانی کتابخانه برای رفع یک مشکل امنیتی لازم باشد، هر برنامه‌ای که از کتابخانه استاتیک استفاده می‌کند باید با کتابخانه جدید دوباره پیوند داده شود. از آنجا که استفاده از کتابخانه‌های استاتیک همیشه آشکار نیست، برنامه‌های مربوطه (و روش‌های لازم برای انجام پیوند) ممکن است حتی شناخته نشده باشند.

روش‌های این فصل نصب اکثر کتابخانه‌های استاتیک را حذف یا غیرفعال می‌کنند. معمولاً این کار با دادن گزینه `--disable-static` به **configure** انجام می‌شود. در موارد دیگر، به روش‌های جایگزین نیاز است. در چند مورد، به خصوص Glibc و GCC، استفاده از کتابخانه‌های استاتیک همچنان یک ویژگی ضروری فرآیند ساخت بسته است.

برای بحث کامل‌تر درباره کتابخانه‌ها، به "کتابخانه‌ها: استاتیک یا اشتراکی؟" در کتاب BLFS مراجعه کنید.

# ۸.۲. مدیریت بسته

مدیریت بسته اغلب یک افزودنی درخواست شده به کتاب LFS است. یک مدیر بسته نصب فایل‌ها را پیگیری می‌کند و حذف و ارتقاء بسته‌ها را آسان‌تر می‌کند. یک مدیر بسته خوب همچنین با فایل‌های پیکربندی به طور ویژه‌ای برخورد می‌کند تا پیکربندی کاربر را هنگام نصب مجدد یا ارتقاء بسته حفظ کند. قبل از اینکه شروع به تعجب کنید، خیر - این بخش درباره هیچ مدیر بسته خاصی صحبت نمی‌کند یا آن را توصیه نمی‌کند. آنچه ارائه می‌دهد خلاصه‌ای از تکنیک‌های محبوب‌تر و نحوه کار آنهاست. مدیر بسته ایده‌آل برای شما ممکن است در میان این تکنیک‌ها باشد، یا ممکن است ترکیبی از دو یا چند مورد از این تکنیک‌ها باشد. این بخش به طور مختصر به مسائلی که ممکن است هنگام ارتقاء بسته‌ها پیش بیاید اشاره می‌کند.

برخی از دلایلی که هیچ مدیر بسته‌ای در LFS یا BLFS ذکر نشده است عبارتند از:

- پرداختن به مدیریت بسته تمرکز را از اهداف این کتاب‌ها - آموزش نحوه ساخت یک سیستم لینوکس - دور می‌کند.
- راه حل‌های متعددی برای مدیریت بسته وجود دارد که هر کدام نقاط قوت و ضعف خود را دارند. یافتن یک راه حل که همه مخاطبان را راضی کند دشوار است.

برخی نکات در مورد موضوع مدیریت بسته نوشته شده است. از پروژه Hints بازدید کنید و ببینید آیا یکی از آنها مناسب نیازهای شما است.

## ۸.۲.۱. مسائل ارتقاء

یک مدیر بسته ارتقاء به نسخه‌های جدیدتر را هنگام انتشار آسان می‌کند. عموماً دستورالعمل‌های کتاب‌های LFS و BLFS را می‌توان برای ارتقاء به نسخه‌های جدیدتر استفاده کرد. در اینجا چند نکته است که باید هنگام ارتقاء بسته‌ها، به خصوص در یک سیستم در حال اجرا، از آنها آگاه باشید:

- اگر هسته لینوکس نیاز به ارتقاء دارد (برای مثال، از 5.10.17 به 5.10.18 یا 5.11.1)، چیز دیگری نیاز به بازسازی ندارد. سیستم به لطف رابط خوب تعریف شده بین هسته و فضای کاربر به خوبی کار خواهد کرد. به طور خاص، سرآیندهای API لینوکس نیازی به ارتقاء همراه با هسته ندارند. شما فقط باید سیستم خود را مجدداً راه‌اندازی کنید تا از هسته ارتقاء یافته استفاده کنید.

- اگر Glibc نیاز به ارتقاء به نسخه جدیدتر دارد (مثلاً از Glibc-2.36 به Glibc-2.40)، برخی مراحل اضافی برای جلوگیری از خراب شدن سیستم لازم است. برای جزئیات به بخش 8.5، "Glibc-2.40" مراجعه کنید.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر کند، هر بسته‌ای که به صورت پویا به کتابخانه پیوند داده شده است باید مجدداً کامپایل شود تا با کتابخانه جدیدتر پیوند داده شود. (توجه داشته باشید که هیچ ارتباطی بین نسخه بسته و نام کتابخانه وجود ندارد.) برای مثال، یک بسته foo-1.2.3 را در نظر بگیرید که یک کتابخانه اشتراکی با نام libfoo.so.1 نصب می‌کند. فرض کنید شما بسته را به نسخه جدیدتر foo-1.2.4 ارتقاء می‌دهید که یک کتابخانه اشتراکی با نام libfoo.so.2 نصب می‌کند. در این صورت، هر بسته‌ای که به صورت پویا به libfoo.so.1 پیوند داده شده است، باید مجدداً کامپایل شود تا با libfoo.so.2 پیوند داده شود تا از نسخه جدید کتابخانه استفاده کند. نباید کتابخانه‌های قدیمی را تا زمانی که تمام بسته‌های وابسته مجدداً کامپایل نشده‌اند حذف کنید.

- اگر یک بسته (به طور مستقیم یا غیرمستقیم) به هر دو نام قدیمی و جدید یک کتابخانه اشتراکی پیوند داده شده باشد (برای مثال، بسته هم به libfoo.so.2 و هم به libbar.so.1 پیوند داده شده است، در حالی که دومی به libfoo.so.3 پیوند داده شده است)، ممکن است بسته بد عمل کند زیرا نسخه‌های مختلف کتابخانه اشتراکی تعاریف ناسازگاری برای برخی نام‌های نماد ارائه می‌دهند. این می‌تواند ناشی از کامپایل مجدد برخی، اما نه همه، بسته‌های پیوند داده شده به کتابخانه اشتراکی قدیمی پس از ارتقاء بسته ارائه دهنده کتابخانه اشتراکی باشد. برای جلوگیری از این مشکل، کاربران باید هر بسته پیوند داده شده به یک کتابخانه اشتراکی با نسخه به‌روز شده (مثلاً از libfoo.so.2 به libfoo.so.3) را در اسرع وقت مجدداً بسازند.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر نکند، اما شماره نسخه فایل کتابخانه کاهش یابد (برای مثال، کتابخانه همچنان libfoo.so.1 نام دارد، اما نام فایل کتابخانه از libfoo.so.1.25 به libfoo.so.1.24 تغییر کرده است)، باید فایل کتابخانه از نسخه قبلاً نصب شده را حذف کنید (در این مورد libfoo.so.1.25). در غیر این صورت، یک دستور ldconfig (که توسط خودتان از خط فرمان یا توسط نصب برخی بسته‌ها فراخوانی می‌شود) پیوند نمادین libfoo.so.1 را مجدداً تنظیم می‌کند تا به فایل کتابخانه قدیمی اشاره کند زیرا به نظر می‌رسد یک نسخه "جدیدتر" است؛ شماره نسخه آن بزرگتر است. این وضعیت ممکن است در صورتی که مجبور به کاهش نسخه یک بسته باشید یا اگر نویسندگان طرح نسخه‌بندی را برای فایل‌های کتابخانه تغییر دهند، پیش بیاید.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر نکند، اما یک مشکل جدی (به خصوص، یک آسیب‌پذیری امنیتی) برطرف شود، تمام برنامه‌های در حال اجرا که به کتابخانه اشتراکی پیوند داده شده‌اند باید مجدداً راه‌اندازی شوند. دستور زیر، که پس از اتمام به‌روزرسانی به عنوان root اجرا می‌شود، فرآیندهایی را که از نسخه‌های قدیمی این کتابخانه‌ها استفاده می‌کنند لیست می‌کند (libfoo را با نام کتابخانه جایگزین کنید):

  ```
  grep -l 'libfoo.*deleted' /proc/*/maps | tr -cd 0-9\\n | xargs -r ps u
  ```

- اگر از OpenSSH برای دسترسی به سیستم استفاده می‌شود و به کتابخانه به‌روز شده پیوند داده شده است، باید سرویس sshd را مجدداً راه‌اندازی کنید، سپس خارج شوید، دوباره وارد شوید و دستور قبلی را مجدداً اجرا کنید تا تأیید کنید که هیچ چیز هنوز از کتابخانه‌های حذف شده استفاده نمی‌کند.

- اگر یک برنامه اجرایی یا یک کتابخانه اشتراکی بازنویسی شود، فرآیندهایی که از کد یا داده در آن برنامه یا کتابخانه استفاده می‌کنند ممکن است از کار بیفتند. روش صحیح به‌روزرسانی یک برنامه یا کتابخانه اشتراکی بدون ایجاد خرابی در فرآیند، حذف آن و سپس نصب نسخه جدید است. دستور install ارائه شده توسط coreutils این را پیاده‌سازی کرده است و اکثر بسته‌ها از آن دستور برای نصب فایل‌های باینری و کتابخانه‌ها استفاده می‌کنند. این بدان معناست که اکثر اوقات با این مشکل مواجه نخواهید شد. با این حال، فرآیند نصب برخی بسته‌ها (به طور خاص SpiderMonkey در BLFS) فقط فایل را در صورت وجود بازنویسی می‌کند؛ این باعث خرابی می‌شود. بنابراین، ایمن‌تر است که کار خود را ذخیره کنید و فرآیندهای در حال اجرای غیرضروری را قبل از به‌روزرسانی یک بسته ببندید.

## ۸.۲.۲. تکنیک‌های مدیریت بسته

در ادامه برخی از تکنیک‌های رایج مدیریت بسته آمده است. قبل از تصمیم‌گیری در مورد یک مدیر بسته، در مورد تکنیک‌های مختلف تحقیق کنید، به خصوص معایب هر طرح خاص.

### ۸.۲.۲.۱. همه چیز در سر من است!

بله، این یک تکنیک مدیریت بسته است. برخی افراد به مدیر بسته نیاز ندارند زیرا بسته‌ها را به خوبی می‌شناسند و می‌دانند کدام فایل‌ها توسط هر بسته نصب می‌شوند. برخی کاربران همچنین به هیچ مدیریت بسته‌ای نیاز ندارند زیرا قصد دارند هر زمان که یک بسته تغییر کرد، کل سیستم را مجدداً بسازند.

### ۸.۲.۲.۲. نصب در دایرکتوری‌های جداگانه

این یک تکنیک مدیریت بسته ساده است که به برنامه خاصی برای مدیریت بسته‌ها نیاز ندارد. هر بسته در یک دایرکتوری جداگانه نصب می‌شود. برای مثال، بسته foo-1.1 در /opt/foo-1.1 نصب می‌شود و یک پیوند نمادین از /opt/foo به /opt/foo-1.

# ۸.۳. Man-pages-6.9.1

بسته Man-pages شامل بیش از 2,400 صفحه راهنما است.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 52 مگابایت

## ۸.۳.۱. نصب Man-pages

دو صفحه راهنما برای توابع رمزگذاری رمز عبور را حذف کنید. Libxcrypt نسخه بهتری از این صفحات راهنما را ارائه خواهد داد:

```bash
rm -v man3/crypt*
```

Man-pages را با اجرای دستور زیر نصب کنید:

```bash
make prefix=/usr install
```

## ۸.۳.۲. محتویات Man-pages

**فایل‌های نصب شده:** صفحات راهنمای مختلف

توضیحات کوتاه:

`man pages`
توابع زبان برنامه‌نویسی C، فایل‌های دستگاه مهم و فایل‌های پیکربندی قابل توجه را توصیف می‌کند.

# ۸.۴. Iana-Etc-20240806

بسته Iana-Etc داده‌هایی برای سرویس‌ها و پروتکل‌های شبکه ارائه می‌دهد.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 4.8 مگابایت

## ۸.۴.۱. نصب Iana-Etc

برای این بسته، ما فقط نیاز داریم فایل‌ها را در جای خود کپی کنیم:

```bash
cp services protocols /etc
```

## ۸.۴.۲. محتویات Iana-Etc

**فایل‌های نصب شده:** /etc/protocols و /etc/services

توضیحات کوتاه:

`/etc/protocols`
پروتکل‌های مختلف اینترنت DARPA را که از زیرسیستم TCP/IP در دسترس هستند توصیف می‌کند.

`/etc/services`
نگاشتی بین نام‌های متنی دوستانه برای سرویس‌های اینترنتی و شماره‌های پورت و انواع پروتکل‌های اختصاص داده شده به آنها ارائه می‌دهد.

این متن بسیار طولانی است و ترجمه کامل آن در یک پاسخ ممکن نیست. من آن را به چند بخش تقسیم کرده و ترجمه خواهم کرد. اینجا بخش اول ترجمه است:

# ۸.۵. Glibc-2.40

بسته Glibc حاوی کتابخانه اصلی C است. این کتابخانه روال‌های پایه برای تخصیص حافظه، جستجوی دایرکتوری‌ها، باز و بسته کردن فایل‌ها، خواندن و نوشتن فایل‌ها، مدیریت رشته‌ها، تطبیق الگو، محاسبات ریاضی و غیره را فراهم می‌کند.

**زمان تقریبی ساخت:** 12 SBU
**فضای دیسک مورد نیاز:** 3.1 گیگابایت

## ۸.۵.۱. نصب Glibc

برخی از برنامه‌های Glibc از دایرکتوری /var/db که مطابق با FHS نیست برای ذخیره داده‌های زمان اجرا استفاده می‌کنند. وصله زیر را اعمال کنید تا چنین برنامه‌هایی داده‌های زمان اجرای خود را در مکان‌های مطابق با FHS ذخیره کنند:

```bash
patch -Np1 -i ../glibc-2.40-fhs-1.patch
```

مستندات Glibc توصیه می‌کند که Glibc را در یک دایرکتوری ساخت اختصاصی بسازید:

```bash
mkdir -v build
cd       build
```

اطمینان حاصل کنید که ابزارهای ldconfig و sln در /usr/sbin نصب خواهند شد:

```bash
echo "rootsbindir=/usr/sbin" > configparms
```

Glibc را برای کامپایل آماده کنید:

```bash
../configure --prefix=/usr                            \
             --disable-werror                         \
             --enable-kernel=4.19                     \
             --enable-stack-protector=strong          \
             --disable-nscd                           \
             libc_cv_slibdir=/usr/lib
```

معنی گزینه‌های پیکربندی:

`--disable-werror`
    این گزینه گزینه -Werror را که به GCC منتقل می‌شود غیرفعال می‌کند. این برای اجرای مجموعه آزمون ضروری است.

`--enable-kernel=4.19`
    این گزینه به سیستم ساخت می‌گوید که این Glibc ممکن است با هسته‌هایی به قدمت 4.19 استفاده شود. این به معنای تولید راه حل‌های جایگزین در صورتی است که یک فراخوانی سیستمی معرفی شده در نسخه بعدی نتواند استفاده شود.

`--enable-stack-protector=strong`
    این گزینه امنیت سیستم را با افزودن کد اضافی برای بررسی سرریز بافر، مانند حملات stack smashing افزایش می‌دهد. توجه داشته باشید که Glibc همیشه به صراحت پیش‌فرض GCC را لغو می‌کند، بنابراین این گزینه حتی با وجود اینکه ما قبلاً --enable-default-ssp را برای GCC مشخص کرده‌ایم، همچنان مورد نیاز است.

`--disable-nscd`
    دیمون کش سرویس نام را که دیگر استفاده نمی‌شود نسازید.

`libc_cv_slibdir=/usr/lib`
    این متغیر کتابخانه صحیح را برای تمام سیستم‌ها تنظیم می‌کند. ما نمی‌خواهیم از lib64 استفاده شود.

بسته را کامپایل کنید:

```bash
make
```

**مهم**: در این بخش، مجموعه آزمون برای Glibc بحرانی در نظر گرفته می‌شود. تحت هیچ شرایطی آن را نادیده نگیرید.

معمولاً چند آزمون با موفقیت انجام نمی‌شوند. شکست‌های آزمون ذکر شده در زیر معمولاً برای نادیده گرفتن ایمن هستند.

```bash
make check
```

ممکن است برخی شکست‌های آزمون را مشاهده کنید. مجموعه آزمون Glibc تا حدودی به سیستم میزبان وابسته است. چند شکست از بیش از 5000 آزمون را می‌توان به طور کلی نادیده گرفت. این فهرستی از رایج‌ترین مسائل مشاهده شده برای نسخه‌های اخیر LFS است:

- io/tst-lchmod در محیط chroot LFS با شکست مواجه می‌شود.

- برخی آزمون‌ها، مانند nss/tst-nss-files-hosts-multi و nptl/tst-thread-affinity* به دلیل timeout (به ویژه زمانی که سیستم نسبتاً کند است و/یا مجموعه آزمون با چندین کار موازی make اجرا می‌شود) با شکست مواجه می‌شوند. این آزمون‌ها را می‌توان با دستور زیر شناسایی کرد:

```bash
grep "Timed out" $(find -name \*.out)
```

امکان اجرای مجدد یک آزمون منفرد با timeout افزایش یافته با TIMEOUTFACTOR=<factor> make test t=<test name> وجود دارد. برای مثال، TIMEOUTFACTOR=10 make test t=nss/tst-nss-files-hosts-multi آزمون nss/tst-nss-files-hosts-multi را با ده برابر timeout اصلی مجدداً اجرا خواهد کرد.

- علاوه بر این، برخی آزمون‌ها ممکن است با یک مدل CPU نسبتاً قدیمی (برای مثال elf/tst-cpu-features-cpuinfo) یا نسخه هسته میزبان (برای مثال stdlib/tst-arc4random-thread) با شکست مواجه شوند.

اگرچه این یک پیام بی‌ضرر است، مرحله نصب Glibc از عدم وجود /etc/ld.so.conf شکایت خواهد کرد. از این هشدار با دستور زیر جلوگیری کنید:

```bash
touch /etc/ld.so.conf
```

Makefile را اصلاح کنید تا یک بررسی قدیمی سلامت را که با پیکربندی مدرن Glibc شکست می‌خورد، نادیده بگیرد:

```bash
sed '/test-installation/s@$(PERL)@echo not running@' -i ../Makefile
```

**مهم**: اگر Glibc را به یک نسخه فرعی جدید (برای مثال، از Glibc-2.36 به Glibc-2.40) در یک سیستم LFS در حال اجرا ارتقاء می‌دهید، باید برخی اقدامات احتیاطی اضافی را برای جلوگیری از خراب شدن سیستم انجام دهید:

- ارتقاء Glibc در یک سیستم LFS قبل از 11.0 (به استثنای) پشتیبانی نمی‌شود. اگر چنین سیستم LFS قدیمی را اجرا می‌کنید اما به یک Glibc جدیدتر نیاز دارید، LFS را بازسازی کنید.

- اگر در یک سیستم LFS قبل از 12.0 (به استثنای) ارتقاء می‌دهید، Libxcrypt را مطابق با بخش 8.27، "Libxcrypt-4.4.36" نصب کنید. علاوه بر نصب عادی Libxcrypt، باید یادداشت در بخش Libxcrypt را برای نصب libcrypt.so.1* (جایگزینی libcrypt.so.1 از نصب قبلی Glibc) دنبال کنید.

- اگر در یک سیستم LFS قبل از 12.1 (به استثنای) ارتقاء می‌دهید، برنامه nscd را حذف کنید:

```bash
rm -f /usr/sbin/nscd
```

- هسته را ارتقاء دهید و اگر قدیمی‌تر از 4.19 است (نسخه فعلی را با uname -r بررسی کنید) یا اگر می‌خواهید به هر حال آن را ارتقاء دهید، مطابق با بخش 10.3، "Linux-6.10.5" سیستم را مجدداً راه‌اندازی کنید.

- هدرهای API هسته را اگر قدیمی‌تر از 4.19 هستند (نسخه فعلی را با cat /usr/include/linux/version.h بررسی کنید) یا اگر می‌خواهید به هر حال آنها را ارتقاء دهید، مطابق با بخش 5.4، "Linux-6.10.5 API Headers" ارتقاء دهید (اما $LFS را از دستور cp حذف کنید).

- یک نصب DESTDIR انجام دهید و کتابخانه‌های اشتراکی Glibc را در سیستم با استفاده از یک دستور نصب واحد ارتقاء دهید:

```bash
make DESTDIR=$PWD/dest install
install -vm755 dest/usr/lib/*.so.* /usr/lib
```

ضروری است که دقیقاً این مراحل را دنبال کنید مگر اینکه کاملاً متوجه شوید چه کاری انجام می‌دهید. هر انحراف غیرمنتظره ممکن است سیستم را کاملاً غیرقابل استفاده کند. شما هشدار داده شده‌اید.

سپس به اجرای دستور make install، دستور sed در مقابل /usr/bin/ldd، و دستورات نصب locales ادامه دهید. پس از اتمام آنها، سیستم را فوراً مجدداً راه‌اندازی کنید.

بسته را نصب کنید:

```bash
make install
```

یک مسیر هارد کد شده به لودر اجرایی را در اسکریپت ldd اصلاح کنید:

```bash
sed '/RTLDLIST=/s@/usr@@g' -i /usr/bin/ldd
```

سپس، locales را نصب کنید که می‌توانند باعث شوند سیستم به زبان‌های مختلف پاسخ دهد. هیچ یک از این locales الزامی نیستند، اما اگر برخی از آنها وجود نداشته باشند، مجموعه‌های آزمون برخی بسته‌ها موارد آزمون مهمی را نادیده خواهند گرفت.

locales فردی را می‌توان با استفاده از برنامه localedef نصب کرد. برای مثال، دومین دستور localedef در زیر تعریف locale مستقل از مجموعه کاراکتر /usr/share/i18n/locales/cs_CZ را با تعریف نقشه کاراکتر /usr/share/i18n/charmaps/UTF-8.gz ترکیب می‌کند و نتیجه را به فایل /usr/lib/locale/locale-archive اضافه می‌کند. دستورالعمل‌های زیر مجموعه حداقلی از locales لازم برای پوشش بهینه آزمون‌ها را نصب خواهند کرد:

```bash
localedef -i C -f UTF-8 C.UTF-8
localedef -i cs_CZ -f UTF-8 cs_CZ.UTF-8
localedef -i de_DE -f ISO-8859-1 de_DE
localedef -i de_DE@euro -f ISO-8859-15 de_DE@euro
localedef -i de_DE -f UTF-8 de_DE.UTF-8
localedef -i el_GR -f ISO-8859-7 el_GR
localedef -i en_GB -f ISO-8859-1 en_GB
localedef -i en_GB -f UTF-8 en_GB.UTF-8
localedef -i en_HK -f ISO-8859-1 en_HK
localedef -i en_PH -f ISO-8859-1 en_PH
localedef -i en_US -f ISO-8859-1 en_US
localedef -i en_US -f UTF-8 en_US.UTF-8
localedef -i es_ES -f ISO-8859-15 es_ES@euro
localedef -i es_MX -f ISO-8859-1 es_MX
localedef -i fa_IR -f UTF-8 fa_IR
localedef -i fr_FR -f ISO-8859-1 fr_FR
localedef -i fr_FR@euro -f ISO-859-15 fr_FR@euro
localedef -i fr_FR -f UTF-8 fr_FR.UTF-8
localedef -i is_IS -f ISO-8859-1 is_IS
localedef -i is_IS -f UTF-8 is_IS.UTF-8
localedef -i it_IT -f ISO-8859-1 it_IT
localedef -i it_IT -f ISO-8859-15 it_IT@euro
localedef -i it_IT -f UTF-8 it_IT.UTF-8
localedef -i ja_JP -f EUC-JP ja_JP
localedef -i ja_JP -f SHIFT_JIS ja_JP.SJIS 2> /dev/null || true
localedef -i ja_JP -f UTF-8 ja_JP.UTF-8
localedef -i nl_NL@euro -f ISO-8859-15 nl_NL@euro
localedef -i ru_RU -f KOI8-R ru_RU.KOI8-R
localedef -i ru_RU -f UTF-8 ru_RU.UTF-8
localedef -i se_NO -f UTF-8 se_NO.UTF-8
localedef -i ta_IN -f UTF-8 ta_IN.UTF-8
localedef -i tr_TR -f UTF-8 tr_TR.UTF-8
localedef -i zh_CN -f GB18030 zh_CN.GB18030
localedef -i zh_HK -f BIG5-HKSCS zh_HK.BIG5-HKSCS
localedef -i zh_TW -f UTF-8 zh_TW.UTF-8
```

علاوه بر این، locale مربوط به کشور، زبان و مجموعه کاراکتر خود را نصب کنید.

به طور جایگزین، می‌توانید تمام locales ذکر شده در فایل glibc-2.40/localedata/SUPPORTED را (که شامل تمام locales ذکر شده در بالا و بسیاری دیگر است) یکجا با دستور زمان‌بر زیر نصب کنید:

```bash
make localedata/install-locales
```

سپس از دستور localedef برای ایجاد و نصب locales که در فایل glibc-2.40/localedata/SUPPORTED ذکر نشده‌اند استفاده کنید زمانی که به آنها نیاز دارید. برای مثال، دو locale زیر برای برخی آزمون‌ها در ادامه این فصل مورد نیاز است:

```bash
localedef -i C -f UTF-8 C.UTF-8
localedef -i ja_JP -f SHIFT_JIS ja_JP.SJIS 2> /dev/null || true
```

**نکته**: Glibc اکنون از libidn2 برای حل نام‌های دامنه بین‌المللی استفاده می‌کند. این یک وابستگی زمان اجرا است. اگر به این قابلیت نیاز دارید، دستورالعمل‌های نصب libidn2 در صفحه libidn2 BLFS موجود است.

## ۸.۵.۲. پیکربندی Glibc

### ۸.۵.۲.۱. افزودن nsswitch.conf

فایل /etc/nsswitch.conf باید ایجاد شود زیرا پیش‌فرض‌های Glibc در یک محیط شبکه‌ای به خوبی کار نمی‌کنند.

با اجرای دستور زیر یک فایل /etc/nsswitch.conf جدید ایجاد کنید:

```bash
cat > /etc/nsswitch.conf << "EOF"
# Begin /etc/nsswitch.conf

passwd: files
group: files
shadow: files

hosts: files dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

# End /etc/nsswitch.conf
EOF
```

### ۸.۵.۲.۲. افزودن داده منطقه زمانی

داده منطقه زمانی را با دستورات زیر نصب و تنظیم کنید:

```bash
tar -xf ../../tzdata2024a.tar.gz

ZONEINFO=/usr/share/zoneinfo
mkdir -pv $ZONEINFO/{posix,right}

for tz in etcetera southamerica northamerica europe africa antarctica  \
          asia australasia backward; do
    zic -L /dev/null   -d $ZONEINFO       ${tz}
    zic -L /dev/null   -d $ZONEINFO/posix ${tz}
    zic -L leapseconds -d $ZONEINFO/right ${tz}
done

cp -v zone.tab zone1970.tab iso3166.tab $ZONEINFO
zic -d $ZONEINFO -p America/New_York
unset ZONEINFO
```

معنی دستورات zic:

`zic -L /dev/null ...`
    این مناطق زمانی posix را بدون هیچ ثانیه کبیسه ایجاد می‌کند. قرارداد این است که آنها را هم در zoneinfo و هم در zoneinfo/posix قرار دهیم. لازم است مناطق زمانی POSIX را در zoneinfo قرار دهیم، در غیر این صورت برخی مجموعه‌های آزمون خطاهایی را گزارش خواهند کرد. در یک سیستم تعبیه شده، که فضا محدود است و قصد ندارید هرگز مناطق زمانی را به‌روز کنید، می‌توانید با استفاده نکردن از دایرکتوری posix، 1.9 مگابایت صرفه‌جویی کنید، اما برخی برنامه‌ها یا مجموعه‌های آزمون ممکن است برخی خطاها تولید کنند.

`zic -L leapseconds ...`
    این مناطق زمانی صحیح را ایجاد می‌کند، از جمله ثانیه‌های کبیسه. در یک سیستم تعبیه شده، که فضا محدود است و قصد ندارید هرگز مناطق زمانی را به‌روز کنید، یا به زمان دقیق اهمیت نمی‌دهید، می‌توانید با حذف دایرکتوری right، 1.9 مگابایت صرفه‌جویی کنید.

`zic ... -p ...`
    این فایل posixrules را ایجاد می‌کند. ما از نیویورک استفاده می‌کنیم زیرا POSIX نیاز دارد که قوانین ساعت تابستانی مطابق با قوانین ایالات متحده باشد.

یک راه برای تعیین منطقه زمانی محلی، اجرای اسکریپت زیر است:

```bash
tzselect
```

پس از پاسخ به چند سؤال در مورد مکان، اسکریپت نام منطقه زمانی را خروجی می‌دهد (مثلاً America/Edmonton). همچنین برخی مناطق زمانی دیگر احتمالی در /usr/share/zoneinfo مانند Canada/Eastern یا EST5EDT ذکر شده‌اند که توسط اسکریپت شناسایی نمی‌شوند اما می‌توان از آنها استفاده کرد.

سپس با اجرای دستور زیر فایل /etc/localtime را ایجاد کنید:

```bash
ln -sfv /usr/share/zoneinfo/<xxx> /etc/localtime
```

<xxx> را با نام منطقه زمانی انتخاب شده جایگزین کنید (مثلاً Canada/Eastern).

### ۸.۵.۲.۳. پیکربندی لودر پویا

به طور پیش‌فرض، لودر پویا (/lib/ld-linux.so.2) از طریق /usr/lib به دنبال کتابخانه‌های پویایی می‌گردد که توسط برنامه‌ها هنگام اجرا مورد نیاز هستند. با این حال، اگر کتابخانه‌هایی در دایرکتوری‌های دیگری غیر از /usr/lib وجود داشته باشند، این‌ها باید به فایل /etc/ld.so.conf اضافه شوند تا لودر پویا آنها را پیدا کند. دو دایرکتوری که معمولاً شناخته شده‌اند که حاوی کتابخانه‌های اضافی هستند /usr/local/lib و /opt/lib هستند، بنابراین این دایرکتوری‌ها را به مسیر جستجوی لودر پویا اضافه کنید.

با اجرای دستور زیر یک فایل /etc/ld.so.conf جدید ایجاد کنید:

```bash
cat > /etc/ld.so.conf << "EOF"
# Begin /etc/ld.so.conf
/usr/local/lib
/opt/lib

EOF
```

اگر مورد نظر است، لودر پویا می‌تواند همچنین یک دایرکتوری را جستجو کند و محتویات فایل‌های یافت شده در آنجا را شامل کند. عموماً فایل‌ها در این دایرکتوری شامل یک خط مشخص کننده مسیر کتابخانه مورد نظر هستند. برای افزودن این قابلیت دستورات زیر را اجرا کنید:

```bash
cat >> /etc/ld.so.conf << "EOF"
# Add an include directory
include /etc/ld.so.conf.d/*.conf

EOF
mkdir -pv /etc/ld.so.conf.d
```

## ۸.۵.۳. محتویات Glibc

**برنامه‌های نصب شده:**
gencat, getconf, getent, iconv, iconvconfig, ldconfig, ldd, lddlibc4, ld.so (پیوند نمادین به ld-linux-x86-64.so.2 یا ld-linux.so.2), locale, localedef, makedb, mtrace, pcprofiledump, pldd, sln, sotruss, sprof, tzselect, xtrace, zdump, و zic

**کتابخانه‌های نصب شده:**
ld-linux-x86-64.so.2, ld-linux.so.2, libBrokenLocale.{a,so}, libanl.{a,so}, libc.{a,so}, libc_nonshared.a, libc_malloc_debug.so, libdl.{a,so.2}, libg.a, libm.{a,so}, libmcheck.a, libmemusage.so, libmvec.{a,so}, libnsl.so.1, libnss_compat.so, libnss_dns.so, libnss_files.so, libnss_hesiod.so, libpcprofile.so, libpthread.{a,so.0}, libresolv.{a,so}, librt.{a,so.1}, libthread_db.so, و libutil.{a,so.1}

**دایرکتوری‌های نصب شده:**
/usr/include/arpa, /usr/include/bits, /usr/include/gnu, /usr/include/net, /usr/include/netash, /usr/include/netatalk, /usr/include/netax25, /usr/include/neteconet, /usr/include/netinet, /usr/include/netipx, /usr/include/netiucv, /usr/include/netpacket, /usr/include/netrom, /usr/include/netrose, /usr/include/nfs, /usr/include/protocols, /usr/include/rpc, /usr/include/sys, /usr/lib/audit, /usr/lib/gconv, /usr/lib/locale, /usr/libexec/getconf, /usr/share/i18n, /usr/share/zoneinfo, و /var/lib/nss_db

**توضیحات کوتاه:**

`gencat`
کاتالوگ‌های پیام تولید می‌کند

`getconf`
مقادیر پیکربندی سیستم را برای متغیرهای خاص سیستم فایل نمایش می‌دهد

`getent`
ورودی‌ها را از یک پایگاه داده اداری دریافت می‌کند

`iconv`
تبدیل مجموعه کاراکتر را انجام می‌دهد

`iconvconfig`
فایل‌های پیکربندی ماژول iconv با بارگذاری سریع ایجاد می‌کند

`ldconfig`
پیوندهای زمان اجرای لینکر پویا را پیکربندی می‌کند

`ldd`
گزارش می‌دهد که کدام کتابخانه‌های اشتراکی برای هر برنامه یا کتابخانه اشتراکی داده شده مورد نیاز هستند

`lddlibc4`
به ldd با فایل‌های شیء کمک می‌کند. در معماری‌های جدیدتر مانند x86_64 وجود ندارد

`locale`
اطلاعات مختلفی در مورد locale فعلی چاپ می‌کند

`localedef`
مشخصات locale را کامپایل می‌کند

`makedb`
یک پایگاه داده ساده از ورودی متنی ایجاد می‌کند

`mtrace`
یک فایل ردیابی حافظه را می‌خواند و تفسیر می‌کند و خلاصه‌ای را به فرمت قابل خواندن توسط انسان نمایش می‌دهد

`pcprofiledump`
اطلاعات تولید شده توسط پروفایل PC را تخلیه می‌کند

`pldd`
اشیاء اشتراکی پویا مورد استفاده توسط فرآیندهای در حال اجرا را لیست می‌کند

`sln`
یک برنامه ln پیوند شده به صورت استاتیک

`sotruss`
فراخوانی‌های روال کتابخانه اشتراکی یک دستور مشخص شده را ردیابی می‌کند

`sprof`
داده‌های پروفایل شیء اشتراکی را می‌خواند و نمایش می‌دهد

`tzselect`
از کاربر در مورد مکان سیستم می‌پرسد و توصیف منطقه زمانی مربوطه را گزارش می‌کند

`xtrace`
اجرای یک برنامه را با چاپ تابع در حال اجرای فعلی ردیابی می‌کند

`zdump`
تخلیه‌کننده منطقه زمانی

`zic`
کامپایلر منطقه زمانی

`ld-*.so`
برنامه کمکی برای اجرای کتابخانه‌های اشتراکی

`libBrokenLocale`
توسط Glibc به عنوان یک هک خام برای اجرای برنامه‌های خراب (مثلاً برخی برنامه‌های Motif) استفاده می‌شود. برای اطلاعات بیشتر به نظرات در glibc-2.40/locale/broken_cur_max.c مراجعه کنید

`libanl`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً کتابخانه جستجوی نام ناهمزمان بود که توابع آن اکنون در libc هستند

`libc`
کتابخانه اصلی C

`libc_malloc_debug`
هنگام پیش‌بارگذاری، بررسی تخصیص حافظه را فعال می‌کند

`libdl`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً کتابخانه رابط پیوند پویا بود که توابع آن اکنون در libc هستند

`libg`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً یک کتابخانه زمان اجرا برای g++ بود

`libm`
کتابخانه ریاضی

`libmvec`
کتابخانه ریاضی برداری، در صورت نیاز هنگام استفاده از libm پیوند داده می‌شود

`libmcheck`
هنگام پیوند، بررسی تخصیص حافظه را فعال می‌کند

`libmemusage`
توسط memusage برای کمک به جمع‌آوری اطلاعات درباره استفاده از حافظه یک برنامه استفاده می‌شود

`libnsl`
کتابخانه سرویس‌های شبکه، اکنون منسوخ شده است

`libnss_*`
ماژول‌های Switch Service Name، حاوی توابعی برای حل نام‌های میزبان، نام‌های کاربری، نام‌های گروه، نام‌های مستعار، سرویس‌ها، پروتکل‌ها و غیره. توسط libc بر اساس پیکربندی در /etc/nsswitch.conf بارگذاری می‌شوند

`libpcprofile`
می‌تواند برای پروفایل PC یک اجرایی پیش‌بارگذاری شود

`libpthread`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً حاوی توابعی بود که بیشتر رابط‌های مشخص شده توسط POSIX.1c Thread Extensions و رابط‌های سمافور مشخص شده توسط POSIX.1b Real-time Extensions را ارائه می‌کرد، اکنون توابع در libc هستند

`libresolv`
حاوی توابعی برای ایجاد، ارسال و تفسیر بسته‌ها به سرورهای نام دامنه اینترنت است

`librt`
حاوی توابعی است که بیشتر رابط‌های مشخص شده توسط POSIX.1b Real-time Extensions را ارائه می‌دهند

`libthread_db`
حاوی توابع مفید برای ساخت اشکال‌زداها برای برنامه‌های چند رشته‌ای است

`libutil`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً حاوی کدی برای توابع "استاندارد" مورد استفاده در بسیاری از ابزارهای مختلف یونیکس بود. این توابع اکنون در libc هستند

# ۸.۶. Zlib-1.3.1

بسته Zlib شامل روال‌های فشرده‌سازی و رمزگشایی است که توسط برخی برنامه‌ها استفاده می‌شود.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 6.4 مگابایت

## ۸.۶.۱. نصب Zlib

Zlib را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

یک کتابخانه استاتیک بی‌استفاده را حذف کنید:

```bash
rm -fv /usr/lib/libz.a
```

## ۸.۶.۲. محتویات Zlib

**کتابخانه‌های نصب شده:** libz.so

توضیحات کوتاه:

`libz`
حاوی توابع فشرده‌سازی و رمزگشایی است که توسط برخی برنامه‌ها استفاده می‌شود

# ۸.۷. Bzip2-1.0.8

بسته Bzip2 شامل برنامه‌هایی برای فشرده‌سازی و رمزگشایی فایل‌ها است. فشرده‌سازی فایل‌های متنی با **bzip2** درصد فشرده‌سازی بسیار بهتری نسبت به **gzip** سنتی ارائه می‌دهد.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 7.2 مگابایت

## ۸.۷.۱. نصب Bzip2

وصله‌ای را اعمال کنید که مستندات این بسته را نصب خواهد کرد:

```bash
patch -Np1 -i ../bzip2-1.0.8-install_docs-1.patch
```

دستور زیر اطمینان می‌دهد که نصب پیوندهای نمادین نسبی است:

```bash
sed -i 's@\(ln -s -f \)$(PREFIX)/bin/@\1@' Makefile
```

اطمینان حاصل کنید که صفحات راهنما در مکان صحیح نصب می‌شوند:

```bash
sed -i "s@(PREFIX)/man@(PREFIX)/share/man@g" Makefile
```

Bzip2 را برای کامپایل آماده کنید:

```bash
make -f Makefile-libbz2_so
make clean
```

**معنی پارامتر make:**
`-f Makefile-libbz2_so`
این باعث می‌شود Bzip2 با استفاده از یک فایل `Makefile` متفاوت ساخته شود، در این مورد فایل `Makefile-libbz2_so`، که یک کتابخانه پویای `libbz2.so` ایجاد می‌کند و ابزارهای Bzip2 را در مقابل آن پیوند می‌دهد.

بسته را کامپایل و آزمایش کنید:

```bash
make
```

برنامه‌ها را نصب کنید:

```bash
make PREFIX=/usr install
```

کتابخانه اشتراکی را نصب کنید:

```bash
cp -av libbz2.so.* /usr/lib
ln -sv libbz2.so.1.0.8 /usr/lib/libbz2.so
```

باینری اشتراکی **bzip2** را در دایرکتوری `/usr/bin` نصب کنید و دو نسخه از **bzip2** را با پیوندهای نمادین جایگزین کنید:

```bash
cp -v bzip2-shared /usr/bin/bzip2
for i in /usr/bin/{bzcat,bunzip2}; do
  ln -sfv bzip2 $i
done
```

یک کتابخانه استاتیک بی‌استفاده را حذف کنید:

```bash
rm -fv /usr/lib/libbz2.a
```

## ۸.۷.۲. محتویات Bzip2

**برنامه‌های نصب شده:** bunzip2 (پیوند به bzip2), bzcat (پیوند به bzip2), bzcmp (پیوند به bzdiff), bzdiff, bzegrep (پیوند به bzgrep), bzfgrep (پیوند به bzgrep), bzgrep, bzip2, bzip2recover, bzless (پیوند به bzmore), و bzmore

**کتابخانه‌های نصب شده:** libbz2.so

**دایرکتوری نصب شده:** /usr/share/doc/bzip2-1.0.8

توضیحات کوتاه:

**bunzip2**
فایل‌های فشرده شده با bzip را رمزگشایی می‌کند

**bzcat**
به خروجی استاندارد رمزگشایی می‌کند

**bzcmp**
**cmp** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzdiff**
**diff** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzegrep**
**egrep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzfgrep**
**fgrep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzgrep**
**grep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzip2**
فایل‌ها را با استفاده از الگوریتم فشرده‌سازی متن مرتب‌سازی بلوکی Burrows-Wheeler با کدگذاری Huffman فشرده می‌کند؛ نرخ فشرده‌سازی بهتر از آن چیزی است که توسط فشرده‌کننده‌های معمولی‌تر با استفاده از الگوریتم‌های "Lempel-Ziv" مانند **gzip** به دست می‌آید

**bzip2recover**
سعی می‌کند داده‌ها را از فایل‌های bzip آسیب دیده بازیابی کند

**bzless**
**less** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzmore**
**more** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

`libbz2`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف و مرتب‌سازی بلوکی را با استفاده از الگوریتم Burrows-Wheeler پیاده‌سازی می‌کند

# ۸.۸. Xz-5.6.2

بسته Xz شامل برنامه‌هایی برای فشرده‌سازی و رمزگشایی فایل‌ها است. این بسته قابلیت‌هایی برای فرمت‌های فشرده‌سازی lzma و xz جدیدتر فراهم می‌کند. فشرده‌سازی فایل‌های متنی با **xz** درصد فشرده‌سازی بهتری نسبت به دستورات سنتی **gzip** یا **bzip2** ارائه می‌دهد.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 21 مگابایت

## ۸.۸.۱. نصب Xz

Xz را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/xz-5.6.2
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

## ۸.۸.۲. محتویات Xz

**برنامه‌های نصب شده:** lzcat (پیوند به xz), lzcmp (پیوند به xzdiff), lzdiff (پیوند به xzdiff), lzegrep (پیوند به xzgrep), lzfgrep (پیوند به xzgrep), lzgrep (پیوند به xzgrep), lzless (پیوند به xzless), lzma (پیوند به xz), lzmadec, lzmainfo, lzmore (پیوند به xzmore), unlzma (پیوند به xz), unxz (پیوند به xz), xz, xzcat (پیوند به xz), xzcmp (پیوند به xzdiff), xzdec, xzdiff, xzegrep (پیوند به xzgrep), xzfgrep (پیوند به xzgrep), xzgrep, xzless, و xzmore

**کتابخانه‌های نصب شده:** liblzma.so

**دایرکتوری‌های نصب شده:** /usr/include/lzma و /usr/share/doc/xz-5.6.2

توضیحات کوتاه:

**lzcat**
به خروجی استاندارد رمزگشایی می‌کند

**lzcmp**
**cmp** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzdiff**
**diff** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzegrep**
**egrep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzfgrep**
**fgrep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzgrep**
**grep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzless**
**less** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzma**
فایل‌ها را با استفاده از فرمت LZMA فشرده یا رمزگشایی می‌کند

**lzmadec**
یک رمزگشای کوچک و سریع برای فایل‌های فشرده شده با LZMA

**lzmainfo**
اطلاعات ذخیره شده در هدر فایل فشرده شده با LZMA را نمایش می‌دهد

**lzmore**
**more** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**unlzma**
فایل‌ها را با استفاده از فرمت LZMA رمزگشایی می‌کند

**unxz**
فایل‌ها را با استفاده از فرمت XZ رمزگشایی می‌کند

**xz**
فایل‌ها را با استفاده از فرمت XZ فشرده یا رمزگشایی می‌کند

**xzcat**
به خروجی استاندارد رمزگشایی می‌کند

**xzcmp**
**cmp** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzdec**
یک رمزگشای کوچک و سریع برای فایل‌های فشرده شده با XZ

**xzdiff**
**diff** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzegrep**
**egrep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzfgrep**
**fgrep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzgrep**
**grep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzless**
**less** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzmore**
**more** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

`liblzma`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف و مرتب‌سازی بلوکی را با استفاده از الگوریتم Lempel-Ziv-Markov chain پیاده‌سازی می‌کند

# ۸.۹. Lz4-1.10.0

Lz4 یک الگوریتم فشرده‌سازی بدون اتلاف است که سرعت فشرده‌سازی بیش از 500 مگابایت بر ثانیه برای هر هسته را ارائه می‌دهد. این الگوریتم دارای یک رمزگشای بسیار سریع است، با سرعتی در حد چندین گیگابایت بر ثانیه برای هر هسته. Lz4 می‌تواند با Zstandard کار کند تا هر دو الگوریتم بتوانند داده‌ها را سریع‌تر فشرده کنند.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 4.2 مگابایت

## ۸.۹.۱. نصب Lz4

بسته را کامپایل کنید:

```bash
make BUILD_STATIC=no PREFIX=/usr
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make -j1 check
```

بسته را نصب کنید:

```bash
make BUILD_STATIC=no PREFIX=/usr install
```

## ۸.۹.۲. محتویات Lz4

**برنامه‌های نصب شده:** lz4, lz4c (پیوند به lz4), lz4cat (پیوند به lz4), و unlz4 (پیوند به lz4)
**کتابخانه نصب شده:** liblz4.so

توضیحات کوتاه:

**lz4**
فایل‌ها را با استفاده از فرمت LZ4 فشرده یا رمزگشایی می‌کند

**lz4c**
فایل‌ها را با استفاده از فرمت LZ4 فشرده می‌کند

**lz4cat**
محتویات فایل فشرده شده با فرمت LZ4 را لیست می‌کند

**unlz4**
فایل‌ها را با استفاده از فرمت LZ4 رمزگشایی می‌کند

`liblz4`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف را با استفاده از الگوریتم LZ4 پیاده‌سازی می‌کند

# ۸.۱۰. Zstd-1.5.6

Zstandard یک الگوریتم فشرده‌سازی بلادرنگ است که نسبت‌های فشرده‌سازی بالایی ارائه می‌دهد. این الگوریتم طیف بسیار گسترده‌ای از تعادل بین فشرده‌سازی و سرعت را ارائه می‌دهد، در حالی که توسط یک رمزگشای بسیار سریع پشتیبانی می‌شود.

**زمان تقریبی ساخت:** 0.4 SBU
**فضای دیسک مورد نیاز:** 84 مگابایت

## ۸.۱۰.۱. نصب Zstd

بسته را کامپایل کنید:

```bash
make prefix=/usr
```

**نکته**
در خروجی آزمون چندین مکان وجود دارد که 'failed' را نشان می‌دهد. این‌ها مورد انتظار هستند و فقط 'FAIL' یک شکست واقعی آزمون است. نباید هیچ شکست آزمونی وجود داشته باشد.

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make prefix=/usr install
```

کتابخانه استاتیک را حذف کنید:

```bash
rm -v /usr/lib/libzstd.a
```

## ۸.۱۰.۲. محتویات Zstd

**برنامه‌های نصب شده:** zstd, zstdcat (پیوند به zstd), zstdgrep, zstdless, zstdmt (پیوند به zstd), و unzstd (پیوند به zstd)
**کتابخانه نصب شده:** libzstd.so

توضیحات کوتاه:

**zstd**
فایل‌ها را با استفاده از فرمت ZSTD فشرده یا رمزگشایی می‌کند

**zstdgrep**
**grep** را روی فایل‌های فشرده شده با ZSTD اجرا می‌کند

**zstdless**
**less** را روی فایل‌های فشرده شده با ZSTD اجرا می‌کند

`libzstd`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف را با استفاده از الگوریتم ZSTD پیاده‌سازی می‌کند

# ۸.۱۱. File-5.45

بسته File شامل ابزاری برای تعیین نوع فایل یا فایل‌های داده شده است.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 17 مگابایت

## ۸.۱۱.۱. نصب File

File را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

## ۸.۱۱.۲. محتویات File

**برنامه نصب شده:** file
**کتابخانه نصب شده:** libmagic.so

توضیحات کوتاه:

**file**

سعی می‌کند هر فایل داده شده را طبقه‌بندی کند؛ این کار را با انجام چندین آزمایش انجام می‌دهد - آزمایش‌های سیستم فایل، آزمایش‌های عدد جادویی و آزمایش‌های زبان

`libmagic`

حاوی روال‌هایی برای تشخیص عدد جادویی است که توسط برنامه **file** استفاده می‌شود