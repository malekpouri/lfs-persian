# فصل ۸. نصب نرم‌افزار پایه سیستم

## ۸.۱. مقدمه

در این فصل، ما شروع به ساخت جدی سیستم LFS می‌کنیم.

نصب این نرم‌افزارها ساده است. اگرچه در بسیاری از موارد دستورالعمل‌های نصب می‌توانند کوتاه‌تر و عمومی‌تر باشند، ما تصمیم گرفته‌ایم دستورالعمل‌های کامل را برای هر بسته ارائه دهیم تا احتمال اشتباه را به حداقل برسانیم. کلید یادگیری اینکه چه چیزی باعث کار کردن یک سیستم لینوکس می‌شود، دانستن این است که هر بسته برای چه استفاده می‌شود و چرا شما (یا سیستم) ممکن است به آن نیاز داشته باشید.

ما استفاده از بهینه‌سازی‌های سفارشی را توصیه نمی‌کنیم. آنها ممکن است باعث شوند یک برنامه کمی سریع‌تر اجرا شود، اما همچنین ممکن است مشکلات کامپایل و مشکلاتی هنگام اجرای برنامه ایجاد کنند. اگر یک بسته با بهینه‌سازی سفارشی کامپایل نمی‌شود، سعی کنید آن را بدون بهینه‌سازی کامپایل کنید و ببینید آیا این مشکل را حل می‌کند. حتی اگر بسته هنگام استفاده از بهینه‌سازی سفارشی کامپایل شود، خطر این وجود دارد که به دلیل تعاملات پیچیده بین کد و ابزارهای ساخت، به اشتباه کامپایل شده باشد. همچنین توجه داشته باشید که گزینه‌های `-march` و `-mtune` با مقادیری که در کتاب مشخص نشده‌اند آزمایش نشده‌اند. این ممکن است مشکلاتی را با بسته‌های toolchain (Binutils، GCC و Glibc) ایجاد کند. دستاوردهای کوچک بالقوه حاصل از سفارشی‌سازی بهینه‌سازی‌های کامپایلر اغلب با خطرات آن جبران می‌شود. سازندگان اولیه LFS تشویق می‌شوند که بدون بهینه‌سازی‌های سفارشی بسازند.

از طرف دیگر، ما بهینه‌سازی‌های فعال شده توسط پیکربندی پیش‌فرض بسته‌ها را حفظ می‌کنیم. علاوه بر این، گاهی اوقات ما به طور صریح یک پیکربندی بهینه‌سازی شده را که توسط یک بسته ارائه شده اما به طور پیش‌فرض فعال نیست، فعال می‌کنیم. نگهدارندگان بسته‌ها قبلاً این پیکربندی‌ها را آزمایش کرده‌اند و آنها را ایمن می‌دانند، بنابراین احتمال اینکه ساخت را خراب کنند کم است. به طور کلی پیکربندی پیش‌فرض قبلاً `-O2` یا `-O3` را فعال می‌کند، بنابراین سیستم حاصل بدون هیچ بهینه‌سازی سفارشی همچنان بسیار سریع اجرا خواهد شد و در عین حال پایدار خواهد بود.

قبل از دستورالعمل‌های نصب، هر صفحه نصب اطلاعاتی درباره بسته ارائه می‌دهد، از جمله توضیح مختصری از آنچه شامل می‌شود، تقریباً چه مدت زمانی برای ساخت لازم است، و چقدر فضای دیسک در طول این فرآیند ساخت مورد نیاز است. پس از دستورالعمل‌های نصب، فهرستی از برنامه‌ها و کتابخانه‌ها (همراه با توضیحات مختصر) که بسته نصب می‌کند، وجود دارد.

**نکته**: مقادیر SBU و فضای دیسک مورد نیاز شامل داده‌های مجموعه آزمون برای تمام بسته‌های قابل اجرا در فصل 8 است. مقادیر SBU با استفاده از چهار هسته CPU (-j4) برای تمام عملیات محاسبه شده‌اند مگر اینکه به طور دیگری مشخص شده باشد.

### ۸.۱.۱. درباره کتابخانه‌ها

به طور کلی، ویراستاران LFS ساخت و نصب کتابخانه‌های استاتیک را توصیه نمی‌کنند. اکثر کتابخانه‌های استاتیک در یک سیستم لینوکس مدرن منسوخ شده‌اند. علاوه بر این، پیوند یک کتابخانه استاتیک به یک برنامه می‌تواند مضر باشد. اگر به‌روزرسانی کتابخانه برای رفع یک مشکل امنیتی لازم باشد، هر برنامه‌ای که از کتابخانه استاتیک استفاده می‌کند باید با کتابخانه جدید دوباره پیوند داده شود. از آنجا که استفاده از کتابخانه‌های استاتیک همیشه آشکار نیست، برنامه‌های مربوطه (و روش‌های لازم برای انجام پیوند) ممکن است حتی شناخته نشده باشند.

روش‌های این فصل نصب اکثر کتابخانه‌های استاتیک را حذف یا غیرفعال می‌کنند. معمولاً این کار با دادن گزینه `--disable-static` به **configure** انجام می‌شود. در موارد دیگر، به روش‌های جایگزین نیاز است. در چند مورد، به خصوص Glibc و GCC، استفاده از کتابخانه‌های استاتیک همچنان یک ویژگی ضروری فرآیند ساخت بسته است.

برای بحث کامل‌تر درباره کتابخانه‌ها، به "کتابخانه‌ها: استاتیک یا اشتراکی؟" در کتاب BLFS مراجعه کنید.

# ۸.۲. مدیریت بسته

مدیریت بسته اغلب یک افزودنی درخواست شده به کتاب LFS است. یک مدیر بسته نصب فایل‌ها را پیگیری می‌کند و حذف و ارتقاء بسته‌ها را آسان‌تر می‌کند. یک مدیر بسته خوب همچنین با فایل‌های پیکربندی به طور ویژه‌ای برخورد می‌کند تا پیکربندی کاربر را هنگام نصب مجدد یا ارتقاء بسته حفظ کند. قبل از اینکه شروع به تعجب کنید، خیر - این بخش درباره هیچ مدیر بسته خاصی صحبت نمی‌کند یا آن را توصیه نمی‌کند. آنچه ارائه می‌دهد خلاصه‌ای از تکنیک‌های محبوب‌تر و نحوه کار آنهاست. مدیر بسته ایده‌آل برای شما ممکن است در میان این تکنیک‌ها باشد، یا ممکن است ترکیبی از دو یا چند مورد از این تکنیک‌ها باشد. این بخش به طور مختصر به مسائلی که ممکن است هنگام ارتقاء بسته‌ها پیش بیاید اشاره می‌کند.

برخی از دلایلی که هیچ مدیر بسته‌ای در LFS یا BLFS ذکر نشده است عبارتند از:

- پرداختن به مدیریت بسته تمرکز را از اهداف این کتاب‌ها - آموزش نحوه ساخت یک سیستم لینوکس - دور می‌کند.
- راه حل‌های متعددی برای مدیریت بسته وجود دارد که هر کدام نقاط قوت و ضعف خود را دارند. یافتن یک راه حل که همه مخاطبان را راضی کند دشوار است.

برخی نکات در مورد موضوع مدیریت بسته نوشته شده است. از پروژه Hints بازدید کنید و ببینید آیا یکی از آنها مناسب نیازهای شما است.

## ۸.۲.۱. مسائل ارتقاء

یک مدیر بسته ارتقاء به نسخه‌های جدیدتر را هنگام انتشار آسان می‌کند. عموماً دستورالعمل‌های کتاب‌های LFS و BLFS را می‌توان برای ارتقاء به نسخه‌های جدیدتر استفاده کرد. در اینجا چند نکته است که باید هنگام ارتقاء بسته‌ها، به خصوص در یک سیستم در حال اجرا، از آنها آگاه باشید:

- اگر هسته لینوکس نیاز به ارتقاء دارد (برای مثال، از 5.10.17 به 5.10.18 یا 5.11.1)، چیز دیگری نیاز به بازسازی ندارد. سیستم به لطف رابط خوب تعریف شده بین هسته و فضای کاربر به خوبی کار خواهد کرد. به طور خاص، سرآیندهای API لینوکس نیازی به ارتقاء همراه با هسته ندارند. شما فقط باید سیستم خود را مجدداً راه‌اندازی کنید تا از هسته ارتقاء یافته استفاده کنید.

- اگر Glibc نیاز به ارتقاء به نسخه جدیدتر دارد (مثلاً از Glibc-2.36 به Glibc-2.40)، برخی مراحل اضافی برای جلوگیری از خراب شدن سیستم لازم است. برای جزئیات به بخش 8.5، "Glibc-2.40" مراجعه کنید.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر کند، هر بسته‌ای که به صورت پویا به کتابخانه پیوند داده شده است باید مجدداً کامپایل شود تا با کتابخانه جدیدتر پیوند داده شود. (توجه داشته باشید که هیچ ارتباطی بین نسخه بسته و نام کتابخانه وجود ندارد.) برای مثال، یک بسته foo-1.2.3 را در نظر بگیرید که یک کتابخانه اشتراکی با نام libfoo.so.1 نصب می‌کند. فرض کنید شما بسته را به نسخه جدیدتر foo-1.2.4 ارتقاء می‌دهید که یک کتابخانه اشتراکی با نام libfoo.so.2 نصب می‌کند. در این صورت، هر بسته‌ای که به صورت پویا به libfoo.so.1 پیوند داده شده است، باید مجدداً کامپایل شود تا با libfoo.so.2 پیوند داده شود تا از نسخه جدید کتابخانه استفاده کند. نباید کتابخانه‌های قدیمی را تا زمانی که تمام بسته‌های وابسته مجدداً کامپایل نشده‌اند حذف کنید.

- اگر یک بسته (به طور مستقیم یا غیرمستقیم) به هر دو نام قدیمی و جدید یک کتابخانه اشتراکی پیوند داده شده باشد (برای مثال، بسته هم به libfoo.so.2 و هم به libbar.so.1 پیوند داده شده است، در حالی که دومی به libfoo.so.3 پیوند داده شده است)، ممکن است بسته بد عمل کند زیرا نسخه‌های مختلف کتابخانه اشتراکی تعاریف ناسازگاری برای برخی نام‌های نماد ارائه می‌دهند. این می‌تواند ناشی از کامپایل مجدد برخی، اما نه همه، بسته‌های پیوند داده شده به کتابخانه اشتراکی قدیمی پس از ارتقاء بسته ارائه دهنده کتابخانه اشتراکی باشد. برای جلوگیری از این مشکل، کاربران باید هر بسته پیوند داده شده به یک کتابخانه اشتراکی با نسخه به‌روز شده (مثلاً از libfoo.so.2 به libfoo.so.3) را در اسرع وقت مجدداً بسازند.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر نکند، اما شماره نسخه فایل کتابخانه کاهش یابد (برای مثال، کتابخانه همچنان libfoo.so.1 نام دارد، اما نام فایل کتابخانه از libfoo.so.1.25 به libfoo.so.1.24 تغییر کرده است)، باید فایل کتابخانه از نسخه قبلاً نصب شده را حذف کنید (در این مورد libfoo.so.1.25). در غیر این صورت، یک دستور ldconfig (که توسط خودتان از خط فرمان یا توسط نصب برخی بسته‌ها فراخوانی می‌شود) پیوند نمادین libfoo.so.1 را مجدداً تنظیم می‌کند تا به فایل کتابخانه قدیمی اشاره کند زیرا به نظر می‌رسد یک نسخه "جدیدتر" است؛ شماره نسخه آن بزرگتر است. این وضعیت ممکن است در صورتی که مجبور به کاهش نسخه یک بسته باشید یا اگر نویسندگان طرح نسخه‌بندی را برای فایل‌های کتابخانه تغییر دهند، پیش بیاید.

- اگر یک بسته حاوی یک کتابخانه اشتراکی به‌روز شود و نام کتابخانه تغییر نکند، اما یک مشکل جدی (به خصوص، یک آسیب‌پذیری امنیتی) برطرف شود، تمام برنامه‌های در حال اجرا که به کتابخانه اشتراکی پیوند داده شده‌اند باید مجدداً راه‌اندازی شوند. دستور زیر، که پس از اتمام به‌روزرسانی به عنوان root اجرا می‌شود، فرآیندهایی را که از نسخه‌های قدیمی این کتابخانه‌ها استفاده می‌کنند لیست می‌کند (libfoo را با نام کتابخانه جایگزین کنید):

  ```
  grep -l 'libfoo.*deleted' /proc/*/maps | tr -cd 0-9\\n | xargs -r ps u
  ```

- اگر از OpenSSH برای دسترسی به سیستم استفاده می‌شود و به کتابخانه به‌روز شده پیوند داده شده است، باید سرویس sshd را مجدداً راه‌اندازی کنید، سپس خارج شوید، دوباره وارد شوید و دستور قبلی را مجدداً اجرا کنید تا تأیید کنید که هیچ چیز هنوز از کتابخانه‌های حذف شده استفاده نمی‌کند.

- اگر یک برنامه اجرایی یا یک کتابخانه اشتراکی بازنویسی شود، فرآیندهایی که از کد یا داده در آن برنامه یا کتابخانه استفاده می‌کنند ممکن است از کار بیفتند. روش صحیح به‌روزرسانی یک برنامه یا کتابخانه اشتراکی بدون ایجاد خرابی در فرآیند، حذف آن و سپس نصب نسخه جدید است. دستور install ارائه شده توسط coreutils این را پیاده‌سازی کرده است و اکثر بسته‌ها از آن دستور برای نصب فایل‌های باینری و کتابخانه‌ها استفاده می‌کنند. این بدان معناست که اکثر اوقات با این مشکل مواجه نخواهید شد. با این حال، فرآیند نصب برخی بسته‌ها (به طور خاص SpiderMonkey در BLFS) فقط فایل را در صورت وجود بازنویسی می‌کند؛ این باعث خرابی می‌شود. بنابراین، ایمن‌تر است که کار خود را ذخیره کنید و فرآیندهای در حال اجرای غیرضروری را قبل از به‌روزرسانی یک بسته ببندید.

## ۸.۲.۲. تکنیک‌های مدیریت بسته

در ادامه برخی از تکنیک‌های رایج مدیریت بسته آمده است. قبل از تصمیم‌گیری در مورد یک مدیر بسته، در مورد تکنیک‌های مختلف تحقیق کنید، به خصوص معایب هر طرح خاص.

### ۸.۲.۲.۱. همه چیز در سر من است!

بله، این یک تکنیک مدیریت بسته است. برخی افراد به مدیر بسته نیاز ندارند زیرا بسته‌ها را به خوبی می‌شناسند و می‌دانند کدام فایل‌ها توسط هر بسته نصب می‌شوند. برخی کاربران همچنین به هیچ مدیریت بسته‌ای نیاز ندارند زیرا قصد دارند هر زمان که یک بسته تغییر کرد، کل سیستم را مجدداً بسازند.

### ۸.۲.۲.۲. نصب در دایرکتوری‌های جداگانه

این یک تکنیک مدیریت بسته ساده است که به برنامه خاصی برای مدیریت بسته‌ها نیاز ندارد. هر بسته در یک دایرکتوری جداگانه نصب می‌شود. برای مثال، بسته foo-1.1 در /opt/foo-1.1 نصب می‌شود و یک پیوند نمادین از /opt/foo به /opt/foo-1.

# ۸.۳. Man-pages-6.9.1

بسته Man-pages شامل بیش از 2,400 صفحه راهنما است.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 52 مگابایت

## ۸.۳.۱. نصب Man-pages

دو صفحه راهنما برای توابع رمزگذاری رمز عبور را حذف کنید. Libxcrypt نسخه بهتری از این صفحات راهنما را ارائه خواهد داد:

```bash
rm -v man3/crypt*
```

Man-pages را با اجرای دستور زیر نصب کنید:

```bash
make prefix=/usr install
```

## ۸.۳.۲. محتویات Man-pages

**فایل‌های نصب شده:** صفحات راهنمای مختلف

توضیحات کوتاه:

`man pages`
توابع زبان برنامه‌نویسی C، فایل‌های دستگاه مهم و فایل‌های پیکربندی قابل توجه را توصیف می‌کند.

# ۸.۴. Iana-Etc-20240806

بسته Iana-Etc داده‌هایی برای سرویس‌ها و پروتکل‌های شبکه ارائه می‌دهد.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 4.8 مگابایت

## ۸.۴.۱. نصب Iana-Etc

برای این بسته، ما فقط نیاز داریم فایل‌ها را در جای خود کپی کنیم:

```bash
cp services protocols /etc
```

## ۸.۴.۲. محتویات Iana-Etc

**فایل‌های نصب شده:** /etc/protocols و /etc/services

توضیحات کوتاه:

`/etc/protocols`
پروتکل‌های مختلف اینترنت DARPA را که از زیرسیستم TCP/IP در دسترس هستند توصیف می‌کند.

`/etc/services`
نگاشتی بین نام‌های متنی دوستانه برای سرویس‌های اینترنتی و شماره‌های پورت و انواع پروتکل‌های اختصاص داده شده به آنها ارائه می‌دهد.

این متن بسیار طولانی است و ترجمه کامل آن در یک پاسخ ممکن نیست. من آن را به چند بخش تقسیم کرده و ترجمه خواهم کرد. اینجا بخش اول ترجمه است:

# ۸.۵. Glibc-2.40

بسته Glibc حاوی کتابخانه اصلی C است. این کتابخانه روال‌های پایه برای تخصیص حافظه، جستجوی دایرکتوری‌ها، باز و بسته کردن فایل‌ها، خواندن و نوشتن فایل‌ها، مدیریت رشته‌ها، تطبیق الگو، محاسبات ریاضی و غیره را فراهم می‌کند.

**زمان تقریبی ساخت:** 12 SBU
**فضای دیسک مورد نیاز:** 3.1 گیگابایت

## ۸.۵.۱. نصب Glibc

برخی از برنامه‌های Glibc از دایرکتوری /var/db که مطابق با FHS نیست برای ذخیره داده‌های زمان اجرا استفاده می‌کنند. وصله زیر را اعمال کنید تا چنین برنامه‌هایی داده‌های زمان اجرای خود را در مکان‌های مطابق با FHS ذخیره کنند:

```bash
patch -Np1 -i ../glibc-2.40-fhs-1.patch
```

مستندات Glibc توصیه می‌کند که Glibc را در یک دایرکتوری ساخت اختصاصی بسازید:

```bash
mkdir -v build
cd       build
```

اطمینان حاصل کنید که ابزارهای ldconfig و sln در /usr/sbin نصب خواهند شد:

```bash
echo "rootsbindir=/usr/sbin" > configparms
```

Glibc را برای کامپایل آماده کنید:

```bash
../configure --prefix=/usr                            \
             --disable-werror                         \
             --enable-kernel=4.19                     \
             --enable-stack-protector=strong          \
             --disable-nscd                           \
             libc_cv_slibdir=/usr/lib
```

معنی گزینه‌های پیکربندی:

`--disable-werror`
    این گزینه گزینه -Werror را که به GCC منتقل می‌شود غیرفعال می‌کند. این برای اجرای مجموعه آزمون ضروری است.

`--enable-kernel=4.19`
    این گزینه به سیستم ساخت می‌گوید که این Glibc ممکن است با هسته‌هایی به قدمت 4.19 استفاده شود. این به معنای تولید راه حل‌های جایگزین در صورتی است که یک فراخوانی سیستمی معرفی شده در نسخه بعدی نتواند استفاده شود.

`--enable-stack-protector=strong`
    این گزینه امنیت سیستم را با افزودن کد اضافی برای بررسی سرریز بافر، مانند حملات stack smashing افزایش می‌دهد. توجه داشته باشید که Glibc همیشه به صراحت پیش‌فرض GCC را لغو می‌کند، بنابراین این گزینه حتی با وجود اینکه ما قبلاً --enable-default-ssp را برای GCC مشخص کرده‌ایم، همچنان مورد نیاز است.

`--disable-nscd`
    دیمون کش سرویس نام را که دیگر استفاده نمی‌شود نسازید.

`libc_cv_slibdir=/usr/lib`
    این متغیر کتابخانه صحیح را برای تمام سیستم‌ها تنظیم می‌کند. ما نمی‌خواهیم از lib64 استفاده شود.

بسته را کامپایل کنید:

```bash
make
```

**مهم**: در این بخش، مجموعه آزمون برای Glibc بحرانی در نظر گرفته می‌شود. تحت هیچ شرایطی آن را نادیده نگیرید.

معمولاً چند آزمون با موفقیت انجام نمی‌شوند. شکست‌های آزمون ذکر شده در زیر معمولاً برای نادیده گرفتن ایمن هستند.

```bash
make check
```

ممکن است برخی شکست‌های آزمون را مشاهده کنید. مجموعه آزمون Glibc تا حدودی به سیستم میزبان وابسته است. چند شکست از بیش از 5000 آزمون را می‌توان به طور کلی نادیده گرفت. این فهرستی از رایج‌ترین مسائل مشاهده شده برای نسخه‌های اخیر LFS است:

- io/tst-lchmod در محیط chroot LFS با شکست مواجه می‌شود.

- برخی آزمون‌ها، مانند nss/tst-nss-files-hosts-multi و nptl/tst-thread-affinity* به دلیل timeout (به ویژه زمانی که سیستم نسبتاً کند است و/یا مجموعه آزمون با چندین کار موازی make اجرا می‌شود) با شکست مواجه می‌شوند. این آزمون‌ها را می‌توان با دستور زیر شناسایی کرد:

```bash
grep "Timed out" $(find -name \*.out)
```

امکان اجرای مجدد یک آزمون منفرد با timeout افزایش یافته با TIMEOUTFACTOR=<factor> make test t=<test name> وجود دارد. برای مثال، TIMEOUTFACTOR=10 make test t=nss/tst-nss-files-hosts-multi آزمون nss/tst-nss-files-hosts-multi را با ده برابر timeout اصلی مجدداً اجرا خواهد کرد.

- علاوه بر این، برخی آزمون‌ها ممکن است با یک مدل CPU نسبتاً قدیمی (برای مثال elf/tst-cpu-features-cpuinfo) یا نسخه هسته میزبان (برای مثال stdlib/tst-arc4random-thread) با شکست مواجه شوند.

اگرچه این یک پیام بی‌ضرر است، مرحله نصب Glibc از عدم وجود /etc/ld.so.conf شکایت خواهد کرد. از این هشدار با دستور زیر جلوگیری کنید:

```bash
touch /etc/ld.so.conf
```

Makefile را اصلاح کنید تا یک بررسی قدیمی سلامت را که با پیکربندی مدرن Glibc شکست می‌خورد، نادیده بگیرد:

```bash
sed '/test-installation/s@$(PERL)@echo not running@' -i ../Makefile
```

**مهم**: اگر Glibc را به یک نسخه فرعی جدید (برای مثال، از Glibc-2.36 به Glibc-2.40) در یک سیستم LFS در حال اجرا ارتقاء می‌دهید، باید برخی اقدامات احتیاطی اضافی را برای جلوگیری از خراب شدن سیستم انجام دهید:

- ارتقاء Glibc در یک سیستم LFS قبل از 11.0 (به استثنای) پشتیبانی نمی‌شود. اگر چنین سیستم LFS قدیمی را اجرا می‌کنید اما به یک Glibc جدیدتر نیاز دارید، LFS را بازسازی کنید.

- اگر در یک سیستم LFS قبل از 12.0 (به استثنای) ارتقاء می‌دهید، Libxcrypt را مطابق با بخش 8.27، "Libxcrypt-4.4.36" نصب کنید. علاوه بر نصب عادی Libxcrypt، باید یادداشت در بخش Libxcrypt را برای نصب libcrypt.so.1* (جایگزینی libcrypt.so.1 از نصب قبلی Glibc) دنبال کنید.

- اگر در یک سیستم LFS قبل از 12.1 (به استثنای) ارتقاء می‌دهید، برنامه nscd را حذف کنید:

```bash
rm -f /usr/sbin/nscd
```

- هسته را ارتقاء دهید و اگر قدیمی‌تر از 4.19 است (نسخه فعلی را با uname -r بررسی کنید) یا اگر می‌خواهید به هر حال آن را ارتقاء دهید، مطابق با بخش 10.3، "Linux-6.10.5" سیستم را مجدداً راه‌اندازی کنید.

- هدرهای API هسته را اگر قدیمی‌تر از 4.19 هستند (نسخه فعلی را با cat /usr/include/linux/version.h بررسی کنید) یا اگر می‌خواهید به هر حال آنها را ارتقاء دهید، مطابق با بخش 5.4، "Linux-6.10.5 API Headers" ارتقاء دهید (اما $LFS را از دستور cp حذف کنید).

- یک نصب DESTDIR انجام دهید و کتابخانه‌های اشتراکی Glibc را در سیستم با استفاده از یک دستور نصب واحد ارتقاء دهید:

```bash
make DESTDIR=$PWD/dest install
install -vm755 dest/usr/lib/*.so.* /usr/lib
```

ضروری است که دقیقاً این مراحل را دنبال کنید مگر اینکه کاملاً متوجه شوید چه کاری انجام می‌دهید. هر انحراف غیرمنتظره ممکن است سیستم را کاملاً غیرقابل استفاده کند. شما هشدار داده شده‌اید.

سپس به اجرای دستور make install، دستور sed در مقابل /usr/bin/ldd، و دستورات نصب locales ادامه دهید. پس از اتمام آنها، سیستم را فوراً مجدداً راه‌اندازی کنید.

بسته را نصب کنید:

```bash
make install
```

یک مسیر هارد کد شده به لودر اجرایی را در اسکریپت ldd اصلاح کنید:

```bash
sed '/RTLDLIST=/s@/usr@@g' -i /usr/bin/ldd
```

سپس، locales را نصب کنید که می‌توانند باعث شوند سیستم به زبان‌های مختلف پاسخ دهد. هیچ یک از این locales الزامی نیستند، اما اگر برخی از آنها وجود نداشته باشند، مجموعه‌های آزمون برخی بسته‌ها موارد آزمون مهمی را نادیده خواهند گرفت.

locales فردی را می‌توان با استفاده از برنامه localedef نصب کرد. برای مثال، دومین دستور localedef در زیر تعریف locale مستقل از مجموعه کاراکتر /usr/share/i18n/locales/cs_CZ را با تعریف نقشه کاراکتر /usr/share/i18n/charmaps/UTF-8.gz ترکیب می‌کند و نتیجه را به فایل /usr/lib/locale/locale-archive اضافه می‌کند. دستورالعمل‌های زیر مجموعه حداقلی از locales لازم برای پوشش بهینه آزمون‌ها را نصب خواهند کرد:

```bash
localedef -i C -f UTF-8 C.UTF-8
localedef -i cs_CZ -f UTF-8 cs_CZ.UTF-8
localedef -i de_DE -f ISO-8859-1 de_DE
localedef -i de_DE@euro -f ISO-8859-15 de_DE@euro
localedef -i de_DE -f UTF-8 de_DE.UTF-8
localedef -i el_GR -f ISO-8859-7 el_GR
localedef -i en_GB -f ISO-8859-1 en_GB
localedef -i en_GB -f UTF-8 en_GB.UTF-8
localedef -i en_HK -f ISO-8859-1 en_HK
localedef -i en_PH -f ISO-8859-1 en_PH
localedef -i en_US -f ISO-8859-1 en_US
localedef -i en_US -f UTF-8 en_US.UTF-8
localedef -i es_ES -f ISO-8859-15 es_ES@euro
localedef -i es_MX -f ISO-8859-1 es_MX
localedef -i fa_IR -f UTF-8 fa_IR
localedef -i fr_FR -f ISO-8859-1 fr_FR
localedef -i fr_FR@euro -f ISO-859-15 fr_FR@euro
localedef -i fr_FR -f UTF-8 fr_FR.UTF-8
localedef -i is_IS -f ISO-8859-1 is_IS
localedef -i is_IS -f UTF-8 is_IS.UTF-8
localedef -i it_IT -f ISO-8859-1 it_IT
localedef -i it_IT -f ISO-8859-15 it_IT@euro
localedef -i it_IT -f UTF-8 it_IT.UTF-8
localedef -i ja_JP -f EUC-JP ja_JP
localedef -i ja_JP -f SHIFT_JIS ja_JP.SJIS 2> /dev/null || true
localedef -i ja_JP -f UTF-8 ja_JP.UTF-8
localedef -i nl_NL@euro -f ISO-8859-15 nl_NL@euro
localedef -i ru_RU -f KOI8-R ru_RU.KOI8-R
localedef -i ru_RU -f UTF-8 ru_RU.UTF-8
localedef -i se_NO -f UTF-8 se_NO.UTF-8
localedef -i ta_IN -f UTF-8 ta_IN.UTF-8
localedef -i tr_TR -f UTF-8 tr_TR.UTF-8
localedef -i zh_CN -f GB18030 zh_CN.GB18030
localedef -i zh_HK -f BIG5-HKSCS zh_HK.BIG5-HKSCS
localedef -i zh_TW -f UTF-8 zh_TW.UTF-8
```

علاوه بر این، locale مربوط به کشور، زبان و مجموعه کاراکتر خود را نصب کنید.

به طور جایگزین، می‌توانید تمام locales ذکر شده در فایل glibc-2.40/localedata/SUPPORTED را (که شامل تمام locales ذکر شده در بالا و بسیاری دیگر است) یکجا با دستور زمان‌بر زیر نصب کنید:

```bash
make localedata/install-locales
```

سپس از دستور localedef برای ایجاد و نصب locales که در فایل glibc-2.40/localedata/SUPPORTED ذکر نشده‌اند استفاده کنید زمانی که به آنها نیاز دارید. برای مثال، دو locale زیر برای برخی آزمون‌ها در ادامه این فصل مورد نیاز است:

```bash
localedef -i C -f UTF-8 C.UTF-8
localedef -i ja_JP -f SHIFT_JIS ja_JP.SJIS 2> /dev/null || true
```

**نکته**: Glibc اکنون از libidn2 برای حل نام‌های دامنه بین‌المللی استفاده می‌کند. این یک وابستگی زمان اجرا است. اگر به این قابلیت نیاز دارید، دستورالعمل‌های نصب libidn2 در صفحه libidn2 BLFS موجود است.

## ۸.۵.۲. پیکربندی Glibc

### ۸.۵.۲.۱. افزودن nsswitch.conf

فایل /etc/nsswitch.conf باید ایجاد شود زیرا پیش‌فرض‌های Glibc در یک محیط شبکه‌ای به خوبی کار نمی‌کنند.

با اجرای دستور زیر یک فایل /etc/nsswitch.conf جدید ایجاد کنید:

```bash
cat > /etc/nsswitch.conf << "EOF"
# Begin /etc/nsswitch.conf

passwd: files
group: files
shadow: files

hosts: files dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

# End /etc/nsswitch.conf
EOF
```

### ۸.۵.۲.۲. افزودن داده منطقه زمانی

داده منطقه زمانی را با دستورات زیر نصب و تنظیم کنید:

```bash
tar -xf ../../tzdata2024a.tar.gz

ZONEINFO=/usr/share/zoneinfo
mkdir -pv $ZONEINFO/{posix,right}

for tz in etcetera southamerica northamerica europe africa antarctica  \
          asia australasia backward; do
    zic -L /dev/null   -d $ZONEINFO       ${tz}
    zic -L /dev/null   -d $ZONEINFO/posix ${tz}
    zic -L leapseconds -d $ZONEINFO/right ${tz}
done

cp -v zone.tab zone1970.tab iso3166.tab $ZONEINFO
zic -d $ZONEINFO -p America/New_York
unset ZONEINFO
```

معنی دستورات zic:

`zic -L /dev/null ...`
    این مناطق زمانی posix را بدون هیچ ثانیه کبیسه ایجاد می‌کند. قرارداد این است که آنها را هم در zoneinfo و هم در zoneinfo/posix قرار دهیم. لازم است مناطق زمانی POSIX را در zoneinfo قرار دهیم، در غیر این صورت برخی مجموعه‌های آزمون خطاهایی را گزارش خواهند کرد. در یک سیستم تعبیه شده، که فضا محدود است و قصد ندارید هرگز مناطق زمانی را به‌روز کنید، می‌توانید با استفاده نکردن از دایرکتوری posix، 1.9 مگابایت صرفه‌جویی کنید، اما برخی برنامه‌ها یا مجموعه‌های آزمون ممکن است برخی خطاها تولید کنند.

`zic -L leapseconds ...`
    این مناطق زمانی صحیح را ایجاد می‌کند، از جمله ثانیه‌های کبیسه. در یک سیستم تعبیه شده، که فضا محدود است و قصد ندارید هرگز مناطق زمانی را به‌روز کنید، یا به زمان دقیق اهمیت نمی‌دهید، می‌توانید با حذف دایرکتوری right، 1.9 مگابایت صرفه‌جویی کنید.

`zic ... -p ...`
    این فایل posixrules را ایجاد می‌کند. ما از نیویورک استفاده می‌کنیم زیرا POSIX نیاز دارد که قوانین ساعت تابستانی مطابق با قوانین ایالات متحده باشد.

یک راه برای تعیین منطقه زمانی محلی، اجرای اسکریپت زیر است:

```bash
tzselect
```

پس از پاسخ به چند سؤال در مورد مکان، اسکریپت نام منطقه زمانی را خروجی می‌دهد (مثلاً America/Edmonton). همچنین برخی مناطق زمانی دیگر احتمالی در /usr/share/zoneinfo مانند Canada/Eastern یا EST5EDT ذکر شده‌اند که توسط اسکریپت شناسایی نمی‌شوند اما می‌توان از آنها استفاده کرد.

سپس با اجرای دستور زیر فایل /etc/localtime را ایجاد کنید:

```bash
ln -sfv /usr/share/zoneinfo/<xxx> /etc/localtime
```

<xxx> را با نام منطقه زمانی انتخاب شده جایگزین کنید (مثلاً Canada/Eastern).

### ۸.۵.۲.۳. پیکربندی لودر پویا

به طور پیش‌فرض، لودر پویا (/lib/ld-linux.so.2) از طریق /usr/lib به دنبال کتابخانه‌های پویایی می‌گردد که توسط برنامه‌ها هنگام اجرا مورد نیاز هستند. با این حال، اگر کتابخانه‌هایی در دایرکتوری‌های دیگری غیر از /usr/lib وجود داشته باشند، این‌ها باید به فایل /etc/ld.so.conf اضافه شوند تا لودر پویا آنها را پیدا کند. دو دایرکتوری که معمولاً شناخته شده‌اند که حاوی کتابخانه‌های اضافی هستند /usr/local/lib و /opt/lib هستند، بنابراین این دایرکتوری‌ها را به مسیر جستجوی لودر پویا اضافه کنید.

با اجرای دستور زیر یک فایل /etc/ld.so.conf جدید ایجاد کنید:

```bash
cat > /etc/ld.so.conf << "EOF"
# Begin /etc/ld.so.conf
/usr/local/lib
/opt/lib

EOF
```

اگر مورد نظر است، لودر پویا می‌تواند همچنین یک دایرکتوری را جستجو کند و محتویات فایل‌های یافت شده در آنجا را شامل کند. عموماً فایل‌ها در این دایرکتوری شامل یک خط مشخص کننده مسیر کتابخانه مورد نظر هستند. برای افزودن این قابلیت دستورات زیر را اجرا کنید:

```bash
cat >> /etc/ld.so.conf << "EOF"
# Add an include directory
include /etc/ld.so.conf.d/*.conf

EOF
mkdir -pv /etc/ld.so.conf.d
```

## ۸.۵.۳. محتویات Glibc

**برنامه‌های نصب شده:**
gencat, getconf, getent, iconv, iconvconfig, ldconfig, ldd, lddlibc4, ld.so (پیوند نمادین به ld-linux-x86-64.so.2 یا ld-linux.so.2), locale, localedef, makedb, mtrace, pcprofiledump, pldd, sln, sotruss, sprof, tzselect, xtrace, zdump, و zic

**کتابخانه‌های نصب شده:**
ld-linux-x86-64.so.2, ld-linux.so.2, libBrokenLocale.{a,so}, libanl.{a,so}, libc.{a,so}, libc_nonshared.a, libc_malloc_debug.so, libdl.{a,so.2}, libg.a, libm.{a,so}, libmcheck.a, libmemusage.so, libmvec.{a,so}, libnsl.so.1, libnss_compat.so, libnss_dns.so, libnss_files.so, libnss_hesiod.so, libpcprofile.so, libpthread.{a,so.0}, libresolv.{a,so}, librt.{a,so.1}, libthread_db.so, و libutil.{a,so.1}

**دایرکتوری‌های نصب شده:**
/usr/include/arpa, /usr/include/bits, /usr/include/gnu, /usr/include/net, /usr/include/netash, /usr/include/netatalk, /usr/include/netax25, /usr/include/neteconet, /usr/include/netinet, /usr/include/netipx, /usr/include/netiucv, /usr/include/netpacket, /usr/include/netrom, /usr/include/netrose, /usr/include/nfs, /usr/include/protocols, /usr/include/rpc, /usr/include/sys, /usr/lib/audit, /usr/lib/gconv, /usr/lib/locale, /usr/libexec/getconf, /usr/share/i18n, /usr/share/zoneinfo, و /var/lib/nss_db

**توضیحات کوتاه:**

`gencat`
کاتالوگ‌های پیام تولید می‌کند

`getconf`
مقادیر پیکربندی سیستم را برای متغیرهای خاص سیستم فایل نمایش می‌دهد

`getent`
ورودی‌ها را از یک پایگاه داده اداری دریافت می‌کند

`iconv`
تبدیل مجموعه کاراکتر را انجام می‌دهد

`iconvconfig`
فایل‌های پیکربندی ماژول iconv با بارگذاری سریع ایجاد می‌کند

`ldconfig`
پیوندهای زمان اجرای لینکر پویا را پیکربندی می‌کند

`ldd`
گزارش می‌دهد که کدام کتابخانه‌های اشتراکی برای هر برنامه یا کتابخانه اشتراکی داده شده مورد نیاز هستند

`lddlibc4`
به ldd با فایل‌های شیء کمک می‌کند. در معماری‌های جدیدتر مانند x86_64 وجود ندارد

`locale`
اطلاعات مختلفی در مورد locale فعلی چاپ می‌کند

`localedef`
مشخصات locale را کامپایل می‌کند

`makedb`
یک پایگاه داده ساده از ورودی متنی ایجاد می‌کند

`mtrace`
یک فایل ردیابی حافظه را می‌خواند و تفسیر می‌کند و خلاصه‌ای را به فرمت قابل خواندن توسط انسان نمایش می‌دهد

`pcprofiledump`
اطلاعات تولید شده توسط پروفایل PC را تخلیه می‌کند

`pldd`
اشیاء اشتراکی پویا مورد استفاده توسط فرآیندهای در حال اجرا را لیست می‌کند

`sln`
یک برنامه ln پیوند شده به صورت استاتیک

`sotruss`
فراخوانی‌های روال کتابخانه اشتراکی یک دستور مشخص شده را ردیابی می‌کند

`sprof`
داده‌های پروفایل شیء اشتراکی را می‌خواند و نمایش می‌دهد

`tzselect`
از کاربر در مورد مکان سیستم می‌پرسد و توصیف منطقه زمانی مربوطه را گزارش می‌کند

`xtrace`
اجرای یک برنامه را با چاپ تابع در حال اجرای فعلی ردیابی می‌کند

`zdump`
تخلیه‌کننده منطقه زمانی

`zic`
کامپایلر منطقه زمانی

`ld-*.so`
برنامه کمکی برای اجرای کتابخانه‌های اشتراکی

`libBrokenLocale`
توسط Glibc به عنوان یک هک خام برای اجرای برنامه‌های خراب (مثلاً برخی برنامه‌های Motif) استفاده می‌شود. برای اطلاعات بیشتر به نظرات در glibc-2.40/locale/broken_cur_max.c مراجعه کنید

`libanl`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً کتابخانه جستجوی نام ناهمزمان بود که توابع آن اکنون در libc هستند

`libc`
کتابخانه اصلی C

`libc_malloc_debug`
هنگام پیش‌بارگذاری، بررسی تخصیص حافظه را فعال می‌کند

`libdl`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً کتابخانه رابط پیوند پویا بود که توابع آن اکنون در libc هستند

`libg`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً یک کتابخانه زمان اجرا برای g++ بود

`libm`
کتابخانه ریاضی

`libmvec`
کتابخانه ریاضی برداری، در صورت نیاز هنگام استفاده از libm پیوند داده می‌شود

`libmcheck`
هنگام پیوند، بررسی تخصیص حافظه را فعال می‌کند

`libmemusage`
توسط memusage برای کمک به جمع‌آوری اطلاعات درباره استفاده از حافظه یک برنامه استفاده می‌شود

`libnsl`
کتابخانه سرویس‌های شبکه، اکنون منسوخ شده است

`libnss_*`
ماژول‌های Switch Service Name، حاوی توابعی برای حل نام‌های میزبان، نام‌های کاربری، نام‌های گروه، نام‌های مستعار، سرویس‌ها، پروتکل‌ها و غیره. توسط libc بر اساس پیکربندی در /etc/nsswitch.conf بارگذاری می‌شوند

`libpcprofile`
می‌تواند برای پروفایل PC یک اجرایی پیش‌بارگذاری شود

`libpthread`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً حاوی توابعی بود که بیشتر رابط‌های مشخص شده توسط POSIX.1c Thread Extensions و رابط‌های سمافور مشخص شده توسط POSIX.1b Real-time Extensions را ارائه می‌کرد، اکنون توابع در libc هستند

`libresolv`
حاوی توابعی برای ایجاد، ارسال و تفسیر بسته‌ها به سرورهای نام دامنه اینترنت است

`librt`
حاوی توابعی است که بیشتر رابط‌های مشخص شده توسط POSIX.1b Real-time Extensions را ارائه می‌دهند

`libthread_db`
حاوی توابع مفید برای ساخت اشکال‌زداها برای برنامه‌های چند رشته‌ای است

`libutil`
کتابخانه ساختگی که هیچ تابعی ندارد. قبلاً حاوی کدی برای توابع "استاندارد" مورد استفاده در بسیاری از ابزارهای مختلف یونیکس بود. این توابع اکنون در libc هستند

# ۸.۶. Zlib-1.3.1

بسته Zlib شامل روال‌های فشرده‌سازی و رمزگشایی است که توسط برخی برنامه‌ها استفاده می‌شود.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 6.4 مگابایت

## ۸.۶.۱. نصب Zlib

Zlib را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

یک کتابخانه استاتیک بی‌استفاده را حذف کنید:

```bash
rm -fv /usr/lib/libz.a
```

## ۸.۶.۲. محتویات Zlib

**کتابخانه‌های نصب شده:** libz.so

توضیحات کوتاه:

`libz`
حاوی توابع فشرده‌سازی و رمزگشایی است که توسط برخی برنامه‌ها استفاده می‌شود

# ۸.۷. Bzip2-1.0.8

بسته Bzip2 شامل برنامه‌هایی برای فشرده‌سازی و رمزگشایی فایل‌ها است. فشرده‌سازی فایل‌های متنی با **bzip2** درصد فشرده‌سازی بسیار بهتری نسبت به **gzip** سنتی ارائه می‌دهد.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 7.2 مگابایت

## ۸.۷.۱. نصب Bzip2

وصله‌ای را اعمال کنید که مستندات این بسته را نصب خواهد کرد:

```bash
patch -Np1 -i ../bzip2-1.0.8-install_docs-1.patch
```

دستور زیر اطمینان می‌دهد که نصب پیوندهای نمادین نسبی است:

```bash
sed -i 's@\(ln -s -f \)$(PREFIX)/bin/@\1@' Makefile
```

اطمینان حاصل کنید که صفحات راهنما در مکان صحیح نصب می‌شوند:

```bash
sed -i "s@(PREFIX)/man@(PREFIX)/share/man@g" Makefile
```

Bzip2 را برای کامپایل آماده کنید:

```bash
make -f Makefile-libbz2_so
make clean
```

**معنی پارامتر make:**
`-f Makefile-libbz2_so`
این باعث می‌شود Bzip2 با استفاده از یک فایل `Makefile` متفاوت ساخته شود، در این مورد فایل `Makefile-libbz2_so`، که یک کتابخانه پویای `libbz2.so` ایجاد می‌کند و ابزارهای Bzip2 را در مقابل آن پیوند می‌دهد.

بسته را کامپایل و آزمایش کنید:

```bash
make
```

برنامه‌ها را نصب کنید:

```bash
make PREFIX=/usr install
```

کتابخانه اشتراکی را نصب کنید:

```bash
cp -av libbz2.so.* /usr/lib
ln -sv libbz2.so.1.0.8 /usr/lib/libbz2.so
```

باینری اشتراکی **bzip2** را در دایرکتوری `/usr/bin` نصب کنید و دو نسخه از **bzip2** را با پیوندهای نمادین جایگزین کنید:

```bash
cp -v bzip2-shared /usr/bin/bzip2
for i in /usr/bin/{bzcat,bunzip2}; do
  ln -sfv bzip2 $i
done
```

یک کتابخانه استاتیک بی‌استفاده را حذف کنید:

```bash
rm -fv /usr/lib/libbz2.a
```

## ۸.۷.۲. محتویات Bzip2

**برنامه‌های نصب شده:** bunzip2 (پیوند به bzip2), bzcat (پیوند به bzip2), bzcmp (پیوند به bzdiff), bzdiff, bzegrep (پیوند به bzgrep), bzfgrep (پیوند به bzgrep), bzgrep, bzip2, bzip2recover, bzless (پیوند به bzmore), و bzmore

**کتابخانه‌های نصب شده:** libbz2.so

**دایرکتوری نصب شده:** /usr/share/doc/bzip2-1.0.8

توضیحات کوتاه:

**bunzip2**
فایل‌های فشرده شده با bzip را رمزگشایی می‌کند

**bzcat**
به خروجی استاندارد رمزگشایی می‌کند

**bzcmp**
**cmp** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzdiff**
**diff** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzegrep**
**egrep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzfgrep**
**fgrep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzgrep**
**grep** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzip2**
فایل‌ها را با استفاده از الگوریتم فشرده‌سازی متن مرتب‌سازی بلوکی Burrows-Wheeler با کدگذاری Huffman فشرده می‌کند؛ نرخ فشرده‌سازی بهتر از آن چیزی است که توسط فشرده‌کننده‌های معمولی‌تر با استفاده از الگوریتم‌های "Lempel-Ziv" مانند **gzip** به دست می‌آید

**bzip2recover**
سعی می‌کند داده‌ها را از فایل‌های bzip آسیب دیده بازیابی کند

**bzless**
**less** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

**bzmore**
**more** را روی فایل‌های فشرده شده با bzip اجرا می‌کند

`libbz2`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف و مرتب‌سازی بلوکی را با استفاده از الگوریتم Burrows-Wheeler پیاده‌سازی می‌کند

# ۸.۸. Xz-5.6.2

بسته Xz شامل برنامه‌هایی برای فشرده‌سازی و رمزگشایی فایل‌ها است. این بسته قابلیت‌هایی برای فرمت‌های فشرده‌سازی lzma و xz جدیدتر فراهم می‌کند. فشرده‌سازی فایل‌های متنی با **xz** درصد فشرده‌سازی بهتری نسبت به دستورات سنتی **gzip** یا **bzip2** ارائه می‌دهد.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 21 مگابایت

## ۸.۸.۱. نصب Xz

Xz را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/xz-5.6.2
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

## ۸.۸.۲. محتویات Xz

**برنامه‌های نصب شده:** lzcat (پیوند به xz), lzcmp (پیوند به xzdiff), lzdiff (پیوند به xzdiff), lzegrep (پیوند به xzgrep), lzfgrep (پیوند به xzgrep), lzgrep (پیوند به xzgrep), lzless (پیوند به xzless), lzma (پیوند به xz), lzmadec, lzmainfo, lzmore (پیوند به xzmore), unlzma (پیوند به xz), unxz (پیوند به xz), xz, xzcat (پیوند به xz), xzcmp (پیوند به xzdiff), xzdec, xzdiff, xzegrep (پیوند به xzgrep), xzfgrep (پیوند به xzgrep), xzgrep, xzless, و xzmore

**کتابخانه‌های نصب شده:** liblzma.so

**دایرکتوری‌های نصب شده:** /usr/include/lzma و /usr/share/doc/xz-5.6.2

توضیحات کوتاه:

**lzcat**
به خروجی استاندارد رمزگشایی می‌کند

**lzcmp**
**cmp** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzdiff**
**diff** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzegrep**
**egrep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzfgrep**
**fgrep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzgrep**
**grep** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzless**
**less** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**lzma**
فایل‌ها را با استفاده از فرمت LZMA فشرده یا رمزگشایی می‌کند

**lzmadec**
یک رمزگشای کوچک و سریع برای فایل‌های فشرده شده با LZMA

**lzmainfo**
اطلاعات ذخیره شده در هدر فایل فشرده شده با LZMA را نمایش می‌دهد

**lzmore**
**more** را روی فایل‌های فشرده شده با LZMA اجرا می‌کند

**unlzma**
فایل‌ها را با استفاده از فرمت LZMA رمزگشایی می‌کند

**unxz**
فایل‌ها را با استفاده از فرمت XZ رمزگشایی می‌کند

**xz**
فایل‌ها را با استفاده از فرمت XZ فشرده یا رمزگشایی می‌کند

**xzcat**
به خروجی استاندارد رمزگشایی می‌کند

**xzcmp**
**cmp** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzdec**
یک رمزگشای کوچک و سریع برای فایل‌های فشرده شده با XZ

**xzdiff**
**diff** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzegrep**
**egrep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzfgrep**
**fgrep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzgrep**
**grep** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzless**
**less** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

**xzmore**
**more** را روی فایل‌های فشرده شده با XZ اجرا می‌کند

`liblzma`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف و مرتب‌سازی بلوکی را با استفاده از الگوریتم Lempel-Ziv-Markov chain پیاده‌سازی می‌کند

# ۸.۹. Lz4-1.10.0

Lz4 یک الگوریتم فشرده‌سازی بدون اتلاف است که سرعت فشرده‌سازی بیش از 500 مگابایت بر ثانیه برای هر هسته را ارائه می‌دهد. این الگوریتم دارای یک رمزگشای بسیار سریع است، با سرعتی در حد چندین گیگابایت بر ثانیه برای هر هسته. Lz4 می‌تواند با Zstandard کار کند تا هر دو الگوریتم بتوانند داده‌ها را سریع‌تر فشرده کنند.

**زمان تقریبی ساخت:** 0.1 SBU
**فضای دیسک مورد نیاز:** 4.2 مگابایت

## ۸.۹.۱. نصب Lz4

بسته را کامپایل کنید:

```bash
make BUILD_STATIC=no PREFIX=/usr
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make -j1 check
```

بسته را نصب کنید:

```bash
make BUILD_STATIC=no PREFIX=/usr install
```

## ۸.۹.۲. محتویات Lz4

**برنامه‌های نصب شده:** lz4, lz4c (پیوند به lz4), lz4cat (پیوند به lz4), و unlz4 (پیوند به lz4)
**کتابخانه نصب شده:** liblz4.so

توضیحات کوتاه:

**lz4**
فایل‌ها را با استفاده از فرمت LZ4 فشرده یا رمزگشایی می‌کند

**lz4c**
فایل‌ها را با استفاده از فرمت LZ4 فشرده می‌کند

**lz4cat**
محتویات فایل فشرده شده با فرمت LZ4 را لیست می‌کند

**unlz4**
فایل‌ها را با استفاده از فرمت LZ4 رمزگشایی می‌کند

`liblz4`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف را با استفاده از الگوریتم LZ4 پیاده‌سازی می‌کند

# ۸.۱۰. Zstd-1.5.6

Zstandard یک الگوریتم فشرده‌سازی بلادرنگ است که نسبت‌های فشرده‌سازی بالایی ارائه می‌دهد. این الگوریتم طیف بسیار گسترده‌ای از تعادل بین فشرده‌سازی و سرعت را ارائه می‌دهد، در حالی که توسط یک رمزگشای بسیار سریع پشتیبانی می‌شود.

**زمان تقریبی ساخت:** 0.4 SBU
**فضای دیسک مورد نیاز:** 84 مگابایت

## ۸.۱۰.۱. نصب Zstd

بسته را کامپایل کنید:

```bash
make prefix=/usr
```

**نکته**
در خروجی آزمون چندین مکان وجود دارد که 'failed' را نشان می‌دهد. این‌ها مورد انتظار هستند و فقط 'FAIL' یک شکست واقعی آزمون است. نباید هیچ شکست آزمونی وجود داشته باشد.

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make prefix=/usr install
```

کتابخانه استاتیک را حذف کنید:

```bash
rm -v /usr/lib/libzstd.a
```

## ۸.۱۰.۲. محتویات Zstd

**برنامه‌های نصب شده:** zstd, zstdcat (پیوند به zstd), zstdgrep, zstdless, zstdmt (پیوند به zstd), و unzstd (پیوند به zstd)
**کتابخانه نصب شده:** libzstd.so

توضیحات کوتاه:

**zstd**
فایل‌ها را با استفاده از فرمت ZSTD فشرده یا رمزگشایی می‌کند

**zstdgrep**
**grep** را روی فایل‌های فشرده شده با ZSTD اجرا می‌کند

**zstdless**
**less** را روی فایل‌های فشرده شده با ZSTD اجرا می‌کند

`libzstd`
کتابخانه‌ای که فشرده‌سازی داده بدون اتلاف را با استفاده از الگوریتم ZSTD پیاده‌سازی می‌کند

# ۸.۱۱. File-5.45

بسته File شامل ابزاری برای تعیین نوع فایل یا فایل‌های داده شده است.

**زمان تقریبی ساخت:** کمتر از 0.1 SBU
**فضای دیسک مورد نیاز:** 17 مگابایت

## ۸.۱۱.۱. نصب File

File را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr
```

بسته را کامپایل کنید:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

بسته را نصب کنید:

```bash
make install
```

## ۸.۱۱.۲. محتویات File

**برنامه نصب شده:** file
**کتابخانه نصب شده:** libmagic.so

توضیحات کوتاه:

**file**

سعی می‌کند هر فایل داده شده را طبقه‌بندی کند؛ این کار را با انجام چندین آزمایش انجام می‌دهد - آزمایش‌های سیستم فایل، آزمایش‌های عدد جادویی و آزمایش‌های زبان

`libmagic`

حاوی روال‌هایی برای تشخیص عدد جادویی است که توسط برنامه **file** استفاده می‌شود

# 8.12. Readline-8.2.13

بسته Readline مجموعه‌ای از کتابخانه‌هاست که قابلیت‌های ویرایش خط فرمان و تاریخچه را ارائه می‌دهد.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 16 مگابایت

## 8.12.1. نصب Readline

نصب مجدد Readline باعث می‌شود کتابخانه‌های قدیمی به <libraryname>.old منتقل شوند. اگرچه این معمولاً مشکلی ایجاد نمی‌کند، اما در برخی موارد ممکن است باعث بروز خطای پیوند در ldconfig شود. این مشکل را می‌توان با اجرای دو دستور sed زیر برطرف کرد:

```bash
sed -i '/MV.*old/d' Makefile.in
sed -i '/{OLDSUFF}/c:' support/shlib-install
```

برای جلوگیری از کدگذاری سخت مسیرهای جستجوی کتابخانه (rpath) در کتابخانه‌های اشتراکی. این بسته برای نصب در مکان استاندارد به rpath نیاز ندارد و rpath ممکن است گاهی اوقات باعث اثرات ناخواسته یا حتی مشکلات امنیتی شود:

```bash
sed -i 's/-Wl,-rpath,[^ ]*//' support/shobj-conf
```

آماده‌سازی Readline برای کامپایل:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --with-curses    \
            --docdir=/usr/share/doc/readline-8.2.13
```

معنی گزینه جدید configure:

- `--with-curses`: این گزینه به Readline می‌گوید که می‌تواند توابع کتابخانه termcap را در کتابخانه curses پیدا کند، نه در یک کتابخانه termcap جداگانه. این کار فایل readline.pc صحیح را تولید خواهد کرد.

کامپایل بسته:

```bash
make SHLIB_LIBS="-lncursesw"
```

معنی گزینه make:

- `SHLIB_LIBS="-lncursesw"`: این گزینه Readline را مجبور می‌کند تا به کتابخانه libncursesw پیوند شود.

این بسته دارای مجموعه آزمون نیست.

نصب بسته:

```bash
make SHLIB_LIBS="-lncursesw" install
```

در صورت تمایل، مستندات را نصب کنید:

```bash
install -v -m644 doc/*.{ps,pdf,html,dvi} /usr/share/doc/readline-8.2.13
```

## 8.12.2. محتویات Readline

کتابخانه‌های نصب شده:
- libhistory.so و libreadline.so

دایرکتوری‌های نصب شده:
- /usr/include/readline و /usr/share/doc/readline-8.2.13

توضیحات کوتاه:

- `libhistory`: یک رابط کاربری یکنواخت برای یادآوری خطوط تاریخچه ارائه می‌دهد
- `libreadline`: مجموعه‌ای از دستورات برای دستکاری متن وارد شده در یک جلسه تعاملی یک برنامه ارائه می‌دهد

# 8.13. M4-1.4.19

بسته M4 شامل یک پردازشگر ماکرو است.

زمان تقریبی ساخت: 0.3 SBU
فضای دیسک مورد نیاز: 48 مگابایت

## 8.13.1. نصب M4

آماده‌سازی M4 برای کامپایل:

```bash
./configure --prefix=/usr
```

کامپایل بسته:

```bash
make
```

برای آزمایش نتایج، دستور زیر را اجرا کنید:

```bash
make check
```

نصب بسته:

```bash
make install
```

## 8.13.2. محتویات M4

برنامه نصب شده:
- m4

توضیحات کوتاه:

- `m4`: فایل‌های داده شده را در حالی که ماکروهای موجود در آنها را گسترش می‌دهد، کپی می‌کند. این ماکروها می‌توانند داخلی یا تعریف شده توسط کاربر باشند و می‌توانند هر تعداد آرگومان داشته باشند. علاوه بر انجام گسترش ماکرو، m4 دارای توابع داخلی برای شامل کردن فایل‌های نام‌گذاری شده، اجرای دستورات یونیکس، انجام محاسبات صحیح، دستکاری متن، بازگشت و غیره است. برنامه m4 می‌تواند به عنوان یک frontend برای یک کامپایلر یا به عنوان یک پردازشگر ماکرو به خودی خود استفاده شود.

# 8.14. Bc-6.7.6

بسته Bc شامل یک زبان پردازش عددی با دقت دلخواه است.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 7.8 مگابایت

## 8.14.1. نصب Bc

آماده‌سازی Bc برای کامپایل:

```bash
CC=gcc ./configure --prefix=/usr -G -O3 -r
```

معنی گزینه‌های configure:

- `CC=gcc`: این پارامتر کامپایلر مورد استفاده را مشخص می‌کند.
- `-G`: بخش‌هایی از مجموعه آزمون که تا زمانی که برنامه bc نصب نشده است کار نخواهند کرد را حذف می‌کند.
- `-O3`: بهینه‌سازی مورد استفاده را مشخص می‌کند.
- `-r`: استفاده از Readline را برای بهبود ویژگی ویرایش خط bc فعال می‌کند.

کامپایل بسته:

```bash
make
```

برای آزمایش bc، اجرا کنید:

```bash
make test
```

نصب بسته:

```bash
make install
```

## 8.14.2. محتویات Bc

برنامه‌های نصب شده:
- bc و dc

توضیحات کوتاه:

- `bc`: یک ماشین حساب خط فرمان
- `dc`: یک ماشین حساب خط فرمان با نماد پسوندی معکوس

# 8.15. Flex-2.6.4

بسته Flex شامل یک ابزار برای تولید برنامه‌هایی است که الگوها را در متن تشخیص می‌دهند.

زمان تقریبی ساخت: 0.1 SBU
فضای دیسک مورد نیاز: 33 مگابایت

## 8.15.1. نصب Flex

آماده‌سازی Flex برای کامپایل:

```bash
./configure --prefix=/usr \
            --docdir=/usr/share/doc/flex-2.6.4 \
            --disable-static
```

کامپایل بسته:

```bash
make
```

برای آزمایش نتایج (حدود 0.5 SBU)، دستور زیر را صادر کنید:

```bash
make check
```

نصب بسته:

```bash
make install
```

تعدادی از برنامه‌ها هنوز flex را نمی‌شناسند و سعی می‌کنند پیشینیان آن، lex را اجرا کنند. برای پشتیبانی از این برنامه‌ها، یک پیوند نمادین به نام lex ایجاد کنید که flex را در حالت شبیه‌سازی lex اجرا می‌کند، و همچنین صفحه man lex را به عنوان یک پیوند نمادین ایجاد کنید:

```bash
ln -sv flex   /usr/bin/lex
ln -sv flex.1 /usr/share/man/man1/lex.1
```

## 8.15.2. محتویات Flex

برنامه‌های نصب شده:
- flex، flex++ (پیوند به flex)، و lex (پیوند به flex)

کتابخانه‌های نصب شده:
- libfl.so

دایرکتوری نصب شده:
- /usr/share/doc/flex-2.6.4

توضیحات کوتاه:

- `flex`: ابزاری برای تولید برنامه‌هایی که الگوها را در متن تشخیص می‌دهند؛ این ابزار انعطاف‌پذیری لازم برای تعیین قوانین جستجوی الگو را فراهم می‌کند و نیاز به توسعه یک برنامه تخصصی را از بین می‌برد
- `flex++`: یک توسعه از flex، برای تولید کد و کلاس‌های ++C استفاده می‌شود. این یک پیوند نمادین به flex است
- `lex`: یک پیوند نمادین که flex را در حالت شبیه‌سازی lex اجرا می‌کند
- `libfl`: کتابخانه flex

# 8.16. Tcl-8.6.14

بسته Tcl شامل زبان فرمان ابزار (Tool Command Language) است، یک زبان اسکریپت‌نویسی قدرتمند و همه منظوره. بسته Expect در Tcl نوشته شده است (تلفظ می‌شود "tickle").

زمان تقریبی ساخت: 3.2 SBU
فضای دیسک مورد نیاز: 91 مگابایت

## 8.16.1. نصب Tcl

این بسته و دو بسته بعدی (Expect و DejaGNU) برای پشتیبانی از اجرای مجموعه آزمون‌های Binutils، GCC و سایر بسته‌ها نصب می‌شوند. نصب سه بسته برای اهداف آزمایش ممکن است بیش از حد به نظر برسد، اما بسیار اطمینان‌بخش، اگر نه ضروری، است که بدانیم مهم‌ترین ابزارها به درستی کار می‌کنند.

آماده‌سازی Tcl برای کامپایل:

```bash
SRCDIR=$(pwd)
cd unix
./configure --prefix=/usr           \
            --mandir=/usr/share/man \
            --disable-rpath
```

معنی پارامترهای جدید configure:

- `--disable-rpath`: این پارامتر از کدگذاری سخت مسیرهای جستجوی کتابخانه (rpath) در فایل‌های اجرایی باینری و کتابخانه‌های اشتراکی جلوگیری می‌کند. این بسته برای نصب در مکان استاندارد به rpath نیاز ندارد و rpath ممکن است گاهی اوقات باعث اثرات ناخواسته یا حتی مشکلات امنیتی شود.

ساخت بسته:

```bash
make

sed -e "s|$SRCDIR/unix|/usr/lib|" \
    -e "s|$SRCDIR|/usr/include|"  \
    -i tclConfig.sh

sed -e "s|$SRCDIR/unix/pkgs/tdbc1.1.7|/usr/lib/tdbc1.1.7|" \
    -e "s|$SRCDIR/pkgs/tdbc1.1.7/generic|/usr/include|"    \
    -e "s|$SRCDIR/pkgs/tdbc1.1.7/library|/usr/lib/tcl8.6|" \
    -e "s|$SRCDIR/pkgs/tdbc1.1.7|/usr/include|"            \
    -i pkgs/tdbc1.1.7/tdbcConfig.sh

sed -e "s|$SRCDIR/unix/pkgs/itcl4.2.4|/usr/lib/itcl4.2.4|" \
    -e "s|$SRCDIR/pkgs/itcl4.2.4/generic|/usr/include|"    \
    -e "s|$SRCDIR/pkgs/itcl4.2.4|/usr/include|"            \
    -i pkgs/itcl4.2.4/itclConfig.sh

unset SRCDIR
```

دستورات مختلف "sed" پس از دستور "make" ارجاعات به دایرکتوری ساخت را از فایل‌های پیکربندی حذف می‌کنند و آنها را با دایرکتوری نصب جایگزین می‌کنند. این برای باقیمانده LFS الزامی نیست، اما ممکن است برای بسته‌ای که بعداً ساخته می‌شود و از Tcl استفاده می‌کند، مورد نیاز باشد.

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make test
```
نصب بسته:

```bash
make install
```

کتابخانه نصب شده را قابل نوشتن کنید تا بتوان نمادهای اشکال‌زدایی را بعداً حذف کرد:

```bash
chmod -v u+w /usr/lib/libtcl8.6.so
```

هدرهای Tcl را نصب کنید. بسته بعدی، Expect، به آنها نیاز دارد.

```bash
make install-private-headers
```

حالا یک پیوند نمادین ضروری ایجاد کنید:

```bash
ln -sfv tclsh8.6 /usr/bin/tclsh
```

یک صفحه man که با یک صفحه man Perl تداخل دارد را تغییر نام دهید:

```bash
mv /usr/share/man/man3/{Thread,Tcl_Thread}.3
```

به صورت اختیاری، مستندات را با اجرای دستورات زیر نصب کنید:

```bash
cd ..
tar -xf ../tcl8.6.14-html.tar.gz --strip-components=1
mkdir -v -p /usr/share/doc/tcl-8.6.14
cp -v -r  ./html/* /usr/share/doc/tcl-8.6.14
```

## 8.16.2. محتویات Tcl

برنامه‌های نصب شده:
- tclsh (پیوند به tclsh8.6) و tclsh8.6

کتابخانه نصب شده:
- libtcl8.6.so و libtclstub8.6.a

توضیحات کوتاه:

- `tclsh8.6`: پوسته فرمان Tcl
- `tclsh`: پیوندی به tclsh8.6
- `libtcl8.6.so`: کتابخانه Tcl
- `libtclstub8.6.a`: کتابخانه Stub Tcl

# 8.17. Expect-5.45.4

بسته Expect شامل ابزارهایی برای خودکارسازی، از طریق گفتگوهای اسکریپت شده، برنامه‌های تعاملی مانند telnet، ftp، passwd، fsck، rlogin و tip است. Expect همچنین برای آزمایش این برنامه‌ها و همچنین تسهیل انواع وظایفی که با هر چیز دیگری به طور ممنوعه دشوار هستند، مفید است. چارچوب DejaGnu در Expect نوشته شده است.

زمان تقریبی ساخت: 0.2 SBU
فضای دیسک مورد نیاز: 3.9 مگابایت

## 8.17.1. نصب Expect

Expect برای کار کردن به PTYها نیاز دارد. با انجام یک آزمایش ساده، بررسی کنید که PTYها در محیط chroot به درستی کار می‌کنند:

```bash
python3 -c 'from pty import spawn; spawn(["echo", "ok"])'
```

این دستور باید "ok" را چاپ کند. اگر به جای آن، خروجی شامل "OSError: out of pty devices" باشد، محیط برای عملیات مناسب PTY تنظیم نشده است. باید از محیط chroot خارج شوید، بخش 7.3، "آماده‌سازی سیستم‌های فایل کرنل مجازی" را دوباره بخوانید و اطمینان حاصل کنید که سیستم فایل devpts (و سایر سیستم‌های فایل کرنل مجازی) به درستی نصب شده‌اند. سپس با پیروی از بخش 7.4، "ورود به محیط Chroot" دوباره وارد محیط chroot شوید. این مسئله باید قبل از ادامه حل شود، در غیر این صورت مجموعه آزمون‌هایی که به Expect نیاز دارند (به عنوان مثال مجموعه آزمون‌های Bash، Binutils، GCC، GDBM و البته خود Expect) به طور فاجعه‌باری شکست خواهند خورد، و خرابی‌های ظریف دیگری نیز ممکن است رخ دهد.

حالا، برخی تغییرات را انجام دهید تا بسته با gcc-14.1 یا بالاتر کار کند:

```bash
patch -Np1 -i ../expect-5.45.4-gcc14-1.patch
```

آماده‌سازی Expect برای کامپایل:

```bash
./configure --prefix=/usr           \
            --with-tcl=/usr/lib     \
            --enable-shared         \
            --disable-rpath         \
            --mandir=/usr/share/man \
            --with-tclinclude=/usr/include
```

معنی گزینه‌های configure:

- `--with-tcl=/usr/lib`: این پارامتر برای گفتن به configure که اسکریپت tclConfig.sh کجا قرار دارد، مورد نیاز است.
- `--with-tclinclude=/usr/include`: این به صراحت به Expect می‌گوید که هدرهای داخلی Tcl را کجا پیدا کند.

ساخت بسته:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make test
```

نصب بسته:

```bash
make install
ln -svf expect5.45.4/libexpect5.45.4.so /usr/lib
```

## 8.17.2. محتویات Expect

برنامه نصب شده:
- expect

کتابخانه نصب شده:
- libexpect5.45.4.so

توضیحات کوتاه:

- `expect`: با سایر برنامه‌های تعاملی مطابق با یک اسکریپت ارتباط برقرار می‌کند
- `libexpect-5.45.4.so`: شامل توابعی است که به Expect اجازه می‌دهد به عنوان یک افزونه Tcl استفاده شود یا مستقیماً از C یا ++C (بدون Tcl) استفاده شود

# 8.18. DejaGNU-1.6.3

بسته DejaGNU شامل یک چارچوب برای اجرای مجموعه آزمون‌ها بر روی ابزارهای GNU است. این در expect نوشته شده است، که خود از Tcl (Tool Command Language) استفاده می‌کند.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 6.9 مگابایت

## 8.18.1. نصب DejaGNU

بالادست توصیه می‌کند که DejaGNU را در یک دایرکتوری ساخت اختصاصی بسازید:

```bash
mkdir -v build
cd       build
```

آماده‌سازی DejaGNU برای کامپایل:

```bash
../configure --prefix=/usr
makeinfo --html --no-split -o doc/dejagnu.html ../doc/dejagnu.texi
makeinfo --plaintext       -o doc/dejagnu.txt  ../doc/dejagnu.texi
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

نصب بسته:

```bash
make install
install -v -dm755  /usr/share/doc/dejagnu-1.6.3
install -v -m644   doc/dejagnu.{html,txt} /usr/share/doc/dejagnu-1.6.3
```

## 8.18.2. محتویات DejaGNU

برنامه‌های نصب شده:
- dejagnu و runtest

توضیحات کوتاه:

- `dejagnu`: راه‌انداز کمکی فرمان DejaGNU
- `runtest`: یک اسکریپت پوششی که پوسته expect مناسب را پیدا می‌کند و سپس DejaGNU را اجرا می‌کند

# 8.19. Pkgconf-2.3.0

بسته pkgconf جانشین pkg-config است و شامل ابزاری برای انتقال مسیر include و/یا مسیرهای کتابخانه به ابزارهای ساخت در طول مراحل configure و make نصب بسته‌ها است.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 4.7 مگابایت

## 8.19.1. نصب Pkgconf

آماده‌سازی Pkgconf برای کامپایل:

```bash
./configure --prefix=/usr              \
            --disable-static           \
            --docdir=/usr/share/doc/pkgconf-2.3.0
```

کامپایل بسته:

```bash
make
```

نصب بسته:

```bash
make install
```

برای حفظ سازگاری با Pkg-config اصلی، دو پیوند نمادین ایجاد کنید:

```bash
ln -sv pkgconf   /usr/bin/pkg-config
ln -sv pkgconf.1 /usr/share/man/man1/pkg-config.1
```

## 8.19.2. محتویات Pkgconf

برنامه‌های نصب شده:
- pkgconf، pkg-config (پیوند به pkgconf)، و bomtool

کتابخانه نصب شده:
- libpkgconf.so

دایرکتوری نصب شده:
- /usr/share/doc/pkgconf-2.3.0

توضیحات کوتاه:

- `pkgconf`:

 اطلاعات متا را برای کتابخانه یا بسته مشخص شده برمی‌گرداند
- `bomtool`:

 یک فهرست مواد نرم‌افزاری (Software Bill Of Materials) از فایل‌های .pc مربوط به pkg-config تولید می‌کند
- `libpkgconf`: 

شامل بیشتر عملکردهای pkgconf است، در حالی که به ابزارهای دیگر مانند IDEها و کامپایلرها اجازه می‌دهد از چارچوب‌های آن استفاده کنند


# 8.20. Binutils-2.43.1

بسته Binutils شامل یک لینکر، یک اسمبلر و ابزارهای دیگر برای کار با فایل‌های شیء است.

زمان تقریبی ساخت: 2.0 SBU
فضای دیسک مورد نیاز: 2.7 گیگابایت

## 8.20.1. نصب Binutils

مستندات Binutils توصیه می‌کند که Binutils را در یک دایرکتوری ساخت اختصاصی بسازید:

```bash
mkdir -v build
cd       build
```

آماده‌سازی Binutils برای کامپایل:

```bash
../configure --prefix=/usr       \
             --sysconfdir=/etc   \
             --enable-gold       \
             --enable-ld=default \
             --enable-plugins    \
             --enable-shared     \
             --disable-werror    \
             --enable-64-bit-bfd \
             --enable-new-dtags  \
             --with-system-zlib  \
             --enable-default-hash-style=gnu
```

معنی پارامترهای جدید configure:

- `--enable-gold`:

 لینکر gold را بسازید و آن را به عنوان ld.gold (در کنار لینکر پیش‌فرض) نصب کنید.
- `--enable-ld=default`:

 لینکر اصلی bfd را بسازید و آن را هم به عنوان ld (لینکر پیش‌فرض) و هم ld.bfd نصب کنید.
- `--enable-plugins`:

 پشتیبانی از پلاگین را برای لینکر فعال می‌کند.
- `--with-system-zlib`:

 از کتابخانه zlib نصب شده به جای ساخت نسخه شامل شده استفاده کنید.

کامپایل بسته:

```bash
make tooldir=/usr
```

معنی پارامتر make:

- `tooldir=/usr`:

 معمولاً، tooldir (دایرکتوری که اجراییها در نهایت در آن قرار خواهند گرفت) به $(exec_prefix)/$(target_alias) تنظیم می‌شود. برای مثال، ماشین‌های x86_64 آن را به /usr/x86_64-pc-linux-gnu گسترش می‌دهند. از آنجا که این یک سیستم سفارشی است، این دایرکتوری مخصوص هدف در /usr مورد نیاز نیست. $(exec_prefix)/$(target_alias) در صورتی استفاده می‌شود که سیستم برای کراس‌کامپایل استفاده شود (به عنوان مثال، کامپایل یک بسته روی یک ماشین Intel که کدی تولید می‌کند که می‌تواند روی ماشین‌های PowerPC اجرا شود).

[مهم] مهم

مجموعه آزمون برای Binutils در این بخش بحرانی در نظر گرفته می‌شود. تحت هیچ شرایطی از آن صرف نظر نکنید.

آزمایش نتایج:

```bash
make -k check
```

برای مشاهده لیست آزمون‌های ناموفق، اجرا کنید:

```bash
grep '^FAIL:' $(find -name '*.log')
```

دوازده آزمون در مجموعه آزمون gold زمانی که گزینه‌های --enable-default-pie و --enable-default-ssp به GCC ارسال می‌شوند، شکست می‌خورند.

نصب بسته:

```bash
make tooldir=/usr install
```

حذف کتابخانه‌های استاتیک بی‌استفاده:

```bash
rm -fv /usr/lib/lib{bfd,ctf,ctf-nobfd,gprofng,opcodes,sframe}.a
```

## 8.20.2. محتویات Binutils

برنامه‌های نصب شده:
addr2line, ar, as, c++filt, dwp, elfedit, gprof, gprofng, ld, ld.bfd, ld.gold, nm, objcopy, objdump, ranlib, readelf, size, strings, و strip

کتابخانه‌های نصب شده:
libbfd.so, libctf.so, libctf-nobfd.so, libgprofng.so, libopcodes.so, و libsframe.so

دایرکتوری نصب شده:
/usr/lib/ldscripts

توضیحات کوتاه:

- `addr2line`:

 آدرس‌های برنامه را به نام فایل‌ها و شماره خطوط ترجمه می‌کند
- `ar`:

 آرشیوها را ایجاد، اصلاح و استخراج می‌کند
- `as`:

 یک اسمبلر که خروجی gcc را به فایل‌های شیء اسمبل می‌کند
- `c++filt`:

توسط لینکر برای رمزگشایی نمادهای ++C و Java استفاده می‌شود
- `dwp`:

 ابزار بسته‌بندی DWARF
- `elfedit`:

 هدرهای ELF فایل‌های ELF را به‌روزرسانی می‌کند
- `gprof`:

 داده‌های نمایه گراف تماس را نمایش می‌دهد
- `gprofng`:

 داده‌های عملکرد را جمع‌آوری و تحلیل می‌کند
- `ld`:

 یک لینکر که تعدادی فایل شیء و آرشیو را در یک فایل واحد ترکیب می‌کند
- `ld.gold`:

 نسخه کاهش یافته ld که فقط از فرمت فایل شیء elf پشتیبانی می‌کند
- `ld.bfd`:

 یک پیوند سخت به ld
- `nm`:

 نمادهای موجود در یک فایل شیء معین را لیست می‌کند
- `objcopy`:

 یک نوع فایل شیء را به نوع دیگر ترجمه می‌کند
- `objdump`:

 اطلاعات مربوط به فایل شیء داده شده را نمایش می‌دهد
- `ranlib`:

 یک فهرست از محتویات یک آرشیو تولید می‌کند و آن را در آرشیو ذخیره می‌کند
- `readelf`:

 اطلاعات مربوط به باینری‌های نوع ELF را نمایش می‌دهد
- `size`:

 اندازه بخش‌ها و اندازه کل فایل‌های شیء داده شده را لیست می‌کند
- `strings`:

 برای هر فایل داده شده، دنباله‌های کاراکترهای قابل چاپ را خروجی می‌دهد
- `strip`:

 نمادها را از فایل‌های شیء حذف می‌کند
- `libbfd`:

 کتابخانه توصیف‌کننده فایل باینری
- `libctf`:

 کتابخانه پشتیبانی اشکال‌زدایی فرمت نوع Compat ANSI-C
- `libctf-nobfd`:

 نسخه‌ای از libctf که از عملکرد libbfd استفاده نمی‌کند
- `libgprofng`:

 کتابخانه‌ای شامل اکثر روال‌های مورد استفاده توسط gprofng
- `libopcodes`:

 کتابخانه‌ای برای کار با کدهای عملیاتی
- `libsframe`:

 کتابخانه‌ای برای پشتیبانی از ردیابی آنلاین با استفاده از یک بازکننده ساده


# 8.21. GMP-6.3.0

بسته GMP شامل کتابخانه‌های ریاضی است. این کتابخانه‌ها توابع مفیدی برای محاسبات با دقت دلخواه دارند.

زمان تقریبی ساخت: 0.3 SBU
فضای دیسک مورد نیاز: 54 مگابایت

## 8.21.1. نصب GMP

[نکته] نکته
اگر در حال ساخت برای x86 32 بیتی هستید، اما CPU شما قادر به اجرای کد 64 بیتی است و CFLAGS را در محیط مشخص کرده‌اید، اسکریپت configure تلاش خواهد کرد برای 64 بیت پیکربندی کند و شکست خواهد خورد. برای جلوگیری از این مشکل، دستور configure زیر را با
`ABI=32 ./configure ...`
فراخوانی کنید.

[نکته] نکته
تنظیمات پیش‌فرض GMP کتابخانه‌هایی را تولید می‌کند که برای پردازنده میزبان بهینه شده‌اند. اگر کتابخانه‌هایی مناسب برای پردازنده‌های با قابلیت کمتر از CPU میزبان مورد نیاز است، می‌توان کتابخانه‌های عمومی را با افزودن گزینه `--host=none-linux-gnu` به دستور configure ایجاد کرد.

آماده‌سازی GMP برای کامپایل:

```bash
./configure --prefix=/usr    \
            --enable-cxx     \
            --disable-static \
            --docdir=/usr/share/doc/gmp-6.3.0
```

معنی گزینه‌های جدید configure:

- `--enable-cxx`:

 این پارامتر پشتیبانی از ++C را فعال می‌کند
- `--docdir=/usr/share/doc/gmp-6.3.0`:

 این متغیر مکان صحیح برای مستندات را مشخص می‌کند.

کامپایل بسته و تولید مستندات HTML:

```bash
make
make html
```

[مهم] مهم
مجموعه آزمون برای GMP در این بخش بحرانی در نظر گرفته می‌شود. تحت هیچ شرایطی از آن صرف نظر نکنید.

آزمایش نتایج:

```bash
make check 2>&1 | tee gmp-check-log
```

[احتیاط] احتیاط
کد در gmp برای پردازنده‌ای که روی آن ساخته می‌شود بسیار بهینه شده است. گاهی اوقات، کدی که پردازنده را تشخیص می‌دهد، قابلیت‌های سیستم را اشتباه شناسایی می‌کند و خطاهایی در آزمون‌ها یا سایر برنامه‌هایی که از کتابخانه‌های gmp استفاده می‌کنند با پیام "Illegal instruction" رخ خواهد داد. در این صورت، gmp باید با گزینه `--host=none-linux-gnu` مجدداً پیکربندی و بازسازی شود.

اطمینان حاصل کنید که حداقل 199 آزمون در مجموعه آزمون قبول شده‌اند. نتایج را با صدور دستور زیر بررسی کنید:

```bash
awk '/# PASS:/{total+=$3} ; END{print total}' gmp-check-log
```

نصب بسته و مستندات آن:

```bash
make install
make install-html
```

## 8.21.2. محتویات GMP

کتابخانه‌های نصب شده:
libgmp.so و libgmpxx.so

دایرکتوری نصب شده:
/usr/share/doc/gmp-6.3.0

توضیحات کوتاه:

- `libgmp`:

 شامل توابع ریاضی با دقت بالا
- `libgmpxx`:

 شامل توابع ریاضی با دقت بالا برای ++C

# 8.22. MPFR-4.2.1

بسته MPFR شامل توابعی برای ریاضیات با دقت چندگانه است.

زمان تقریبی ساخت: 0.2 SBU
فضای دیسک مورد نیاز: 43 مگابایت

## 8.22.1. نصب MPFR

آماده‌سازی MPFR برای کامپایل:

```bash
./configure --prefix=/usr        \
            --disable-static     \
            --enable-thread-safe \
            --docdir=/usr/share/doc/mpfr-4.2.1
```

کامپایل بسته و تولید مستندات HTML:

```bash
make
make html
```

[مهم] مهم
مجموعه آزمون برای MPFR در این بخش بحرانی در نظر گرفته می‌شود. تحت هیچ شرایطی از آن صرف نظر نکنید.

آزمایش نتایج و اطمینان از قبولی تمام 198 آزمون:

```bash
make check
```

نصب بسته و مستندات آن:

```bash
make install
make install-html
```

## 8.22.2. محتویات MPFR

کتابخانه نصب شده:
libmpfr.so

دایرکتوری نصب شده:
/usr/share/doc/mpfr-4.2.1

توضیحات کوتاه:

- `libmpfr`:

 شامل توابع ریاضی با دقت چندگانه

# 8.23. MPC-1.3.1

بسته MPC شامل یک کتابخانه برای محاسبات اعداد مختلط با دقت دلخواه و گرد کردن صحیح نتیجه است.

زمان تقریبی ساخت: 0.1 SBU
فضای دیسک مورد نیاز: 22 مگابایت

## 8.23.1. نصب MPC

آماده‌سازی MPC برای کامپایل:

```bash
./configure --prefix=/usr    \
            --disable-static \
            --docdir=/usr/share/doc/mpc-1.3.1
```

کامپایل بسته و تولید مستندات HTML:

```bash
make
make html
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

نصب بسته و مستندات آن:

```bash
make install
make install-html
```

## 8.23.2. محتویات MPC

کتابخانه نصب شده:
libmpc.so

دایرکتوری نصب شده:
/usr/share/doc/mpc-1.3.1

توضیحات کوتاه:

- `libmpc`:

 شامل توابع ریاضی مختلط

# 8.24. Attr-2.5.2

بسته Attr شامل ابزارهایی برای مدیریت ویژگی‌های گسترش یافته اشیاء سیستم فایل است.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 4.1 مگابایت

## 8.24.1. نصب Attr

آماده‌سازی Attr برای کامپایل:

```bash
./configure --prefix=/usr     \
            --disable-static  \
            --sysconfdir=/etc \
            --docdir=/usr/share/doc/attr-2.5.2
```

کامپایل بسته:

```bash
make
```

آزمون‌ها باید روی یک سیستم فایل اجرا شوند که از ویژگی‌های گسترش یافته پشتیبانی می‌کند، مانند سیستم‌های فایل ext2، ext3 یا ext4. برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

نصب بسته:

```bash
make install
```

## 8.24.2. محتویات Attr

برنامه‌های نصب شده:
attr، getfattr و setfattr

کتابخانه نصب شده:
libattr.so

دایرکتوری‌های نصب شده:
/usr/include/attr و /usr/share/doc/attr-2.5.2

توضیحات کوتاه:

- `attr`:

 ویژگی‌های گسترش یافته را بر روی اشیاء سیستم فایل اعمال می‌کند
- `getfattr`:

 ویژگی‌های گسترش یافته اشیاء سیستم فایل را دریافت می‌کند
- `setfattr`:

 ویژگی‌های گسترش یافته اشیاء سیستم فایل را تنظیم می‌کند
- `libattr`:

 شامل توابع کتابخانه برای دستکاری ویژگی‌های گسترش یافته

# 8.25. Acl-2.3.2

بسته Acl شامل ابزارهایی برای مدیریت لیست‌های کنترل دسترسی است، که برای تعریف حقوق دسترسی اختیاری دقیق برای فایل‌ها و دایرکتوری‌ها استفاده می‌شود.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 6.3 مگابایت

## 8.25.1. نصب Acl

آماده‌سازی Acl برای کامپایل:

```bash
./configure --prefix=/usr         \
            --disable-static      \
            --docdir=/usr/share/doc/acl-2.3.2
```

کامپایل بسته:

```bash
make
```

آزمون‌های Acl باید روی یک سیستم فایل اجرا شوند که از کنترل‌های دسترسی پشتیبانی می‌کند، اما نه تا زمانی که بسته Coreutils با استفاده از کتابخانه‌های Acl ساخته شده باشد. در صورت تمایل، پس از ساخت بسته Coreutils به این بسته بازگردید و `make check` را اجرا کنید.

نصب بسته:

```bash
make install
```

## 8.25.2. محتویات Acl

برنامه‌های نصب شده:
chacl، getfacl و setfacl

کتابخانه نصب شده:
libacl.so

دایرکتوری‌های نصب شده:
/usr/include/acl و /usr/share/doc/acl-2.3.2

توضیحات کوتاه:

- `chacl`:

 لیست کنترل دسترسی یک فایل یا دایرکتوری را تغییر می‌دهد
- `getfacl`:

 لیست‌های کنترل دسترسی فایل را دریافت می‌کند
- `setfacl`:

 لیست‌های کنترل دسترسی فایل را تنظیم می‌کند
- `libacl`:

 شامل توابع کتابخانه برای دستکاری لیست‌های کنترل دسترسی

# 8.26. Libcap-2.70

بسته Libcap رابط فضای کاربر برای قابلیت‌های POSIX 1003.1e موجود در کرنل‌های لینوکس را پیاده‌سازی می‌کند. این قابلیت‌ها امتیاز ریشه همه‌کاره را به مجموعه‌ای از امتیازات متمایز تقسیم می‌کنند.

زمان تقریبی ساخت: کمتر از 0.1 SBU
فضای دیسک مورد نیاز: 2.9 مگابایت

## 8.26.1. نصب Libcap

جلوگیری از نصب کتابخانه‌های استاتیک:

```bash
sed -i '/install -m.*STA/d' libcap/Makefile
```

کامپایل بسته:

```bash
make prefix=/usr lib=lib
```

معنی گزینه make:

- `lib=lib`:

 این پارامتر دایرکتوری کتابخانه را به /usr/lib به جای /usr/lib64 در x86_64 تنظیم می‌کند. این گزینه روی x86 تأثیری ندارد.

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make test
```

نصب بسته:

```bash
make prefix=/usr lib=lib install
```

## 8.26.2. محتویات Libcap

برنامه‌های نصب شده:
capsh، getcap، getpcaps و setcap

کتابخانه‌های نصب شده:
libcap.so و libpsx.so

توضیحات کوتاه:

- `capsh`:

 یک پوسته برای کاوش و محدود کردن پشتیبانی از قابلیت‌ها
- `getcap`:

 قابلیت‌های فایل را بررسی می‌کند
- `با کمال میل، ادامه ترجمه را ارائه می‌دهم:

- `getpcaps`:

 قابلیت‌های فرآیند(های) مورد پرس و جو را نمایش می‌دهد
- `setcap`:

 قابلیت‌های فایل را تنظیم می‌کند
- `libcap`:

 شامل توابع کتابخانه برای دستکاری قابلیت‌های POSIX 1003.1e است
- `libpsx`:

 شامل توابعی برای پشتیبانی از معنای POSIX برای فراخوانی‌های سیستمی مرتبط با کتابخانه pthread است

# 8.27. Libxcrypt-4.4.36

بسته Libxcrypt شامل یک کتابخانه مدرن برای هش کردن یک طرفه رمزهای عبور است.

زمان تقریبی ساخت: 0.1 SBU
فضای دیسک مورد نیاز: 12 مگابایت

## 8.27.1. نصب Libxcrypt

آماده‌سازی Libxcrypt برای کامپایل:

```bash
./configure --prefix=/usr                \
            --enable-hashes=strong,glibc \
            --enable-obsolete-api=no     \
            --disable-static             \
            --disable-failure-tokens
```

معنی گزینه‌های جدید configure:

- `--enable-hashes=strong,glibc`:

 الگوریتم‌های هش قوی توصیه شده برای موارد استفاده امنیتی و الگوریتم‌های هش ارائه شده توسط libcrypt سنتی Glibc برای سازگاری را می‌سازد.
- `--enable-obsolete-api=no`:

 API منسوخ شده را غیرفعال می‌کند. این توابع برای یک سیستم لینوکس مدرن ساخته شده از منبع مورد نیاز نیستند.
- `--disable-failure-tokens`:

 ویژگی توکن شکست را غیرفعال می‌کند. این برای سازگاری با کتابخانه‌های هش سنتی برخی پلتفرم‌ها مورد نیاز است، اما یک سیستم لینوکس مبتنی بر Glibc به آن نیاز ندارد.

کامپایل بسته:

```bash
make
```

برای آزمایش نتایج، دستور زیر را صادر کنید:

```bash
make check
```

نصب بسته:

```bash
make install
```

[نکته] نکته
دستورالعمل‌های بالا توابع API منسوخ شده را غیرفعال کرد، زیرا هیچ بسته‌ای که با کامپایل از منابع نصب شده باشد در زمان اجرا به آنها پیوند نمی‌شود. با این حال، تنها برنامه‌های باینری شناخته شده که به این توابع پیوند می‌دهند نیاز به نسخه ABI 1 دارند. اگر باید چنین توابعی را به دلیل برخی برنامه‌های فقط باینری یا برای سازگاری با LSB داشته باشید، بسته را دوباره با دستورات زیر بسازید:

```bash
make distclean
./configure --prefix=/usr                \
            --enable-hashes=strong,glibc \
            --enable-obsolete-api=glibc  \
            --disable-static             \
            --disable-failure-tokens
make
cp -av --remove-destination .libs/libcrypt.so.1* /usr/lib
```

## 8.27.2. محتویات Libxcrypt

کتابخانه‌های نصب شده:
libcrypt.so

توضیحات کوتاه:

- `libcrypt`:

 شامل توابعی برای هش کردن رمزهای عبور است

# 8.28. Shadow-4.16.0

بسته Shadow شامل برنامه‌هایی برای مدیریت رمزهای عبور به روشی امن است.

زمان تقریبی ساخت: 0.1 SBU
فضای دیسک مورد نیاز: 112 مگابایت

## 8.28.1. نصب Shadow

[مهم] مهم

اگر Linux-PAM را نصب کرده‌اید، به جای این صفحه باید صفحه shadow BLFS را دنبال کنید تا shadow را بسازید (یا بازسازی یا ارتقا دهید).

[نکته] نکته

اگر می‌خواهید استفاده از رمزهای عبور قوی را اجباری کنید، برای نصب CrackLib قبل از ساخت Shadow به https://www.linuxfromscratch.org/blfs/view/12.2/postlfs/cracklib.html مراجعه کنید. سپس --with-libcrack را به دستور configure زیر اضافه کنید.

نصب برنامه groups و صفحات راهنمای آن را غیرفعال کنید، زیرا Coreutils نسخه بهتری ارائه می‌دهد. همچنین، از نصب صفحات راهنمایی که قبلاً در بخش 8.3، "Man-pages-6.9.1" نصب شده‌اند جلوگیری کنید:

```bash
sed -i 's/groups$(EXEEXT) //' src/Makefile.in
find man -name Makefile.in -exec sed -i 's/groups\.1 / /'   {} \;
find man -name Makefile.in -exec sed -i 's/getspnam\.3 / /' {} \;
find man -name Makefile.in -exec sed -i 's/passwd\.5 / /'   {} \;
```

به جای استفاده از روش رمزگذاری پیش‌فرض، از روش بسیار امن‌تر YESCRYPT برای رمزگذاری رمز عبور استفاده کنید که همچنین اجازه رمزهای عبور طولانی‌تر از 8 کاراکتر را می‌دهد. همچنین لازم است مکان منسوخ /var/spool/mail برای صندوق‌های پستی کاربر که Shadow به طور پیش‌فرض استفاده می‌کند را به مکان /var/mail که در حال حاضر استفاده می‌شود تغییر دهید. و /bin و /sbin را از PATH حذف کنید، زیرا آنها فقط پیوندهای نمادین به همتایان خود در /usr هستند.

[نکته] نکته

اگر به هر دلیلی می‌خواهید /bin و/یا /sbin را در PATH قرار دهید، پس از ساخت LFS، PATH را در .bashrc اصلاح کنید.

```bash
sed -e 's:#ENCRYPT_METHOD DES:ENCRYPT_METHOD YESCRYPT:' \
    -e 's:/var/spool/mail:/var/mail:'                   \
    -e '/PATH=/{s@/sbin:@@;s@/bin:@@}'                  \
    -i etc/login.defs
```

[نکته] نکته

اگر تصمیم گرفتید Shadow را با پشتیبانی Cracklib بسازید، این دستور را صادر کنید:

```bash
sed -i 's:DICTPATH.*:DICTPATH\t/lib/cracklib/pw_dict:' etc/login.defs
```

آماده‌سازی Shadow برای کامپایل:

```bash
touch /usr/bin/passwd
./configure --sysconfdir=/etc   \
            --disable-static    \
            --with-{b,yes}crypt \
            --without-libbsd    \
            --with-group-name-max-length=32
```

معنی گزینه‌های جدید پیکربندی:

- `touch /usr/bin/passwd`:

 فایل /usr/bin/passwd باید وجود داشته باشد زیرا مکان آن در برخی برنامه‌ها به صورت سخت‌کد شده است؛ اگر از قبل وجود نداشته باشد، اسکریپت نصب آن را در مکان اشتباه ایجاد خواهد کرد.
- `--with-{b,yes}crypt`:

 پوسته این را به دو سوئیچ، --with-bcrypt و --with-yescrypt گسترش می‌دهد. آنها به shadow اجازه می‌دهند از الگوریتم‌های Bcrypt و Yescrypt پیاده‌سازی شده توسط Libxcrypt برای هش کردن رمزهای عبور استفاده کند. این الگوریتم‌ها امن‌تر هستند (به ویژه، بسیار مقاوم‌تر در برابر حملات مبتنی بر GPU) نسبت به الگوریتم‌های سنتی SHA.
- `--with-group-name-max-length=32`:

 طولانی‌ترین نام کاربری مجاز 32 کاراکتر است. حداکثر طول نام گروه را نیز همان مقدار قرار دهید.
- `--without-libbsd`:

 از تابع readpassphrase از libbsd که در LFS نیست استفاده نکنید. به جای آن از نسخه داخلی استفاده کنید.

کامپایل بسته:

```bash
make
```

این بسته دارای مجموعه آزمون نیست.

نصب بسته:

```bash
make exec_prefix=/usr install
make -C man install-man
```

## 8.28.2. پیکربندی Shadow

این بسته شامل ابزارهایی برای اضافه کردن، اصلاح و حذف کاربران و گروه‌ها؛ تنظیم و تغییر رمزهای عبور آنها؛ و انجام سایر وظایف مدیریتی است. برای توضیح کامل اینکه سایه‌گذاری رمز عبور به چه معناست، به فایل doc/HOWTO در درخت منبع باز شده مراجعه کنید. اگر از پشتیبانی Shadow استفاده می‌کنید، به یاد داشته باشید که برنامه‌هایی که نیاز به تأیید رمزهای عبور دارند (مدیران نمایش، برنامه‌های FTP، دیمون‌های pop3 و غیره) باید با Shadow سازگار باشند. یعنی، آنها باید قادر به کار با رمزهای عبور سایه‌گذاری شده باشند.

برای فعال کردن رمزهای عبور سایه‌گذاری شده، دستور زیر را اجرا کنید:

```bash
pwconv
```

برای فعال کردن رمزهای عبور گروهی سایه‌گذاری شده، اجرا کنید:

```bash
grpconv
```

پیکربندی پیش‌فرض Shadow برای ابزار useradd نیاز به توضیح دارد. اول، اقدام پیش‌فرض برای ابزار useradd ایجاد کاربر و گروهی با همان نام کاربر است. به طور پیش‌فرض، شماره‌های شناسه کاربر (UID) و شناسه گروه (GID) از 1000 شروع می‌شوند. این بدان معناست که اگر پارامترهای اضافی به useradd ارسال نکنید، هر کاربر عضو یک گروه منحصر به فرد در سیستم خواهد بود. اگر این رفتار نامطلوب است، باید پارامتر -g یا -N را به useradd ارسال کنید، یا تنظیم USERGROUPS_ENAB را در /etc/login.defs تغییر دهید. برای اطلاعات بیشتر به useradd(8) مراجعه کنید.

دوم، برای تغییر پارامترهای پیش‌فرض، فایل /etc/default/useradd باید ایجاد شود و متناسب با نیازهای خاص شما تنظیم شود. آن را با این دستور ایجاد کنید:

```bash
mkdir -p /etc/default
useradd -D --gid 999
```

توضیحات پارامتر /etc/default/useradd:

- `GROUP=999`:

 این پارامتر شروع شماره‌های گروه استفاده شده در فایل /etc/group را تنظیم می‌کند. مقدار خاص 999 از پارامتر --gid بالا می‌آید. می‌توانید آن را به هر مقدار دلخواه تنظیم کنید. توجه داشته باشید که useradd هرگز یک UID یا GID را مجدداً استفاده نخواهد کرد. اگر عددی که در این پارامتر مشخص شده استفاده شود، از شماره بعدی موجود استفاده خواهد کرد. همچنین توجه داشته باشید که اگر گروهی با شناسه برابر با این عدد در سیستم شما وجود نداشته باشد، اولین باری که از useradd بدون پارامتر -g استفاده می‌کنید، یک پیام خطا تولید خواهد شد - useradd: unknown GID 999، حتی اگر حساب به درستی ایجاد شده باشد. به همین دلیل است که ما گروه users را با این شناسه گروه در بخش 7.6، "ایجاد فایل‌ها و پیوندهای نمادین ضروری" ایجاد کردیم.

- `CREATE_MAIL_SPOOL=yes`:

 این پارامتر باعث می‌شود useradd یک فایل صندوق پستی برای هر کاربر جدید ایجاد کند. useradd مالکیت گروهی این فایل را به گروه mail با مجوزهای 0660 اختصاص خواهد داد. اگر نمی‌خواهید این فایل‌ها را ایجاد کنید، دستور زیر را صادر کنید:

```bash
sed -i '/MAIL/s/yes/no/' /etc/default/useradd
```

## 8.28.3. تنظیم رمز عبور ریشه

یک رمز عبور برای کاربر root انتخاب کنید و آن را با اجرای این دستور تنظیم کنید:

```bash
passwd root
```

## 8.28.4. محتویات Shadow

برنامه‌های نصب شده:
chage, chfn, chgpasswd, chpasswd, chsh, expiry, faillog, getsubids, gpasswd, groupadd, groupdel, groupmems, groupmod, grpck, grpconv, grpunconv, login, logoutd, newgidmap, newgrp, newuidmap, newusers, nologin, passwd, pwck, pwconv, pwunconv, sg (پیوند به newgrp), su, useradd, userdel, usermod, vigr (پیوند به vipw), و vipw

دایرکتوری‌های نصب شده:
/etc/default و /usr/include/shadow

کتابخانه‌های نصب شده:
libsubid.so

توضیحات کوتاه:

- `chage`:

 برای تغییر حداکثر تعداد روزها بین تغییرات اجباری رمز عبور استفاده می‌شود
- `chfn`:

 برای تغییر نام کامل کاربر و سایر اطلاعات استفاده می‌شود
- `chgpasswd`:

 برای به‌روزرسانی رمزهای عبور گروه به صورت دسته‌ای استفاده می‌شود
- `chpasswd`:

 برای به‌روزرسانی رمزهای عبور کاربر به صورت دسته‌ای استفاده می‌شود
- `chsh`:

 برای تغییر پوسته ورود پیش‌فرض کاربر استفاده می‌شود
- `expiry`:

 سیاست انقضای رمز عبور فعلی را بررسی و اعمال می‌کند
- `faillog`:

 برای بررسی گزارش شکست‌های ورود، تنظیم حداکثر تعداد شکست قبل از مسدود شدن حساب و بازنشانی تعداد شکست استفاده می‌شود
- `getsubids`:

 برای لیست کردن محدوده‌های شناسه تابع برای یک کاربر استفاده می‌شود
- `gpasswd`:

 برای اضافه و حذف اعضا و مدیران به گروه‌ها استفاده می‌شود
- `groupadd`:

 یک گروه با نام داده شده ایجاد می‌کند
- `groupdel`:

 گروه با نام داده شده را حذف می‌کند
- `groupmems`:

 به کاربر اجازه می‌دهد لیست عضویت گروه خود را بدون نیاز به امتیازات ابرکاربر مدیریت کند
- `groupmod`:

 برای اصلاح نام یا GID گروه داده شده استفاده می‌شود

- `grpck`:

 یکپارچگی فایل‌های گروه /etc/group و /etc/gshadow را بررسی می‌کند
- `grpconv`:

 فایل گروه سایه را از فایل گروه عادی ایجاد یا به‌روزرسانی می‌کند
- `grpunconv`:

 /etc/group را از /etc/gshadow به‌روزرسانی می‌کند و سپس دومی را حذف می‌کند
- `login`:

 توسط سیستم برای ورود کاربران استفاده می‌شود
- `logoutd`:

 یک دیمون است که برای اعمال محدودیت‌ها در زمان ورود و پورت‌ها استفاده می‌شود
- `newgidmap`:

 برای تنظیم نگاشت gid فضای نام کاربر استفاده می‌شود
- `newgrp`:

 برای تغییر GID فعلی در طول یک جلسه ورود استفاده می‌شود
- `newuidmap`:

 برای تنظیم نگاشت uid فضای نام کاربر استفاده می‌شود
- `newusers`:

 برای ایجاد یا به‌روزرسانی یک سری کامل از حساب‌های کاربری استفاده می‌شود
- `nologin`:

 پیامی نمایش می‌دهد که می‌گوید یک حساب در دسترس نیست؛ برای استفاده به عنوان پوسته پیش‌فرض برای حساب‌های غیرفعال طراحی شده است
- `passwd`:

 برای تغییر رمز عبور یک حساب کاربری یا گروهی استفاده می‌شود
- `pwck`:

 یکپارچگی فایل‌های رمز عبور /etc/passwd و /etc/shadow را بررسی می‌کند
- `pwconv`:

 فایل رمز عبور سایه را از فایل رمز عبور عادی ایجاد یا به‌روزرسانی می‌کند
- `pwunconv`:

 /etc/passwd را از /etc/shadow به‌روزرسانی می‌کند و سپس دومی را حذف می‌کند
- `sg`:

 یک دستور داده شده را در حالی که GID کاربر به گروه داده شده تنظیم شده است اجرا می‌کند
- `su`:

 یک پوسته را با شناسه‌های کاربر و گروه جایگزین اجرا می‌کند
- `useradd`:

 یک کاربر جدید با نام داده شده ایجاد می‌کند، یا اطلاعات پیش‌فرض کاربر جدید را به‌روزرسانی می‌کند
- `userdel`:

 حساب کاربری مشخص شده را حذف می‌کند
- `usermod`:

 برای اصلاح نام ورود، شناسه کاربری (UID)، پوسته، گروه اولیه، دایرکتوری خانه و غیره کاربر داده شده استفاده می‌شود
- `vigr`:

 فایل‌های /etc/group یا /etc/gshadow را ویرایش می‌کند
- `vipw`:

 فایل‌های /etc/passwd یا /etc/shadow را ویرایش می‌کند
- `libsubid`:

 کتابخانه‌ای برای مدیریت محدوده‌های شناسه تابع برای کاربران و گروه‌ها

