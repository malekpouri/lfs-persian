## فصل ۲. آماده‌سازی سیستم میزبان

### ۲.۱. مقدمه

در این فصل، ابزارهای میزبان مورد نیاز برای ساخت LFS بررسی شده و در صورت لزوم نصب می‌شوند. سپس پارتیشنی که سیستم LFS را میزبانی خواهد کرد، آماده می‌شود. ما پارتیشن را ایجاد کرده، یک سیستم فایل روی آن ایجاد می‌کنیم و آن را نصب می‌کنیم.

### ۲.۲. الزامات سیستم میزبان

#### ۲.۲.۱. سخت‌افزار

ویراستاران LFS توصیه می‌کنند که CPU سیستم حداقل چهار هسته داشته باشد و سیستم حداقل ۸ گیگابایت حافظه داشته باشد. سیستم‌های قدیمی‌تر که این الزامات را برآورده نمی‌کنند همچنان کار خواهند کرد، اما زمان ساخت بسته‌ها به طور قابل توجهی طولانی‌تر از آنچه مستند شده خواهد بود.

#### ۲.۲.۲. نرم‌افزار

سیستم میزبان شما باید نرم‌افزارهای زیر را با حداقل نسخه‌های ذکر شده داشته باشد. این نباید برای اکثر توزیع‌های مدرن لینوکس مشکلی ایجاد کند. همچنین توجه داشته باشید که بسیاری از توزیع‌ها هدرهای نرم‌افزاری را در بسته‌های جداگانه قرار می‌دهند، اغلب به شکل `<package-name>-devel` یا `<package-name>-dev`. اطمینان حاصل کنید که اگر توزیع شما آنها را ارائه می‌دهد، آنها را نصب کنید.

نسخه‌های قدیمی‌تر بسته‌های نرم‌افزاری ذکر شده ممکن است کار کنند، اما آزمایش نشده‌اند.

- Bash-3.2 (`/bin/sh` باید یک لینک نمادین یا سخت به bash باشد)
- Binutils-2.13.1 (نسخه‌های بالاتر از 2.43.1 توصیه نمی‌شوند زیرا آزمایش نشده‌اند)
- Bison-2.7 (`/usr/bin/yacc` باید لینکی به bison یا یک اسکریپت کوچک باشد که bison را اجرا می‌کند)
- Coreutils-8.1
- Diffutils-2.8.1
- Findutils-4.2.31
- Gawk-4.0.1 (`/usr/bin/awk` باید لینکی به gawk باشد)
- GCC-5.2 شامل کامپایلر ++C، ++g (نسخه‌های بالاتر از 14.2.0 توصیه نمی‌شوند زیرا آزمایش نشده‌اند). کتابخانه‌های استاندارد C و ++C (با هدرها) نیز باید موجود باشند تا کامپایلر ++C بتواند برنامه‌های میزبانی شده را بسازد
- Grep-2.5.1a
- Gzip-1.3.12
- Linux Kernel-4.19

دلیل نیاز به نسخه هسته این است که ما آن نسخه را هنگام ساخت glibc در فصل ۵ و فصل ۸ مشخص می‌کنیم، بنابراین راه‌حل‌های موقت برای هسته‌های قدیمی‌تر فعال نمی‌شوند و glibc کامپایل شده کمی سریع‌تر و کوچک‌تر است. از فوریه ۲۰۲۴، ۴.۱۹ قدیمی‌ترین نسخه هسته است که هنوز توسط توسعه‌دهندگان هسته پشتیبانی می‌شود. برخی نسخه‌های هسته قدیمی‌تر از ۴.۱۹ ممکن است هنوز توسط تیم‌های شخص ثالث پشتیبانی شوند، اما آنها به عنوان نسخه‌های رسمی هسته بالادستی در نظر گرفته نمی‌شوند؛ برای جزئیات https://kernel.org/category/releases.html را بخوانید.

اگر هسته میزبان قبل از ۴.۱۹ است، باید هسته را با یک نسخه به‌روزتر جایگزین کنید. دو راه برای انجام این کار وجود دارد. اول، ببینید آیا فروشنده لینوکس شما بسته هسته ۴.۱۹ یا بالاتر را ارائه می‌دهد. اگر چنین است، ممکن است بخواهید آن را نصب کنید. اگر فروشنده شما بسته هسته قابل قبولی ارائه نمی‌دهد، یا ترجیح می‌دهید آن را نصب نکنید، می‌توانید خودتان یک هسته کامپایل کنید. دستورالعمل‌های کامپایل هسته و پیکربندی بوت لودر (با فرض اینکه میزبان از GRUB استفاده می‌کند) در فصل ۱۰ قرار دارد.
ما نیاز داریم که هسته میزبان از ترمینال مجازی UNIX 98 (PTY) پشتیبانی کند. این باید در تمام توزیع‌های دسکتاپ یا سرور که لینوکس 4.19 یا هسته جدیدتر را ارائه می‌دهند، فعال باشد. اگر در حال ساخت یک هسته میزبان سفارشی هستید، اطمینان حاصل کنید که `CONFIG_UNIX98_PTYS` در پیکربندی هسته روی `y` تنظیم شده است.

- M4-1.4.10
- Make-4.0
- Patch-2.5.4
- Perl-5.8.8
- Python-3.4
- Sed-4.1.5
- Tar-1.22
- Texinfo-5.0
- Xz-5.0.0

**مهم**

توجه داشته باشید که لینک‌های نمادین ذکر شده در بالا برای ساخت یک سیستم LFS با استفاده از دستورالعمل‌های موجود در این کتاب ضروری هستند. لینک‌های نمادین که به نرم‌افزارهای دیگر اشاره می‌کنند (مانند dash، mawk و غیره) ممکن است کار کنند، اما توسط تیم توسعه LFS آزمایش یا پشتیبانی نشده‌اند و ممکن است نیاز به انحراف از دستورالعمل‌ها یا وصله‌های اضافی برای برخی بسته‌ها داشته باشند.

برای بررسی اینکه آیا سیستم میزبان شما تمام نسخه‌های مناسب و توانایی کامپایل برنامه‌ها را دارد، دستورات زیر را اجرا کنید:
```bash
cat > version-check.sh << "EOF"
#!/bin/bash
# A script to list version numbers of critical development tools
# If you have tools installed in other directories, adjust PATH here AND
# in ~lfs/.bashrc (section 4.4) as well.
LC_ALL=C
PATH=/usr/bin:/bin
bail() { echo "FATAL: $1"; exit 1; }
grep --version > /dev/null 2> /dev/null || bail "grep does not work"
sed '' /dev/null || bail "sed does not work"
sort /dev/null || bail "sort does not work"
ver_check()
{
if ! type -p $2 &>/dev/null
then
echo "ERROR: Cannot find $2 ($1)"; return 1;
fi
v=$($2 --version 2>&1 | grep -E -o '[0-9]+\.[0-9\.]+[a-z]*' | head -n1)
if printf '%s\n' $3 $v | sort --version-sort --check &>/dev/null
then
printf "OK: %-9s %-6s >= $3\n" "$1" "$v"; return 0;
else
printf "ERROR: %-9s is TOO OLD ($3 or later required)\n" "$1";
return 1;
fi
}
ver_kernel()
{
kver=$(uname -r | grep -E -o '^[0-9\.]+')
if printf '%s\n' $1 $kver | sort --version-sort --check &>/dev/null
then
printf "OK: Linux Kernel $kver >= $1\n"; return 0;
else
printf "ERROR: Linux Kernel ($kver) is TOO OLD ($1 or later required)\n" "$kver";
return 1;
fi
}
# Coreutils first because --version-sort needs Coreutils >= 7.0
ver_check Coreutils sort 8.1 || bail "Coreutils too old, stop"
ver_check Bash bash 3.2
ver_check Binutils ld 2.13.1
ver_check Bison bison 2.7
ver_check Diffutils diff 2.8.1
ver_check Findutils find 4.2.31
ver_check Gawk gawk 4.0.1
ver_check GCC gcc 5.2
ver_check "GCC (C++)" g++ 5.2
ver_check Grep grep 2.5.1a
ver_check Gzip gzip 1.3.12
ver_check M4 m4 1.4.10
ver_check Make make 4.0
ver_check Patch patch 2.5.4
ver_check Perl perl 5.8.8
ver_check Python python3 3.4
ver_check Sed sed 4.1.5
ver_check Tar tar 1.22
ver_check Texinfo texi2any 5.0
ver_check Xz xz 5.0.0
ver_kernel 4.19
if mount | grep -q 'devpts on /dev/pts' && [ -e /dev/ptmx ]
then echo "OK: Linux Kernel supports UNIX 98 PTY";
else echo "ERROR: Linux Kernel does NOT support UNIX 98 PTY"; fi
alias_check() {
if $1 --version 2>&1 | grep -qi $2
then printf "OK: %-4s is $2\n" "$1";
else printf "ERROR: %-4s is NOT $2\n" "$1"; fi
}
echo "Aliases:"
alias_check awk GNU
alias_check yacc Bison
alias_check sh Bash
echo "Compiler check:"
if printf "int main(){}" | g++ -x c++ -
then echo "OK: g++ works";
else echo "ERROR: g++ does NOT work"; fi
rm -f a.out
if [ "$(nproc)" = "" ]; then
echo "ERROR: nproc is not available or it produces empty output"
else
echo "OK: nproc reports $(nproc) logical cores are available"
fi
EOF
bash version-check.sh
```
### ۲.۳. ساخت LFS در مراحل

LFS طراحی شده است تا در یک جلسه ساخته شود. یعنی، دستورالعمل‌ها فرض می‌کنند که سیستم در طول فرآیند خاموش نخواهد شد. این به این معنا نیست که سیستم باید در یک نشست ساخته شود. مسئله این است که برخی از روش‌ها باید پس از راه‌اندازی مجدد هنگام از سرگیری LFS در نقاط مختلف تکرار شوند.

#### ۲.۳.۱. فصل‌های ۱–۴

این فصل‌ها دستورات را روی سیستم میزبان اجرا می‌کنند. هنگام راه‌اندازی مجدد، از یک چیز مطمئن باشید:

- روش‌هایی که به عنوان کاربر ریشه پس از بخش ۲.۴ انجام می‌شوند باید متغیر محیطی LFS را برای کاربر ریشه تنظیم کنند.

#### ۲.۳.۲. فصل‌های ۵–۶

- پارتیشن `/mnt/lfs` باید نصب شده باشد.
- این دو فصل باید به عنوان کاربر lfs انجام شوند. قبل از انجام هر کاری در این فصل‌ها باید دستور `su - lfs` صادر شود. اگر این کار را انجام ندهید، در معرض خطر نصب بسته‌ها در میزبان و احتمالاً غیرقابل استفاده کردن آن هستید.
- روش‌های موجود در دستورالعمل‌های کامپایل عمومی بسیار مهم هستند. اگر شکی وجود دارد که یک بسته به درستی نصب شده است، اطمینان حاصل کنید که تارباِل قبلاً استخراج شده حذف شده است، سپس بسته را مجدداً استخراج کنید و تمام دستورالعمل‌های آن بخش را کامل کنید.

#### ۲.۳.۳. فصل‌های ۷–۱۰

- پارتیشن `/mnt/lfs` باید نصب شده باشد.
- چند عملیات، از "تغییر مالکیت" تا "ورود به محیط Chroot،" باید به عنوان کاربر ریشه انجام شوند، با متغیر محیطی LFS تنظیم شده برای کاربر ریشه.
- هنگام ورود به chroot، متغیر محیطی LFS باید برای ریشه تنظیم شود. متغیر LFS پس از ورود به محیط chroot استفاده نمی‌شود.
- سیستم‌های فایل مجازی باید نصب شوند. این کار می‌تواند قبل یا بعد از ورود به chroot با تغییر به یک ترمینال مجازی میزبان و، به عنوان ریشه، اجرای دستورات در بخش ۷.۳.۱، "نصب و پر کردن /dev" و بخش ۷.۳.۲، "نصب سیستم‌های فایل هسته مجازی" انجام شود.

### ۲.۴. ایجاد یک پارتیشن جدید

مانند اکثر سیستم‌عامل‌های دیگر، LFS معمولاً روی یک پارتیشن اختصاصی نصب می‌شود. رویکرد توصیه شده برای ساخت یک سیستم LFS استفاده از یک پارتیشن خالی موجود یا، اگر فضای پارتیشن‌بندی نشده کافی دارید، ایجاد یکی است.

یک سیستم حداقلی نیاز به پارتیشنی حدود ۱۰ گیگابایت (GB) دارد. این برای ذخیره تمام تاربال‌های منبع و کامپایل بسته‌ها کافی است. با این حال، اگر سیستم LFS قرار است سیستم لینوکس اصلی باشد، احتمالاً نرم‌افزارهای اضافی نصب خواهند شد که به فضای بیشتری نیاز دارند. یک پارتیشن ۳۰ گیگابایتی اندازه معقولی برای رشد است. خود سیستم LFS این همه فضا را اشغال نخواهد کرد. بخش بزرگی از این نیاز برای فراهم کردن فضای ذخیره‌سازی موقت کافی و همچنین برای افزودن قابلیت‌های اضافی پس از تکمیل LFS است. علاوه بر این، کامپایل بسته‌ها می‌تواند به فضای زیادی روی دیسک نیاز داشته باشد که پس از نصب بسته بازیابی می‌شود.

از آنجا که همیشه حافظه دسترسی تصادفی (RAM) کافی برای فرآیندهای کامپایل در دسترس نیست، ایده خوبی است که از یک پارتیشن کوچک دیسک به عنوان فضای تبادل (swap) استفاده کنید. این توسط هسته برای ذخیره داده‌هایی که به ندرت استفاده می‌شوند استفاده می‌شود و حافظه بیشتری را برای فرآیندهای فعال در دسترس قرار می‌دهد. پارتیشن تبادل برای یک سیستم LFS می‌تواند همان پارتیشنی باشد که توسط سیستم میزبان استفاده می‌شود، در این صورت نیازی به ایجاد یکی دیگر نیست.

یک برنامه پارتیشن‌بندی دیسک مانند cfdisk یا fdisk را با گزینه خط فرمان نام‌گذاری دیسک سختی که پارتیشن جدید روی آن ایجاد خواهد شد شروع کنید — به عنوان مثال `/dev/sda` برای درایو دیسک اصلی. یک پارتیشن بومی لینوکس و یک پارتیشن تبادل، در صورت نیاز، ایجاد کنید. لطفاً اگر هنوز نمی‌دانید چگونه از برنامه‌ها استفاده کنید، به cfdisk(8) یا fdisk(8) مراجعه کنید.

**نکته**
برای کاربران با تجربه، طرح‌های پارتیشن‌بندی دیگری امکان‌پذیر است. سیستم جدید LFS می‌تواند روی یک آرایه RAID نرم‌افزاری یا یک حجم منطقی LVM باشد. با این حال، برخی از این گزینه‌ها نیاز به یک initramfs دارند، که یک موضوع پیشرفته است. این روش‌های پارتیشن‌بندی برای کاربران تازه کار LFS توصیه نمی‌شود.

نام‌گذاری پارتیشن جدید را به خاطر بسپارید (مثلاً، sda5). این کتاب به این به عنوان پارتیشن LFS اشاره خواهد کرد. همچنین نام‌گذاری پارتیشن تبادل را به خاطر بسپارید. این نام‌ها بعداً برای فایل /etc/fstab مورد نیاز خواهند بود.

#### ۲.۴.۱. سایر مسائل پارتیشن‌بندی

درخواست‌های مشاوره در مورد پارتیشن‌بندی سیستم اغلب در لیست‌های پستی LFS ارسال می‌شود. این یک موضوع بسیار ذهنی است. پیش‌فرض برای اکثر توزیع‌ها استفاده از کل درایو با استثنای یک پارتیشن تبادل کوچک است. این برای LFS به چند دلیل بهینه نیست. انعطاف‌پذیری را کاهش می‌دهد، اشتراک‌گذاری داده‌ها در چندین توزیع یا ساخت‌های LFS را دشوارتر می‌کند، تهیه نسخه پشتیبان را زمان‌برتر می‌کند و می‌تواند فضای دیسک را از طریق تخصیص ناکارآمد ساختارهای سیستم فایل هدر دهد.

##### ۲.۴.۱.۱. پارتیشن ریشه

یک پارتیشن ریشه LFS (که نباید با دایرکتوری /root اشتباه گرفته شود) بیست گیگابایتی یک سازش خوب برای اکثر سیستم‌هاست. فضای کافی برای ساخت LFS و بیشتر BLFS را فراهم می‌کند، اما به اندازه کافی کوچک است که چندین پارتیشن را می‌توان به راحتی برای آزمایش ایجاد کرد.

##### ۲.۴.۱.۲. پارتیشن تبادل

اکثر توزیع‌ها به طور خودکار یک پارتیشن تبادل ایجاد می‌کنند. به طور کلی اندازه توصیه شده پارتیشن تبادل حدود دو برابر مقدار RAM فیزیکی است، اما این به ندرت مورد نیاز است. اگر فضای دیسک محدود است، پارتیشن تبادل را در دو گیگابایت نگه دارید و مقدار تبادل دیسک را نظارت کنید.

اگر می‌خواهید از ویژگی هایبرنیشن (تعلیق به دیسک) لینوکس استفاده کنید، محتویات RAM را قبل از خاموش کردن دستگاه به پارتیشن تبادل می‌نویسد. در این صورت اندازه پارتیشن تبادل باید حداقل به اندازه RAM نصب شده سیستم باشد.

تبادل هرگز خوب نیست. برای دیسک‌های سخت مکانیکی معمولاً می‌توانید با گوش دادن به فعالیت دیسک و مشاهده نحوه واکنش سیستم به دستورات تشخیص دهید که آیا سیستم در حال تبادل است یا خیر. با یک SSD نمی‌توانید تبادل را بشنوید، اما می‌توانید با اجرای برنامه‌های top یا free متوجه شوید که چقدر فضای تبادل استفاده می‌شود. استفاده از یک SSD برای پارتیشن تبادل باید در صورت امکان اجتناب شود. اولین واکنش به تبادل باید بررسی یک دستور نامعقول مانند تلاش برای ویرایش یک فایل پنج گیگابایتی باشد. اگر تبادل به یک رخداد عادی تبدیل شود، بهترین راه حل خرید RAM بیشتر برای سیستم شماست.

##### ۲.۴.۱.۳. پارتیشن Grub Bios

اگر دیسک بوت با یک جدول پارتیشن GUID (GPT) پارتیشن‌بندی شده باشد، یک پارتیشن کوچک، معمولاً ۱ مگابایت، باید ایجاد شود اگر از قبل وجود نداشته باشد. این پارتیشن فرمت نشده است، اما باید در دسترس GRUB برای استفاده در طول نصب بوت لودر باشد. این پارتیشن معمولاً با استفاده از fdisk 'BIOS Boot' نامگذاری می‌شود یا اگر از دستور gdisk استفاده می‌کنید، کد EF02 دارد.

**نکته**
پارتیشن Grub Bios باید روی درایوی باشد که BIOS برای بوت کردن سیستم استفاده می‌کند. این لزوماً درایوی نیست که پارتیشن ریشه LFS را نگه می‌دارد. دیسک‌های یک سیستم ممکن است از انواع مختلف جدول پارتیشن استفاده کنند. ضرورت پارتیشن Grub Bios فقط به نوع جدول پارتیشن دیسک بوت بستگی

# 2.4.1.4. پارتیشن‌های مناسب

چندین پارتیشن دیگر وجود دارند که اگرچه ضروری نیستند، اما باید هنگام طراحی چیدمان دیسک در نظر گرفته شوند. لیست زیر جامع نیست، اما به عنوان یک راهنما در نظر گرفته شده است:

- **/boot** - بسیار توصیه می‌شود. از این پارتیشن برای ذخیره کرنل‌ها و سایر اطلاعات بوت استفاده کنید. برای به حداقل رساندن مشکلات احتمالی بوت با دیسک‌های بزرگتر، این را اولین پارتیشن فیزیکی روی اولین درایو دیسک خود قرار دهید. اندازه پارتیشن 200 مگابایت کافی است.

- **/boot/efi** - پارتیشن سیستم EFI، که برای بوت کردن سیستم با UEFI مورد نیاز است. برای جزئیات صفحه BLFS را بخوانید.

- **/home** - بسیار توصیه می‌شود. دایرکتوری خانه و تنظیمات شخصی کاربر خود را در چندین توزیع یا نسخه LFS به اشتراک بگذارید. اندازه آن معمولاً نسبتاً بزرگ است و به فضای دیسک در دسترس بستگی دارد.

- **/usr** - در LFS، /bin، /lib و /sbin لینک‌های نمادین به همتایان خود در /usr هستند. بنابراین /usr حاوی تمام باینری‌های مورد نیاز برای اجرای سیستم است. برای LFS معمولاً نیازی به پارتیشن جداگانه برای /usr نیست. اگر به هر حال آن را ایجاد می‌کنید، باید پارتیشنی به اندازه کافی بزرگ ایجاد کنید تا همه برنامه‌ها و کتابخانه‌های سیستم را در خود جای دهد. پارتیشن ریشه می‌تواند در این پیکربندی بسیار کوچک باشد (شاید فقط یک گیگابایت)، بنابراین برای یک کلاینت نازک یا ایستگاه کاری بدون دیسک (جایی که /usr از یک سرور راه دور نصب می‌شود) مناسب است. با این حال، باید توجه داشته باشید که یک initramfs (که توسط LFS پوشش داده نشده است) برای بوت کردن سیستم با پارتیشن /usr جداگانه مورد نیاز خواهد بود.

- **/opt** - این دایرکتوری برای BLFS بسیار مفید است، جایی که بسته‌های بزرگ متعددی مانند KDE یا Texlive را می‌توان بدون جاسازی فایل‌ها در سلسله مراتب /usr نصب کرد. در صورت استفاده، 5 تا 10 گیگابایت معمولاً کافی است.

- **/tmp** - پارتیشن جداگانه /tmp نادر است، اما هنگام پیکربندی یک کلاینت نازک مفید است. این پارتیشن، در صورت استفاده، معمولاً نیازی به بیش از چند گیگابایت ندارد. اگر RAM کافی دارید، می‌توانید یک tmpfs را روی /tmp نصب کنید تا دسترسی به فایل‌های موقت سریع‌تر شود.

- **/usr/src** - این پارتیشن برای فراهم کردن مکانی برای ذخیره فایل‌های منبع BLFS و به اشتراک گذاری آنها در نسخه‌های LFS بسیار مفید است. همچنین می‌تواند به عنوان مکانی برای ساخت بسته‌های BLFS استفاده شود. یک پارتیشن نسبتاً بزرگ 30-50 گیگابایتی فضای کافی را فراهم می‌کند.

هر پارتیشن جداگانه‌ای که می‌خواهید هنگام شروع سیستم به طور خودکار نصب شود، باید در فایل /etc/fstab مشخص شود. جزئیات مربوط به نحوه مشخص کردن پارتیشن‌ها در بخش 10.2، "ایجاد فایل /etc/fstab" مورد بحث قرار خواهد گرفت.

# 2.5. ایجاد یک سیستم فایل روی پارتیشن

یک پارتیشن فقط محدوده‌ای از سکتورها روی یک درایو دیسک است که توسط مرزهای تعیین شده در یک جدول پارتیشن محدود شده است. قبل از اینکه سیستم عامل بتواند از یک پارتیشن برای ذخیره هر فایلی استفاده کند، پارتیشن باید فرمت شود تا حاوی یک سیستم فایل باشد که معمولاً شامل یک برچسب، بلوک‌های دایرکتوری، بلوک‌های داده و یک طرح ایندکس‌گذاری برای پیدا کردن یک فایل خاص در صورت نیاز است. سیستم فایل همچنین به سیستم عامل کمک می‌کند تا فضای آزاد روی پارتیشن را پیگیری کند، سکتورهای مورد نیاز را هنگام ایجاد یک فایل جدید یا گسترش یک فایل موجود رزرو کند و قطعات داده آزاد ایجاد شده هنگام حذف فایل‌ها را بازیافت کند. همچنین ممکن است از افزونگی داده‌ها و بازیابی خطا پشتیبانی کند.

LFS می‌تواند از هر سیستم فایلی که توسط کرنل لینوکس شناخته می‌شود استفاده کند، اما رایج‌ترین انواع ext3 و ext4 هستند. انتخاب سیستم فایل مناسب می‌تواند پیچیده باشد؛ به ویژگی‌های فایل‌ها و اندازه پارتیشن بستگی دارد. به عنوان مثال:

- **ext2** برای پارتیشن‌های کوچکی که به ندرت به‌روزرسانی می‌شوند مانند /boot مناسب است.

- **ext3** یک ارتقا برای ext2 است که شامل یک ژورنال برای کمک به بازیابی وضعیت پارتیشن در صورت خاموش شدن ناگهانی است. معمولاً به عنوان یک سیستم فایل همه منظوره استفاده می‌شود.

- **ext4** جدیدترین نسخه از خانواده سیستم فایل ext است. چندین قابلیت جدید از جمله تایم استمپ‌های نانوثانیه، ایجاد و استفاده از فایل‌های بسیار بزرگ (تا 16 ترابایت) و بهبودهای سرعت را فراهم می‌کند.

سایر سیستم‌های فایل، از جمله FAT32، NTFS، JFS و XFS برای اهداف خاص مفید هستند. اطلاعات بیشتر در مورد این سیستم‌های فایل و بسیاری دیگر را می‌توان در https://en.wikipedia.org/wiki/Comparison_of_file_systems یافت.

LFS فرض می‌کند که سیستم فایل ریشه (/) از نوع ext4 است. برای ایجاد یک سیستم فایل ext4 روی پارتیشن LFS، دستور زیر را صادر کنید:

```
mkfs -v -t ext4 /dev/<xxx>
```

<xxx> را با نام پارتیشن LFS جایگزین کنید.

اگر از یک پارتیشن swap موجود استفاده می‌کنید، نیازی به فرمت کردن آن نیست. اگر یک پارتیشن swap جدید ایجاد شده است، باید با این دستور مقداردهی اولیه شود:

```
mkswap /dev/<yyy>
```

<yyy> را با نام پارتیشن swap جایگزین کنید.

# 2.6. تنظیم متغیر $LFS

در طول این کتاب، متغیر محیطی LFS چندین بار استفاده خواهد شد. باید اطمینان حاصل کنید که این متغیر همیشه در طول فرآیند ساخت LFS تعریف شده است. باید به نام دایرکتوری که در آن سیستم LFS خود را خواهید ساخت تنظیم شود - ما از /mnt/lfs به عنوان مثال استفاده خواهیم کرد، اما می‌توانید هر نام دایرکتوری که می‌خواهید انتخاب کنید. اگر LFS را روی یک پارتیشن جداگانه می‌سازید، این دایرکتوری نقطه نصب برای پارتیشن خواهد بود. یک مکان دایرکتوری را انتخاب کنید و متغیر را با دستور زیر تنظیم کنید:

```
export LFS=/mnt/lfs
```

داشتن این متغیر مفید است زیرا دستوراتی مانند mkdir -v $LFS/tools را می‌توان به صورت لفظی تایپ کرد. شل به طور خودکار "$LFS" را با "/mnt/lfs" (یا هر مقداری که متغیر به آن تنظیم شده است) هنگام پردازش خط فرمان جایگزین می‌کند.

**احتیاط**

فراموش نکنید که هر بار که از محیط کاری فعلی خارج و دوباره وارد می‌شوید (مانند زمانی که su به root یا کاربر دیگری انجام می‌دهید) بررسی کنید که LFS تنظیم شده است. بررسی کنید که متغیر LFS به درستی تنظیم شده است با:

```
echo $LFS
```

مطمئن شوید که خروجی مسیر محل ساخت سیستم LFS شما را نشان می‌دهد، که اگر مثال ارائه شده دنبال شده باشد /mnt/lfs است. اگر خروجی نادرست است، از دستور داده شده در صفحه قبل برای تنظیم $LFS به نام دایرکتوری صحیح استفاده کنید.

**نکته**

یک راه برای اطمینان از اینکه متغیر LFS همیشه تنظیم شده است، ویرایش فایل .bash_profile هم در دایرکتوری خانه شخصی شما و هم در /root/.bash_profile و وارد کردن دستور export بالا است. علاوه بر این، شل مشخص شده در فایل /etc/passwd برای تمام کاربرانی که به متغیر LFS نیاز دارند باید bash باشد تا اطمینان حاصل شود که فایل /root/.bash_profile به عنوان بخشی از فرآیند ورود به سیستم گنجانده شده است.

ملاحظه دیگر روشی است که برای ورود به سیستم میزبان استفاده می‌شود. اگر از طریق یک مدیر نمایش گرافیکی وارد می‌شوید، .bash_profile کاربر معمولاً هنگام شروع یک ترمینال مجازی استفاده نمی‌شود. در این حالت، دستور export را به فایل .bashrc برای کاربر و root اضافه کنید. علاوه بر این، برخی از توزیع‌ها از یک تست "if" استفاده می‌کنند و دستورات .bashrc باقیمانده را برای یک فراخوانی غیر تعاملی bash اجرا نمی‌کنند. مطمئن شوید که دستور export را قبل از تست برای استفاده غیر تعاملی قرار دهید.

# 2.7. نصب پارتیشن جدید

اکنون که یک سیستم فایل ایجاد شده است، پارتیشن باید نصب شود تا سیستم میزبان بتواند به آن دسترسی پیدا کند. این کتاب فرض می‌کند که سیستم فایل در دایرکتوری مشخص شده توسط متغیر محیطی LFS که در بخش قبلی توضی

۲.۷. نصب پارتیشن جدید

حال که یک سیستم فایل ایجاد شده است، پارتیشن باید نصب شود تا سیستم میزبان بتواند به آن دسترسی پیدا کند. این کتاب فرض می‌کند که سیستم فایل در دایرکتوری مشخص شده توسط متغیر محیطی LFS که در بخش قبلی توضیح داده شد، نصب می‌شود.

دقیقاً نمی‌توان گفت که "یک پارتیشن را نصب می‌کنیم". ما سیستم فایلی را که درون آن پارتیشن جاسازی شده است نصب می‌کنیم. اما از آنجایی که یک پارتیشن نمی‌تواند بیش از یک سیستم فایل داشته باشد، افراد اغلب از پارتیشن و سیستم فایل مرتبط با آن به گونه‌ای صحبت می‌کنند که انگار یکی هستند.

نقطه نصب را ایجاد کنید و سیستم فایل LFS را با این دستورات نصب کنید:

```md
mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
```

`<xxx>` را با نام پارتیشن LFS جایگزین کنید.

اگر از چندین پارتیشن برای LFS استفاده می‌کنید (مثلاً یکی برای / و دیگری برای /home)، آنها را به این صورت نصب کنید:

```md
mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
mkdir -v $LFS/home
mount -v -t ext4 /dev/<yyy> $LFS/home
```

`<xxx>` و `<yyy>` را با نام‌های مناسب پارتیشن‌ها جایگزین کنید.

اطمینان حاصل کنید که این پارتیشن جدید با مجوزهای بیش از حد محدودکننده (مانند گزینه‌های nosuid یا nodev) نصب نشده باشد. دستور mount را بدون هیچ پارامتری اجرا کنید تا ببینید چه گزینه‌هایی برای پارتیشن LFS نصب شده تنظیم شده است. اگر nosuid و/یا nodev تنظیم شده باشند، پارتیشن باید مجدداً نصب شود.

**هشدار**

دستورالعمل‌های فوق فرض می‌کنند که شما در طول فرآیند LFS کامپیوتر خود را راه‌اندازی مجدد نخواهید کرد. اگر سیستم خود را خاموش کنید، یا باید پارتیشن LFS را هر بار که فرآیند ساخت را از سر می‌گیرید مجدداً نصب کنید، یا فایل /etc/fstab سیستم میزبان را اصلاح کنید تا هنگام راه‌اندازی مجدد، به طور خودکار آن را نصب کند. به عنوان مثال، ممکن است این خط را به فایل /etc/fstab خود اضافه کنید:

```md
/dev/<xxx> /mnt/lfs ext4 defaults 1 1
```

اگر از پارتیشن‌های اختیاری اضافی استفاده می‌کنید، حتماً آنها را نیز اضافه کنید.

اگر از یک پارتیشن swap استفاده می‌کنید، اطمینان حاصل کنید که با استفاده از دستور swapon فعال شده است:

```md
/sbin/swapon -v /dev/<zzz>
```

`<zzz>` را با نام پارتیشن swap جایگزین کنید.

حال که پارتیشن جدید LFS آماده استفاده است، وقت آن رسیده که بسته‌ها را دانلود کنیم.