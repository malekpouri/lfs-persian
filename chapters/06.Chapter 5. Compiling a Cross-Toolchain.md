# فصل ۵. ساخت یک ابزارزنجیره متقاطع

## ۵.۱. مقدمه
این فصل نشان می‌دهد چگونه می‌توان یک کامپایلر متقاطع و ابزارهای مرتبط با آن را بسازید. اگرچه اینجا کامپایل متقاطع ساختگی است، اصول آن مانند یک ابزارزنجیره متقاطع واقعی است.
برنامه‌های کامپایل‌شده در این فصل در زیر‌دایرکتوری $LFS/tools نصب می‌شوند تا از فایل‌های نصب‌شده در فصول بعدی جدا بمانند. از طرف دیگر، کتابخانه‌ها در محل نهایی خود نصب می‌شوند، زیرا به سیستمی که می‌خواهیم بسازیم مربوط هستند.

### ۵.۲. Binutils-2.43.1 - گذر اول
بسته Binutils شامل یک لینکر، مونتاژگر و سایر ابزارهای مربوط به فایل‌های شیء است.
زمان تقریبی ساخت: ۱ SBU
فضای دیسک مورد نیاز: ۶۷۷ مگابایت

### ۵.۲.۱. نصب Binutils متقاطع
یادداشت
برگردید و یادداشت‌های بخش با عنوان دستورالعمل‌های کلی کامپایل را دوباره بخوانید. درک یادداشت‌های برچسب‌گذاری‌شده با عنوان مهم می‌تواند مشکلات زیادی را در آینده حل کند.

مهم است که Binutils اولین بسته‌ای باشد که کامپایل می‌شود، زیرا Glibc و GCC آزمایش‌های مختلفی روی لینکر و مونتاژگر موجود انجام می‌دهند تا تعیین کنند که ویژگی‌های خود را چگونه فعال کنند.
مستندات Binutils توصیه می‌کنند که Binutils در یک دایرکتوری ساخت اختصاصی ساخته شود:

```bash
mkdir -v build
cd build
```

یادداشت
به منظور اینکه مقادیر SBU لیست‌شده در بقیه کتاب مفید باشند، زمان ساخت این بسته از پیکربندی، تا و شامل اولین نصب را اندازه‌گیری کنید. برای انجام این کار به راحتی، دستورات را در یک دستور زمان مانند این قرار دهید:

```bash
time { ../configure ... && make && make install; }
```

حال Binutils را برای کامپایل آماده کنید:

```bash
../configure --prefix=$LFS/tools \
--with-sysroot=$LFS \
--target=$LFS_TGT \
--disable-nls \
--enable-gprofng=no \
--disable-werror \
--enable-new-dtags \
--enable-default-hash-style=gnu
```

معنی گزینه‌های پیکربندی:

`--prefix=$LFS/tools`

این به اسکریپت پیکربندی می‌گوید که برنامه‌های Binutils را در دایرکتوری $LFS/tools نصب کند.

`--with-sysroot=$LFS`

برای کامپایل متقاطع، این به سیستم ساخت می‌گوید که برای کتابخانه‌های سیستم هدف به $LFS مراجعه کند.

`--target=$LFS_TGT`

به دلیل اینکه توصیف ماشین در متغیر LFS_TGT کمی با مقداری که توسط اسکریپت config.guess برگردانده می‌شود، متفاوت است، این گزینه به اسکریپت پیکربندی می‌گوید که سیستم ساخت Binutils را برای ساخت یک لینکر متقاطع تنظیم کند.

`--disable-nls`

این بین‌المللی‌سازی را غیرفعال می‌کند، زیرا i18n برای ابزارهای موقت مورد نیاز نیست.

`--enable-gprofng=no`

این ساخت gprofng را که برای ابزارهای موقت مورد نیاز نیست، غیرفعال می‌کند.

`--disable-werror`

این باعث می‌شود که ساخت در صورت وجود هشدارها از کامپایلر میزبان متوقف نشود.

`--enable-new-dtags`

این باعث می‌شود که لینکر از تگ "runpath" برای جاسازی مسیرهای جستجوی کتابخانه در اجراکننده‌های پویا و کتابخانه‌های اشتراکی استفاده کند، به جای تگ سنتی "rpath". این باعث آسان‌تر شدن اشکال‌زدایی اجراکننده‌های پویا پیوندی‌شده می‌شود و مشکلات بالقوه در مجموعه آزمون برخی بسته‌ها را برطرف می‌کند.

`--enable-default-hash-style=gnu`

به طور پیش‌فرض، لینکر هم جدول هش سبک گنو و هم جدول هش کلاسیک ELF را برای کتابخانه‌های اشتراکی و اجراکننده‌های پویا پیوندی‌شده تولید می‌کند. جداول هش فقط برای لینکر پویا برای انجام جستجوی نماد مورد نظر هستند. در LFS، لینکر پویا (ارائه‌شده توسط بسته Glibc) همیشه از جدول هش سبک گنو که برای پرس‌وجو سریع‌تر است استفاده می‌کند. بنابراین جدول هش کلاسیک ELF کاملاً بی‌فایده است. این باعث می‌شود که لینکر فقط جدول هش سبک گنو را تولید کند، تا زمانی که ما بسته‌ها را می‌سازیم، وقت زیادی صرف تولید جدول هش کلاسیک ELF نشود، یا فضای دیسک زیادی برای ذخیره آن اشغال نشود.

ادامه کامپایل بسته:

```bash
make
```

نصب بسته:

```bash
make install
```

جزئیات این بسته در بخش ۸.۲۰.۲، "محتویات Binutils" قرار دارد.

## ۵.۳. GCC-14.2.0 - گذر اول
بسته GCC شامل مجموعه کامپایلر گنو است که شامل کامپایلرهای C و C++ است.
زمان تقریبی ساخت: ۳.۲ SBU
فضای دیسک مورد نیاز: ۴.۹ گیگابایت

### ۵.۳.۱. نصب GCC متقاطع
GCC به بسته‌های GMP، MPFR و MPC نیاز دارد. از آنجایی که ممکن است این بسته‌ها در توزیع میزبان شما شامل نباشند، آن‌ها همراه با GCC ساخته خواهند شد. هر بسته را در دایرکتوری منبع GCC باز کنید و دایرکتوری‌های ایجادشده را به گونه‌ای تغییر نام دهید که روش‌های ساخت GCC به طور خودکار از آن‌ها استفاده کنند:

یادداشت
در مورد این فصل، درک اشتباهات زیادی وجود دارد. روش‌ها مانند هر فصل دیگر است، همانطور که قبلاً توضیح داده شد (دستورات ساخت بسته). ابتدا تارball gcc-14.2.0 را از دایرکتوری منابع خارج کنید، سپس به دایرکتوری ایجادشده تغییر مسیر دهید. فقط سپس باید با دستورات زیر ادامه دهید.

```bash
tar -xf ../mpfr-4.2.1.tar.xz
mv -v mpfr-4.2.1 mpfr
tar -xf ../gmp-6.3.0.tar.xz
mv -v gmp-6.3.0 gmp
tar -xf ../mpc-1.3.1.tar.gz
mv -v mpc-1.3.1 mpc
```

در میزبان‌های x86_64، نام پیش‌فرض دایرکتوری برای کتابخانه‌های 64 بیتی را روی "lib" تنظیم کنید:

```bash
case $(uname -m) in
x86_64)
sed -e '/m64=/s/lib64/lib/' \
-i.orig gcc/config/i386/t-linux64
;;
esac
```

مستندات GCC توصیه می‌کنند که GCC در یک دایرکتوری ساخت اختصاصی ساخته شود:

```bash
mkdir -v build
cd build
```

GCC را برای کامپایل آماده کنید:

```bash
../configure \
--target=$LFS_TGT \
--prefix=$LFS/tools \
--with-glibc-version=2.40 \
--with-sysroot=$LFS \
--with-newlib \
--without-headers \
--enable-default-pie \
--enable-default-ssp \
--disable-nls \
--disable-shared \
--disable-multilib \
--disable-threads \
--disable-libatomic \
--disable-libgomp \
--disable-libquadmath \
--disable-libssp \
--disable-libvtv \
--disable-libstdcxx \
--enable-languages=c,c++
```

معنی گزینه‌های پیکربندی:

`--with-glibc-version=2.40`

این گزینه نسخه Glibc را مشخص می‌کند که در هدف مورد استفاده قرار خواهد گرفت. این گزینه برای libc میزبان مربوط نیست، زیرا همه چیزی که توسط GCC گذر اول کامپایل می‌شود، در محیط chroot که از libc میزبان جدا است، اجرا خواهد شد.

`--with-newlib`

از آنجایی که هنوز کتابخانه C قابل استفاده در دسترس نیست، این اطمینان حاصل می‌کند که هنگام ساخت libgcc، ثابت inhibit_libc تعریف شود. این باعث می‌شود که هیچ کد دیگری که پشتیبانی libc را نیاز دارد، کامپایل نشود.

`--without-headers`

هنگام ایجاد یک کامپایلر متقاطع کامل، GCC به هدرهای استاندارد سازگار با سیستم هدف نیاز دارد. برای اهداف ما این هدرها مورد نیاز نخواهند بود. این گزینه باعث می‌شود که GCC از جستجوی آن‌ها خودداری کند.

`--enable-default-pie` و `--enable-default-ssp`

این گزینه‌ها به GCC اجازه می‌دهند که برنامه‌ها را با برخی ویژگی‌های امنیتی سختگیرانه (اطلاعات بیشتر در مورد آنها در یادداشت در مورد PIE و SSP در فصل ۸) به طور پیش‌فرض کامپایل کند. در این مرحله به طور دقیق مورد نیاز نیستند، زیرا کامپایلر فقط اجراکننده‌های موقت تولید خواهد کرد. اما تمیزتر است که بسته‌های موقت تا آنجا که امکان دارد به بسته‌های نهایی نزدیک باشند.

`--disable-shared`

این گزینه باعث می‌شود که GCC کتابخانه‌های داخلی خود را به صورت استاتیک پیوند دهد. ما به این نیاز داریم زیرا کتابخانه‌های اشتراکی به Glibc، که هنوز در سیستم هدف نصب نشده است، نیاز دارند.

`--disable-multilib`

در x86_64، LFS از پیکربندی multilib پشتیبانی نمی‌کند. این گزینه برای x86 بی‌خطر است.

`--disable-threads`، `--disable-libatomic`، `--disable-libgomp`، `--disable-libquadmath`، `--disable-libssp`، `--disable-libvtv`، `--disable-libstdcxx`

این گزینه‌ها پشتیبانی برای چندرشته‌ای، libatomic، libgomp، libquadmath، libssp، libvtv و کتابخانه استاندارد C++ را غیرفعال می‌کنند. این امکانات ممکن است هنگام ساخت یک کامپایلر متقاطع کامپایل نشوند و برای وظیفه کامپایل متقاطع libc موقت ضروری نیستند.

`--enable-languages=c,c++`

این گزینه اطمینان می‌دهد که فقط کامپایلرهای C و C++ ساخته می‌شوند. این تنها زبان‌های مورد نیاز در حال حاضر است.

GCC را با اجرای دستور زیر کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

```bash
make install
```

این ساخت GCC چند هدر داخلی سیستم نصب کرده است. به طور معمول یکی از آن‌ها، limits.h، در عوض شامل هدر limits.h مربوطه سیستم، در این مورد $LFS/usr/include/limits.h، می‌شود. اما در زمان این ساخت GCC، $LFS/usr/include/limits.h وجود ندارد، بنابراین هدر داخلی که به تازگی نصب شده است، یک فایل خودگردان و ناقص است و ویژگی‌های گسترده هدر سیستم را شامل نمی‌شود. این برای ساخت Glibc کافی است، اما هدر داخلی کامل بعداً مورد نیاز خواهد بود. یک نسخه کامل از هدر داخلی را با استفاده از دستوری که در شرایط عادی سیستم ساخت GCC انجام می‌دهد، ایجاد کنید:
```
یادداشت
دستور زیر یک مثال از جانشینی فرمان تودرتو با استفاده از دو روش نشان می‌دهد: بک تیک و ساختار $()   می‌توان آن را با استفاده از همان روش برای هر دو جانشینی بازنویسی کرد، اما برای نشان دادن اینکه چگونه می‌توان آن‌ها را با هم ترکیب کرد، به این صورت نشان داده شده است. به طور کلی، روش $() ترجیح داده می‌شود.
```

```bash
cd ..
cat gcc/limitx.h gcc/glimits.h gcc/limity.h > \
`dirname $($LFS_TGT-gcc -print-libgcc-file-name)`/include/limits.h
```

جزئیات این بسته در بخش ۸.۲۹.۲، "محتویات GCC" قرار دارد.

### ۵.۴. هدرهای API لینوکس-۶.۱۰.۵
هدرهای API لینوکس (در linux-6.10.5.tar.xz) رابط برنامه‌نویسی کاربردی (API) هسته را برای استفاده توسط Glibc در معرض قرار می‌دهند.
زمان تقریبی ساخت: کمتر از ۰.۱ SBU
فضای دیسک مورد نیاز: ۱.۶ گیگابایت

### ۵.۴.۱. نصب هدرهای API لینوکس
هسته لینوکس باید یک رابط برنامه‌نویسی کاربردی (API) را برای کتابخانه C سیستم (Glibc در LFS) در معرض قرار دهد. این کار با طهارت بخشی به انواع مختلف فایل‌های هدر که در بسته منبع هسته لینوکس ارسال می‌شوند، انجام می‌شود.
مطمئن شوید که هیچ فایل منسوخی در بسته وجود ندارد:

```bash
make mrproper
```

اکنون هدرهای قابل مشاهده کاربر را از منبع استخراج کنید. هدف make "headers_install" توصیه نمی‌شود، زیرا به rsync نیاز دارد که ممکن است در دسترس نباشد. ابتدا هدرها در ./usr قرار داده می‌شوند، سپس به محل مورد نیاز کپی می‌شوند.

```bash
make headers
find usr/include -type f ! -name '*.h' -delete
cp -rv usr/include $LFS/usr
```

### ۵.۴.۲. محتویات هدرهای API لینوکس

```
هدرهای نصب‌شده: `/usr/include/asm/*.h`، `/usr/include/asm-generic/*.h`، `/usr/include/drm/*.h`، `/usr/include/linux/*.h`، `/usr/include/misc/*.h`، `/usr/include/mtd/*.h`، `/usr/include/rdma/*.h`، `/usr/include/scsi/*.h`، `/usr/include/sound/*.h`، `/usr/include/video/*.h` و `/usr/include/xen/*.h`
دایرکتوری‌های نصب‌شده: `/usr/include/asm`، `/usr/include/asm-generic`، `/usr/include/drm`، `/usr/include/linux`، `/usr/include/misc`، `/usr/include/mtd`، `/usr/include/rdma`، `/usr/include/scsi`، `/usr/include/sound`، `/usr/include/video` و `/usr/include/xen`
```
شرح کوتاه

```
`/usr/include/asm/*.h` هدرهای ASM رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/asm-generic/*.h` هدرهای ASM Generic رابط برنامه‌نویسی کاربردی لینوکس

`/usr/include/drm/*.h` هدرهای DRM رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/linux/*.h` هدرهای Linux رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/misc/*.h` هدرهای متفرقه رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/mtd/*.h` هدرهای MTD رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/rdma/*.h` هدرهای RDMA رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/scsi/*.h` هدرهای SCSI رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/sound/*.h` هدرهای صوتی رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/video/*.h` هدرهای ویدئویی رابط برنامه‌نویسی کاربردی لینوکس
`/usr/include/xen/*.h` هدرهای Xen رابط برنامه‌نویسی کاربردی لینوکس
```

### ۵.۵. Glibc-2.40
بسته Glibc شامل اصلی‌ترین کتابخانه C است. این کتابخانه روش‌های اصلی برای تخصیص حافظه، جستجوی دایرکتوری‌ها، باز و بستن فایل‌ها، خواندن و نوشتن فایل‌ها، کارکرد رشته‌ها، تطبیق الگو، محاسبات و غیره را فراهم می‌کند.
زمان تقریبی ساخت: ۱.۳ SBU
فضای دیسک مورد نیاز: ۸۲۸ مگابایت

### ۵.۵.۱. نصب Glibc
ابتدا یک پیوند نمادین برای رعایت LSB ایجاد کنید. علاوه بر این، برای x86_64، یک پیوند نمادین سازگاری که برای عملکرد صحیح پویاگر کتابخانه مورد نیاز است، ایجاد کنید:

```bash
case $(uname -m) in
i?86) ln -sfv ld-linux.so.2 $LFS/lib/ld-lsb.so.3
;;
x86_64) ln -sfv ../lib/ld-linux-x86-64.so.2 $LFS/lib64
ln -sfv ../lib/ld-linux-x86-64.so.2 $LFS/lib64/ld-lsb-x86-64.so.3
;;
esac
```

***یادداشت***
دستور بالا صحیح است. دستور ln دارای چند نسخه نحوی است، بنابراین مطمئن شوید که info coreutils ln و ln(1) را بررسی کنید قبل از گزارش آنچه که ممکن است یک خطا به نظر برسد.

برخی از برنامه‌های Glibc از دایرکتوری /var/db غیر-FHS متبع برای ذخیره داده‌های زمان اجرای خود استفاده می‌کنند. وصله زیر را اعمال کنید تا چنین برنامه‌هایی داده‌های زمان اجرای خود را در محل‌های مناسب FHS ذخیره کنند:

```bash
patch -Np1 -i ../glibc-2.40-fhs-1.patch
```

مستندات Glibc توصیه می‌کنند که Glibc در یک دایرکتوری ساخت اختصاصی ساخته شود:

```bash
mkdir -v build
cd build
```

اطمینان حاصل کنید که ابزارهای ldconfig و sln در /usr/sbin نصب شده‌اند:

```bash
echo "rootsbindir=/usr/sbin" > configparms
```

حال Glibc را برای کامپایل آماده کنید:

```bash
../configure \
--prefix=/usr \
--host=$LFS_TGT \
--build=$(../scripts/config.guess) \
--enable-kernel=4.19 \
--with-headers=$LFS/usr/include \
--disable-nscd \
libc_cv_slibdir=/usr/lib
```

معنی گزینه‌های پیکربندی:

`--host=$LFS_TGT`، `--build=$(../scripts/config.guess)`
ترکیب این دو گزینه باعث می‌شود که سیستم ساخت Glibc خود را برای کامپایل متقاطع تنظیم کند، با استفاده از لینکر متقاطع و کامپایلر متقاطع در $LFS/tools.

`--enable-kernel=4.19`

این به Glibc می‌گوید که کتابخانه را با پشتیبانی از کرنل‌های لینوکس ۴.۱۹ و جدیدتر کامپایل کند. راه‌حل‌های کرنل‌های قدیمی‌تر فعال نمی‌شوند.

`--with-headers=$LFS/usr/include`

این به Glibc می‌گوید که خود را با هدرهای اخیراً نصب‌شده در دایرکتوری $LFS/usr/include کامپایل کند، تا بداند که کرنل دقیقاً چه ویژگی‌هایی دارد و بتواند خود را متناسب با آن بهینه کند.

`libc_cv_slibdir=/usr/lib`

این تضمین می‌کند که کتابخانه در /usr/lib نصب شود، به جای مسیر پیش‌فرض /lib64 در ماشین‌های ۶۴ بیتی.

`--disable-nscd`

داینمیک نیست و کش نام سرویس را ساخته نمی‌کند.

در این مرحله ممکن است هشدار زیر ظاهر شود:

```text
configure: WARNING:
*** These auxiliary programs are missing or 
*** incompatible versions: msgfmt
*** some features will be disabled.
*** Check the INSTALL file for required versions.
```

برنامه msgfmt ناسازگار یا از دست رفته معمولاً بی‌خطر است. این برنامه msgfmt بخشی از بسته Gettext است که توزیع میزبان باید فراهم کند.

یادداشت
گزارش‌هایی وجود داشته است که این بسته ممکن است هنگام ساخت به عنوان "make موازی" شکست بخورد. اگر این اتفاق بیفتد، دستور make را با گزینه -j1 دوباره اجرا کنید.

بسته را کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

هشدار
اگر LFS به درستی تنظیم نشده باشد و با وجود توصیه‌ها، به عنوان ریشه ساخته شود، دستور بعدی Glibc تازه‌ساخته شده را در سیستم میزبان شما نصب خواهد کرد، که تقریباً به طور قطع آن را غیرقابل استفاده خواهد کرد. بنابراین قبل از اجرای دستور زیر، دوباره بررسی کنید که محیط به درستی تنظیم شده است و ریشه نیستید.

```bash
make DESTDIR=$LFS install
```

معنی گزینه make install:

`DESTDIR=$LFS`

متغیر DESTDIR make توسط تقریباً همه بسته‌ها برای تعریف محلی که بسته باید نصب شود، استفاده می‌شود. اگر تنظیم نشود، به طور پیش‌فرض به دایرکتوری ریشه (/) اشاره می‌کند. در اینجا مشخص می‌کنیم که بسته در $LFS نصب می‌شود، که در بخش ۷.۴، "ورود به محیط chroot" به عنوان دایرکتوری ریشه استفاده خواهد شد.

یک مسیر سخت‌کد‌شده به پویاگر اجراکننده در اسکریپت ldd را اصلاح کنید:

```bash
sed '/RTLDLIST=/s@/usr@@g' -i $LFS/usr/bin/ldd
```

***هشدار***
در این مرحله، بسیار مهم است که متوقف شوید و اطمینان حاصل کنید که کارکردهای اصلی (کامپایل و پیوند) ابزارزنجیره جدید به نحوی که انتظار می‌رود، کار می‌کنند. برای انجام یک بررسی سالم، دستورات زیر را اجرا کنید:

```bash
echo 'int main(){}' | $LFS_TGT-gcc -xc -
readelf -l a.out | grep ld-linux
```

اگر همه چیز به درستی کار می‌کند، هیچ خطایی وجود نخواهد داشت و خروجی آخرین دستور به شکل زیر خواهد بود:

```bash
[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

توجه داشته باشید که برای ماشین‌های ۳۲ بیتی، نام پویاگر /lib/ld-linux.so.2 خواهد بود.

اگر خروجی به گونه نشان داده شده بالا نباشد، یا هیچ خروجی وجود نداشته باشد، پس چیزی اشتباه است. موارد را بررسی و مسیرها را دنبال کنید تا محل مشکل را پیدا و آن را اصلاح کنید. این مشکل باید قبل از ادامه حل شود.

وقتی همه چیز درست بود، فایل آزمایشی را پاک کنید:

```bash
rm -v a.out
```

***یادداشت***
ساخت بسته‌ها در فصل بعدی به عنوان یک بررسی تکمیلی این که ابزارزنجیره به درستی ساخته شده است، عمل خواهد کرد. اگر برخی از بسته‌ها، به ویژه Binutils-pass2 یا GCC-pass2، نتوانستند ساخته شوند، نشانه‌ای است که چیزی در نصب Binutils، GCC یا Glibc قبلی اشتباه بوده است.

جزئیات این بسته در بخش ۸.۵.۳، "محتویات Glibc" قرار دارد.

۵.۶. Libstdc++ از GCC-14.2.0
Libstdc++ کتابخانه استاندارد C++ است. برای کامپایل کد C++ (بخشی از GCC به زبان C++ نوشته شده است) مورد نیاز است، اما هنگام ساخت gcc-pass1 نصب آن را به تأخیر انداختیم، زیرا Libstdc++ به Glibc، که هنوز در دایرکتوری هدف در دسترس نبود، وابسته بود.
زمان تقریبی ساخت: ۰.۲ SBU
فضای دیسک مورد نیاز: ۱.۲ گیگابایت

### ۵.۶.۱. نصب Libstdc++ هدف
***یادداشت***
Libstdc++ بخشی از منابع GCC است. ابتدا باید تارball GCC را باز کنید و به دایرکتوری gcc-14.2.0 تغییر مسیر دهید.

یک دایرکتوری ساخت جداگانه برای Libstdc++ ایجاد کنید و به آن وارد شوید:

```bash
mkdir -v build
cd build
```

Libstdc++ را برای کامپایل آماده کنید:

```bash
../libstdc++-v3/configure \
--host=$LFS_TGT \
--build=$(../config.guess) \
--prefix=/usr \
--disable-multilib \
--disable-nls \
--disable-libstdcxx-pch \
--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/14.2.0
```

معنی گزینه‌های پیکربندی:

`--host=...`

مشخص می‌کند که کامپایلر متقاطعی که تازه ساخته‌ایم باید به جای آنچه در /usr/bin است استفاده شود.

`--disable-libstdcxx-pch`

این گزینه مانع از نصب فایل‌های هدر پیش‌کامپایل شده می‌شود، که در این مرحله مورد نیاز نیستند.

`--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/14.2.0`

این محل نصب فایل‌های هدر را مشخص می‌کند. از آنجایی که Libstdc++ کتابخانه استاندارد C++ برای LFS است، این دایرکتوری باید با محلی که کامپایلر C++ ($LFS_TGT-g++) به دنبال فایل‌های هدر استاندارد C++ است، مطابقت داشته باشد. در یک ساخت معمولی، این اطلاعات به طور خودکار از دایرکتوری سطح بالاتر به گزینه‌های پیکربندی Libstdc++ منتقل می‌شوند. در مورد ما، این اطلاعات باید به صراحت داده شود. کامپایلر C++ مسیر ریشه $LFS (مشخص شده هنگام ساخت GCC-pass1) را به مسیر جستجوی فایل‌های هدر اضافه خواهد کرد، بنابراین در واقع در $LFS/tools/$LFS_TGT/include/c++/14.2.0 جستجو خواهد کرد. ترکیب متغیر DESTDIR (در دستور make install زیر) و این گزینه باعث می‌شود که هدرها در آنجا نصب شوند.

Libstdc++ را با اجرای دستور زیر کامپایل کنید:

```bash
make
```

کتابخانه را نصب کنید:

```bash
make DESTDIR=$LFS install
```

فایل‌های آرشیو libtool را حذف کنید زیرا برای کامپایل متقاطع مضر هستند:

```bash
rm -v $LFS/usr/lib/lib{stdc++{,exp,fs},supc++}.la
```

جزئیات این بسته در بخش ۸.۲۹.۲، "محتویات GCC" قرار دارد.
