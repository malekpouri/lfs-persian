# فصل 4. آماده‌سازی‌های نهایی

## 4.1. مقدمه

در این فصل، ما چند کار اضافی برای آماده‌سازی ساخت سیستم موقت انجام خواهیم داد. ما یک مجموعه از دایرکتوری‌ها را در $LFS ایجاد خواهیم کرد (که در آن ابزارهای موقت را نصب خواهیم کرد)، یک کاربر بدون امتیاز اضافه می‌کنیم، و یک محیط ساخت مناسب برای آن کاربر ایجاد می‌کنیم. همچنین واحدهای زمانی ("SBU") که برای اندازه‌گیری زمان ساخت بسته‌های LFS استفاده می‌کنیم را توضیح می‌دهیم و اطلاعاتی در مورد مجموعه آزمون‌های بسته‌ها ارائه می‌دهیم.

## 4.2. ایجاد یک ساختار دایرکتوری محدود در سیستم‌فایل LFS

در این بخش، ما شروع به پر کردن سیستم‌فایل LFS با قطعاتی می‌کنیم که سیستم نهایی لینوکس را تشکیل خواهند داد. اولین قدم ایجاد یک سلسله مراتب دایرکتوری محدود است، تا برنامه‌های کامپایل شده در فصل 6 (و همچنین glibc و libstdc++ در فصل 5) بتوانند در مکان نهایی خود نصب شوند. ما این کار را انجام می‌دهیم تا آن برنامه‌های موقت هنگامی که نسخه‌های نهایی در فصل 8 ساخته می‌شوند، جایگزین شوند.

ساختار دایرکتوری مورد نیاز را با اجرای دستورات زیر به عنوان کاربر root ایجاد کنید:

```bash
mkdir -pv $LFS/{etc,var} $LFS/usr/{bin,lib,sbin}
for i in bin lib sbin; do
ln -sv usr/$i $LFS/$i
done
case $(uname -m) in
x86_64) mkdir -pv $LFS/lib64 ;;
esac
```

برنامه‌های فصل 6 با یک کامپایلر متقاطع کامپایل خواهند شد (جزئیات بیشتر را می‌توان در بخش نکات فنی زنجیره ابزار یافت). این کامپایلر متقاطع در یک دایرکتوری خاص نصب خواهد شد تا از سایر برنامه‌ها جدا شود. همچنان به عنوان کاربر root، آن دایرکتوری را با این دستور ایجاد کنید:

```bash
mkdir -pv $LFS/tools
```

> **نکته**
> 
> ویراستاران LFS عمداً تصمیم گرفته‌اند از دایرکتوری /usr/lib64 استفاده نکنند. چندین گام برداشته شده تا اطمینان حاصل شود که زنجیره ابزار از آن استفاده نخواهد کرد. اگر به هر دلیلی این دایرکتوری ظاهر شود (یا به دلیل اینکه در پیروی از دستورالعمل‌ها اشتباهی کرده‌اید، یا به این دلیل که یک بسته باینری نصب کرده‌اید که پس از اتمام LFS آن را ایجاد کرده است)، ممکن است سیستم شما را خراب کند. شما باید همیشه مطمئن شوید که این دایرکتوری وجود ندارد.

## 4.3. افزودن کاربر LFS

هنگامی که به عنوان کاربر root وارد سیستم می‌شوید، یک اشتباه کوچک می‌تواند به سیستم آسیب برساند یا آن را نابود کند. بنابراین، بسته‌های دو فصل بعدی به عنوان یک کاربر بدون امتیاز ساخته می‌شوند. شما می‌توانید از نام کاربری خود استفاده کنید، اما برای راحت‌تر کردن تنظیم یک محیط کاری تمیز، ما یک کاربر جدید به نام lfs به عنوان عضوی از یک گروه جدید (همچنین به نام lfs) ایجاد می‌کنیم و دستورات را به عنوان lfs در طول فرآیند نصب اجرا می‌کنیم. به عنوان کاربر root، دستورات زیر را برای افزودن کاربر جدید صادر کنید:

```bash
groupadd lfs
useradd -s /bin/bash -g lfs -m -k /dev/null lfs
```

این معنای گزینه‌های خط فرمان است:

-s /bin/bash
این bash را به عنوان پوسته پیش‌فرض برای کاربر lfs تعیین می‌کند.

-g lfs
این گزینه کاربر lfs را به گروه lfs اضافه می‌کند.

-m
این یک دایرکتوری خانگی برای lfs ایجاد می‌کند.

-k /dev/null
این پارامتر از کپی احتمالی فایل‌ها از یک دایرکتوری اسکلت (پیش‌فرض /etc/skel است) جلوگیری می‌کند با تغییر مکان ورودی به دستگاه ویژه null.

lfs
این نام کاربر جدید است.

اگر می‌خواهید به عنوان lfs وارد سیستم شوید یا از یک کاربر غیر root به lfs تغییر دهید (برخلاف تغییر به کاربر lfs هنگامی که به عنوان root وارد شده‌اید، که نیازی به رمز عبور lfs ندارد)، باید برای lfs یک رمز عبور تنظیم کنید. دستور زیر را به عنوان کاربر root برای تنظیم رمز عبور صادر کنید:

```bash
passwd lfs
```

به lfs دسترسی کامل به تمام دایرکتوری‌های زیر $LFS را با تعیین lfs به عنوان مالک بدهید:

```bash
chown -v lfs $LFS/{usr{,/*},lib,var,etc,bin,sbin,tools}
case $(uname -m) in
x86_64) chown -v lfs $LFS/lib64 ;;
esac
```

> **نکته**
> 
> در برخی از سیستم‌های میزبان، دستور su زیر به درستی کامل نمی‌شود و ورود به سیستم برای کاربر lfs را به پس‌زمینه معلق می‌کند. اگر پیام "lfs:~$" بلافاصله ظاهر نشد، وارد کردن دستور fg این مشکل را حل خواهد کرد.

سپس، یک پوسته را به عنوان کاربر lfs شروع کنید. این کار را می‌توان با ورود به سیستم به عنوان lfs در یک کنسول مجازی، یا با دستور جایگزین/تعویض کاربر زیر انجام داد:

```bash
su - lfs
```

"-" به su دستور می‌دهد تا یک پوسته ورود را در مقابل یک پوسته غیر ورود شروع کند. تفاوت بین این دو نوع پوسته به تفصیل در bash(1) و info bash توضیح داده شده است.

## 4.4. تنظیم محیط

یک محیط کاری خوب را با ایجاد دو فایل راه‌اندازی جدید برای پوسته bash تنظیم کنید. در حالی که به عنوان کاربر lfs وارد شده‌اید، دستور زیر را برای ایجاد یک .bash_profile جدید صادر کنید:

```bash
cat > ~/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
```

هنگامی که به عنوان کاربر lfs وارد سیستم می‌شوید، یا زمانی که با استفاده از دستور su با گزینه "-" به کاربر lfs تغییر می‌دهید، پوسته اولیه یک پوسته ورود است که فایل /etc/profile میزبان را می‌خواند (احتمالاً حاوی برخی تنظیمات و متغیرهای محیطی) و سپس .bash_profile را می‌خواند. دستور `exec env -i.../bin/bash` در فایل .bash_profile، پوسته در حال اجرا را با یک پوسته جدید با محیط کاملاً خالی جایگزین می‌کند، به جز متغیرهای HOME، TERM و PS1. این اطمینان حاصل می‌کند که هیچ متغیر محیطی ناخواسته و بالقوه خطرناک از سیستم میزبان به محیط ساخت نشت نمی‌کند.

نمونه جدید پوسته، یک پوسته غیر ورودی است که محتویات فایل‌های /etc/profile یا .bash_profile را نمی‌خواند و اجرا نمی‌کند، بلکه در عوض فایل .bashrc را می‌خواند و اجرا می‌کند. اکنون فایل .bashrc را ایجاد کنید:

```bash
cat > ~/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LFS LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
```

معنای تنظیمات در .bashrc:

**set +h**

دستور set +h تابع هش bash را خاموش می‌کند. هش کردن معمولاً یک ویژگی مفید است - bash از یک جدول هش برای به یاد آوردن مسیر کامل فایل‌های اجرایی استفاده می‌کند تا از جستجوی مکرر PATH برای یافتن همان فایل اجرایی جلوگیری کند. با این حال، ابزارهای جدید باید به محض نصب شدن استفاده شوند. خاموش کردن تابع هش، پوسته را مجبور می‌کند تا هر بار که یک برنامه باید اجرا شود، PATH را جستجو کند. به این ترتیب، پوسته ابزارهای تازه کامپایل شده را در $LFS/tools/bin به محض در دسترس بودن پیدا می‌کند، بدون اینکه نسخه قبلی همان برنامه را که توسط توزیع میزبان در /usr/bin یا /bin ارائه شده است، به خاطر بیاورد.

**umask 022**

تنظیم ماسک ایجاد فایل کاربر (umask) به 022 اطمینان می‌دهد که فایل‌ها و دایرکتوری‌های تازه ایجاد شده فقط توسط مالک آنها قابل نوشتن هستند، اما توسط هر کسی قابل خواندن و اجرا هستند (با فرض استفاده از حالت‌های پیش‌فرض توسط فراخوانی سیستمی open(2)، فایل‌های جدید با حالت مجوز 644 و دایرکتوری‌ها با حالت 755 ایجاد می‌شوند).

**LFS=/mnt/lfs**

متغیر LFS باید به نقطه اتصال انتخاب شده تنظیم شود.

**LC_ALL=POSIX**

متغیر LC_ALL بومی‌سازی برخی برنامه‌ها را کنترل می‌کند و باعث می‌شود پیام‌های آنها از قراردادهای یک کشور خاص پیروی کنند. تنظیم LC_ALL به "POSIX" یا "C" (این دو معادل هستند) اطمینان می‌دهد که همه چیز در محیط کراس‌کامپایل طبق انتظار کار خواهد کرد.

**LFS_TGT=$(uname -m)-lfs-linux-gnu**

متغیر LFS_TGT یک توصیف ماشین غیر پیش‌فرض اما سازگار را برای استفاده در ساخت کراس‌کامپایلر و لینکر ما و هنگام کراس‌کامپایل تولچین موقت ما تنظیم می‌کند. اطلاعات بیشتر در یادداشت‌های فنی تولچین ارائه شده است.

**PATH=/usr/bin**

بسیاری از توزیع‌های مدرن لینوکس /bin و /usr/bin را ادغام کرده‌اند. در این صورت، متغیر PATH استاندارد باید برای محیط فصل 6 به /usr/bin/ تنظیم شود. وقتی این مورد نیست، خط بعدی /bin را به مسیر اضافه می‌کند.

**if [ ! -L /bin ]; then PATH=/bin:$PATH; fi**

اگر /bin یک لینک نمادین نباشد، باید به متغیر PATH اضافه شود.

**PATH=$LFS/tools/bin:$PATH**

با قرار دادن $LFS/tools/bin در ابتدای PATH استاندارد، کراس‌کامپایلر نصب شده در ابتدای فصل 5 بلافاصله پس از نصب توسط پوسته انتخاب می‌شود. این، در ترکیب با خاموش کردن هش کردن، خطر استفاده از کامپایلر میزبان به جای کراس‌کامپایلر را محدود می‌کند.

**CONFIG_SITE=$LFS/usr/share/config.site**

در فصل 5 و فصل 6، اگر این متغیر تنظیم نشود، اسکریپت‌های پیکربندی ممکن است تلاش کنند موارد پیکربندی خاص برخی توزیع‌ها را از /usr/share/config.site در سیستم میزبان بارگیری کنند. آن را لغو کنید تا از آلودگی احتمالی از میزبان جلوگیری شود.

**export ...**

در حالی که دستورات قبلی برخی متغیرها را تنظیم کرده‌اند، برای اینکه آنها در هر زیر پوسته قابل مشاهده باشند، آنها را صادر می‌کنیم.

**مهم**

چندین توزیع تجاری یک نمونه سازی مستند نشده از /etc/bash.bashrc را به مقداردهی اولیه bash اضافه می‌کنند. این فایل پتانسیل تغییر محیط کاربر lfs را به روش‌هایی دارد که می‌تواند بر ساخت بسته‌های حیاتی LFS تأثیر بگذارد. برای اطمینان از تمیز بودن محیط کاربر lfs، وجود /etc/bash.bashrc را بررسی کنید و در صورت وجود، آن را کنار بگذارید. به عنوان کاربر ریشه، اجرا کنید:

```bash
[ ! -e /etc/bash.bashrc ] || mv -v /etc/bash.bashrc /etc/bash.bashrc.NOUSE
```

زمانی که کاربر lfs دیگر مورد نیاز نیست (در ابتدای فصل 7)، می‌توانید به راحتی /etc/bash.bashrc را بازگردانید (در صورت تمایل).

توجه داشته باشید که بسته Bash LFS که ما در بخش 8.36، "Bash-5.2.32" خواهیم ساخت برای بارگیری یا اجرای /etc/bash.bashrc پیکربندی نشده است، بنابراین این فایل در یک سیستم LFS تکمیل شده بی‌فایده است.

برای بسیاری از سیستم‌های مدرن با چندین پردازنده (یا هسته)، زمان کامپایل برای یک بسته را می‌توان با انجام یک "ساخت موازی" با گفتن به برنامه make که چند پردازنده در دسترس است از طریق یک گزینه خط فرمان یا یک متغیر محیطی کاهش داد. به عنوان مثال، یک پردازنده Intel Core i9-13900K دارای 8 هسته P (عملکرد) و 16 هسته E (کارآیی) است، و یک هسته P می‌تواند به طور همزمان دو رشته را اجرا کند، بنابراین هر هسته P توسط هسته لینوکس به عنوان دو هسته منطقی مدل می‌شود. در نتیجه در مجموع 32 هسته منطقی وجود دارد. یک راه آشکار برای استفاده از تمام این هسته‌های منطقی، اجازه دادن به make برای ایجاد تا 32 کار ساخت است. این کار را می‌توان با ارسال گزینه -j32 به make انجام داد:

```bash
make -j32
```

یا متغیر محیطی MAKEFLAGS را تنظیم کنید و محتوای آن به طور خودکار توسط make به عنوان گزینه‌های خط فرمان استفاده خواهد شد:

```bash
export MAKEFLAGS=-j32
```

**مهم**

هرگز یک گزینه -j بدون عدد به make ارسال نکنید یا چنین گزینه‌ای را در MAKEFLAGS تنظیم نکنید. انجام این کار به make اجازه می‌دهد تا کارهای ساخت نامحدود ایجاد کند و باعث مشکلات پایداری سیستم شود.

برای استفاده از تمام هسته‌های منطقی موجود برای ساخت بسته‌ها در فصل 5 و فصل 6، اکنون MAKEFLAGS را در .bashrc تنظیم کنید:

```bash
cat >> ~/.bashrc << "EOF"
export MAKEFLAGS=-j$(nproc)
EOF
```

$(nproc) را با تعداد هسته‌های منطقی که می‌خواهید استفاده کنید جایگزین کنید اگر نمی‌خواهید از تمام هسته‌های منطقی استفاده کنید.

در نهایت، برای اطمینان از آماده بودن کامل محیط برای ساخت ابزارهای موقت، پوسته bash را مجبور کنید تا پروفایل کاربر جدید را بخواند:

```bash
source ~/.bash_profile
```
## 4.5. درباره SBUها

بسیاری از افراد مایلند از قبل بدانند که کامپایل و نصب هر بسته تقریباً چقدر طول می‌کشد. از آنجایی که Linux From Scratch را می‌توان روی سیستم‌های بسیار متفاوتی ساخت، ارائه تخمین‌های زمانی مطلق غیرممکن است. بزرگترین بسته (gcc) در سریع‌ترین سیستم‌ها حدود 5 دقیقه طول می‌کشد، اما ممکن است در سیستم‌های کندتر روزها طول بکشد! به جای ارائه زمان‌های واقعی، از معیار واحد ساخت استاندارد (SBU) استفاده خواهد شد.

معیار SBU به شرح زیر کار می‌کند. اولین بسته‌ای که در فصل 5 کامپایل می‌شود، binutils است. زمانی که برای کامپایل با استفاده از یک هسته طول می‌کشد، به عنوان واحد ساخت استاندارد یا SBU در نظر گرفته می‌شود. تمام زمان‌های کامپایل دیگر بر حسب این واحد زمانی بیان خواهند شد.

به عنوان مثال، یک بسته را در نظر بگیرید که زمان کامپایل آن 4.5 SBU است. این بدان معناست که اگر سیستم شما 4 دقیقه برای کامپایل و نصب اولین گذر binutils طول کشید، حدود 18 دقیقه طول خواهد کشید تا بسته مثال را بسازد. خوشبختانه، اکثر زمان‌های ساخت کوتاه‌تر از یک SBU هستند.

SBUها کاملاً دقیق نیستند زیرا به عوامل زیادی از جمله نسخه GCC سیستم میزبان بستگی دارند. آنها در اینجا ارائه می‌شوند تا تخمینی از مدت زمان لازم برای نصب یک بسته ارائه دهند، اما اعداد می‌توانند در برخی موارد تا ده‌ها دقیقه متغیر باشند.

در برخی سیستم‌های جدیدتر، مادربورد قادر به کنترل سرعت ساعت سیستم است. این می‌تواند با دستوری مانند powerprofilesctl کنترل شود. این در LFS در دسترس نیست، اما ممکن است در توزیع میزبان در دسترس باشد. پس از تکمیل LFS، می‌توان آن را با روش‌های موجود در صفحه BLFS power-profiles-daemon به سیستم اضافه کرد. قبل از اندازه‌گیری زمان ساخت هر بسته، توصیه می‌شود از یک پروفایل توان سیستم تنظیم شده برای حداکثر عملکرد (و حداکثر مصرف انرژی) استفاده کنید. در غیر این صورت، مقدار SBU اندازه‌گیری شده ممکن است نادرست باشد زیرا سیستم ممکن است هنگام ساخت binutils-pass1 یا سایر بسته‌ها به طور متفاوتی واکنش نشان دهد. توجه داشته باشید که حتی اگر از همان پروفایل برای هر دو بسته استفاده شود، ممکن است یک عدم دقت قابل توجه همچنان نمایان شود زیرا اگر سیستم هنگام شروع روند ساخت بیکار باشد، ممکن است کندتر پاسخ دهد. تنظیم پروفایل توان به "performance" این مشکل را به حداقل می‌رساند. و مشخصاً انجام این کار همچنین باعث می‌شود سیستم LFS را سریع‌تر بسازد.

اگر powerprofilesctl در دسترس است، دستور `powerprofilesctl set performance` را صادر کنید تا پروفایل عملکرد را انتخاب کنید. برخی از توزیع‌ها به جای powerprofilesctl، دستور tuned-adm را برای مدیریت پروفایل‌ها ارائه می‌دهند، در این توزیع‌ها دستور `tuned-adm profile throughput-performance` را صادر کنید تا پروفایل throughput-performance را انتخاب کنید.

**توجه**
هنگامی که از چندین پردازنده به این روش استفاده می‌شود، واحدهای SBU در کتاب حتی بیشتر از حالت معمول متغیر خواهند بود. در برخی موارد، مرحله make به سادگی شکست خواهد خورد. تحلیل خروجی فرآیند ساخت نیز دشوارتر خواهد بود زیرا خطوط از فرآیندهای مختلف در هم تنیده خواهند شد. اگر با مشکلی در یک مرحله ساخت مواجه شدید، به ساخت تک پردازنده بازگردید تا پیام‌های خطا را به درستی تحلیل کنید.

زمان‌های ارائه شده در اینجا برای تمام بسته‌ها (به جز binutils-pass1 که بر اساس یک هسته است) بر اساس استفاده از چهار هسته (-j4) است. زمان‌های فصل 8 همچنین شامل زمان اجرای آزمون‌های رگرسیون برای بسته است مگر اینکه به طور دیگری مشخص شده باشد.

## 4.6. درباره مجموعه‌های آزمون

اکثر بسته‌ها یک مجموعه آزمون ارائه می‌دهند. اجرای مجموعه آزمون برای یک بسته تازه ساخته شده ایده خوبی است زیرا می‌تواند یک "بررسی سلامت" ارائه دهد که نشان می‌دهد همه چیز به درستی کامپایل شده است. یک مجموعه آزمون که مجموعه بررسی‌های خود را با موفقیت پشت سر می‌گذارد، معمولاً ثابت می‌کند که بسته همانطور که توسعه دهنده در نظر داشته عمل می‌کند. با این حال، تضمین نمی‌کند که بسته کاملاً بدون اشکال است.
برخی از مجموعه‌های آزمون مهم‌تر از دیگران هستند. به عنوان مثال، مجموعه‌های آزمون برای بسته‌های ابزار اصلی - GCC، binutils و glibc - به دلیل نقش مرکزی آنها در یک سیستم با عملکرد مناسب، از اهمیت بسیار بالایی برخوردار هستند. مجموعه‌های آزمون برای GCC و glibc می‌توانند زمان بسیار طولانی برای تکمیل طول بکشند، به ویژه در سخت‌افزارهای کندتر، اما به شدت توصیه می‌شوند.

**نکته**
اجرای مجموعه‌های آزمون در فصل 5 و فصل 6 بی‌معنی است؛ زیرا برنامه‌های آزمایشی با یک کامپایلر متقاطع کامپایل می‌شوند، احتمالاً نمی‌توانند روی میزبان ساخت اجرا شوند.

یک مشکل رایج با اجرای مجموعه‌های آزمون برای binutils و GCC، تمام شدن ترمینال‌های شبه (PTY) است. این می‌تواند منجر به تعداد زیادی از آزمون‌های ناموفق شود. این ممکن است به چندین دلیل رخ دهد، اما محتمل‌ترین دلیل این است که سیستم میزبان سیستم فایل devpts را به درستی تنظیم نکرده است. این مسأله با جزئیات بیشتر در https://www.linuxfromscratch.org/lfs/faq.html#no-ptys مورد بحث قرار گرفته است.

گاهی اوقات مجموعه‌های آزمون بسته‌ها به دلایلی که توسعه‌دهندگان از آن آگاه هستند و غیر بحرانی تشخیص داده‌اند، شکست می‌خورند. لاگ‌های موجود در https://www.linuxfromscratch.org/lfs/build-logs/12.2/ را مشاهده کنید تا بررسی کنید که آیا این شکست‌ها مورد انتظار هستند یا خیر. این سایت برای تمام مجموعه‌های آزمون در سراسر این کتاب معتبر است.
