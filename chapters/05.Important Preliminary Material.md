# مطالب مقدماتی مهم

## مقدمه

این بخش به سه مرحله تقسیم می‌شود: اول، ساخت یک کامپایلر متقاطع و کتابخانه‌های مرتبط با آن؛ دوم، استفاده از این تولچین متقاطع برای ساخت چندین ابزار به روشی که آنها را از توزیع میزبان جدا می‌کند؛ و سوم، ورود به محیط chroot (که جداسازی میزبان را بیشتر بهبود می‌بخشد) و ساخت ابزارهای باقی‌مانده مورد نیاز برای ساخت سیستم نهایی.

> **مهم**
> این جایی است که کار واقعی ساخت یک سیستم جدید آغاز می‌شود. بسیار دقت کنید که دستورالعمل‌ها را دقیقاً همانطور که کتاب نشان می‌دهد دنبال کنید. باید سعی کنید بفهمید که هر دستور چه کاری انجام می‌دهد، و صرف نظر از اینکه چقدر مشتاق هستید که ساخت خود را به پایان برسانید، باید از تایپ کورکورانه دستورات همانطور که نشان داده شده خودداری کنید. وقتی چیزی را نمی‌فهمید، مستندات را بخوانید. همچنین، با استفاده از ابزار tee برای ارسال خروجی ترمینال به یک فایل، تایپ خود و خروجی دستورات را پیگیری کنید. این کار اشکال‌زدایی را در صورت بروز مشکل آسان‌تر می‌کند.

بخش بعدی یک مقدمه فنی به فرآیند ساخت است، در حالی که بخش بعدی دستورالعمل‌های عمومی بسیار مهمی را ارائه می‌دهد.

## یادداشت‌های فنی تولچین

این بخش برخی از دلایل و جزئیات فنی پشت روش کلی ساخت را توضیح می‌دهد. سعی نکنید بلافاصله همه چیز را در این بخش درک کنید. بیشتر این اطلاعات پس از انجام یک ساخت واقعی واضح‌تر خواهد شد. در هر زمان در طول فرآیند ساخت می‌توانید به این فصل بازگردید و آن را دوباره بخوانید.

هدف کلی فصل 5 و فصل 6 تولید یک منطقه موقت حاوی مجموعه‌ای از ابزارهایی است که مشخص شده خوب هستند و از سیستم میزبان جدا شده‌اند. با استفاده از دستور chroot، کامپایل‌ها در فصل‌های باقی‌مانده در آن محیط ایزوله خواهند شد، که یک ساخت تمیز و بدون مشکل سیستم هدف LFS را تضمین می‌کند. فرآیند ساخت طوری طراحی شده است که خطرات را برای خوانندگان جدید به حداقل برساند و در عین حال بیشترین ارزش آموزشی را فراهم کند.

این فرآیند ساخت بر اساس کامپایل متقاطع است. کامپایل متقاطع معمولاً برای ساخت یک کامپایلر و تولچین مرتبط با آن برای یک ماشین متفاوت از ماشینی که برای ساخت استفاده می‌شود، استفاده می‌شود. این برای LFS اکیداً ضروری نیست، زیرا ماشینی که سیستم جدید در آن اجرا خواهد شد همان ماشینی است که برای ساخت استفاده می‌شود. اما کامپایل متقاطع یک مزیت بزرگ دارد: هر چیزی که به صورت متقاطع کامپایل شود نمی‌تواند به محیط میزبان وابسته باشد.

## درباره کامپایل متقاطع

>**نکته**
>کتاب LFS یک آموزش عمومی برای ساخت یک تولچین متقاطع (یا بومی) نیست (و شامل آن نیست). از دستورات کتاب برای یک تولچین متقاطع برای هدفی غیر از ساخت LFS استفاده نکنید، مگر اینکه واقعاً بفهمید چه کاری انجام می‌دهید.

کامپایل متقاطع شامل برخی مفاهیم است که شایسته یک بخش مجزا هستند. اگرچه ممکن است این بخش در خواندن اول حذف شود، بازگشت به آن بعداً به شما کمک می‌کند تا درک کامل‌تری از فرآیند به دست آورید.

بیایید ابتدا برخی از اصطلاحات استفاده شده در این زمینه را تعریف کنیم.
**ساخت (build)**
ماشینی است که ما در آن برنامه‌ها را می‌سازیم. توجه داشته باشید که به این ماشین همچنین "میزبان" نیز گفته می‌شود.

**میزبان (host)**
ماشین/سیستمی است که برنامه‌های ساخته شده در آن اجرا خواهند شد. توجه داشته باشید که این استفاده از "میزبان" با بخش‌های دیگر متفاوت است.

**هدف (target)**
فقط برای کامپایلرها استفاده می‌شود. این ماشینی است که کامپایلر برای آن کد تولید می‌کند. ممکن است با هر دو ماشین ساخت و میزبان متفاوت باشد.

به عنوان مثال، بیایید سناریوی زیر را تصور کنیم (که گاهی به آن "Canadian Cross" گفته می‌شود). ما فقط یک کامپایلر روی یک ماشین کند داریم، بیایید آن را ماشین A بنامیم، و کامپایلر ccA. ما همچنین یک ماشین سریع (B) داریم، اما هیچ کامپایلری برای (B) نداریم، و می‌خواهیم برای یک ماشین کند سوم (C) کد تولید کنیم. ما یک کامپایلر برای ماشین C در سه مرحله خواهیم ساخت.

| مرحله | ساخت | میزبان | هدف | عملیات |
|-------|------|--------|------|---------|
| 1 | A | A | B | ساخت کامپایلر متقاطع cc1 با استفاده از ccA روی ماشین A. |
| 2 | A | B | C | ساخت کامپایلر متقاطع cc2 با استفاده از cc1 روی ماشین A. |
| 3 | B | C | C | ساخت کامپایلر ccC با استفاده از cc2 روی ماشین B. |

سپس، تمام برنامه‌های مورد نیاز ماشین C را می‌توان با استفاده از cc2 روی ماشین سریع B کامپایل کرد. توجه داشته باشید که مگر اینکه B بتواند برنامه‌های تولید شده برای C را اجرا کند، هیچ راهی برای آزمایش برنامه‌های تازه ساخته شده تا زمانی که خود ماشین C در حال اجرا نباشد، وجود ندارد. به عنوان مثال، برای اجرای یک مجموعه آزمون روی ccC، ممکن است بخواهیم یک مرحله چهارم اضافه کنیم:

| مرحله | ساخت | میزبان | هدف | عملیات |
|-------|------|--------|------|---------|
| 4 | C | C | C | بازسازی و آزمایش ccC با استفاده از ccC روی ماشین C |

ترجمه متن به فارسی:

در مثال بالا، فقط cc1 و cc2 کراس کامپایلر هستند، یعنی آنها کدی را برای ماشینی متفاوت از ماشینی که روی آن اجرا می‌شوند تولید می‌کنند. کامپایلرهای دیگر ccA و ccC کدی را برای ماشینی که روی آن اجرا می‌شوند تولید می‌کنند. چنین کامپایلرهایی، کامپایلرهای بومی نامیده می‌شوند.

## پیاده‌سازی کراس کامپایل برای LFS

> نکته
> 
> تمام بسته‌های کراس کامپایل شده در این کتاب از یک سیستم ساخت مبتنی بر autoconf استفاده می‌کنند. سیستم ساخت مبتنی بر autoconf انواع سیستم را به شکل cpu-vendor-kernel-os می‌پذیرد که به آن سه‌تایی سیستم گفته می‌شود. از آنجا که فیلد فروشنده اغلب بی‌ربط است، autoconf به شما اجازه می‌دهد آن را حذف کنید.
>یک خواننده زیرک ممکن است بپرسد چرا یک "سه‌تایی" به یک نام چهار جزئی اشاره دارد. فیلد kernel و فیلد os در ابتدا یک فیلد واحد "سیستم" بودند. چنین فرم سه فیلدی هنوز هم امروزه برای برخی سیستم‌ها معتبر است، به عنوان مثال، x86_64-unknown-freebsd. اما دو سیستم می‌توانند همان kernel را به اشتراک بگذارند و همچنان برای استفاده از همان سه‌تایی برای توصیف آنها بسیار متفاوت باشند. به عنوان مثال، Android که روی یک تلفن همراه اجرا می‌شود کاملاً با Ubuntu که روی یک سرور ARM64 اجرا می‌شود متفاوت است، حتی اگر هر دو روی همان نوع CPU (ARM64) اجرا شوند و از همان kernel (Linux) استفاده کنند.
>بدون یک لایه شبیه‌سازی، نمی‌توانید یک اجرایی برای یک سرور را روی یک تلفن همراه اجرا کنید یا برعکس. بنابراین فیلد "سیستم" به فیلدهای kernel و os تقسیم شده است تا این سیستم‌ها را به طور واضح مشخص کند. در مثال ما، سیستم Android به صورت aarch64-unknown-linux-android مشخص می‌شود و سیستم Ubuntu به صورت aarch64-unknown-linux-gnu مشخص می‌شود.
>کلمه "سه‌تایی" همچنان در واژگان جا افتاده است. یک راه ساده برای تعیین سه‌تایی سیستم شما اجرای اسکریپت config.guess است که همراه با منبع بسیاری از بسته‌ها می‌آید. منابع binutils را باز کنید، اسکریپت ./config.guess را اجرا کنید و خروجی را یادداشت کنید. به عنوان مثال، برای یک پردازنده 32 بیتی Intel خروجی i686-pc-linux-gnu خواهد بود. روی یک سیستم 64 بیتی x86_64-pc-linux-gnu خواهد بود. در اکثر سیستم‌های Linux دستور ساده‌تر gcc -dumpmachine اطلاعات مشابهی به شما خواهد داد.
>همچنین باید از نام لینکر پویای پلتفرم آگاه باشید که اغلب به عنوان بارگذار پویا شناخته می‌شود (نباید با لینکر استاندارد ld که بخشی از binutils است اشتباه گرفته شود). لینکر پویایی که توسط بسته glibc ارائه می‌شود کتابخانه‌های مشترک مورد نیاز یک برنامه را پیدا و بارگذاری می‌کند، برنامه را برای اجرا آماده می‌کند و سپس آن را اجرا می‌کند. نام لینکر پویا برای یک ماشین 32 بیتی Intel، ld-linux.so.2 است؛ روی سیستم‌های 64 بیتی ld-linux-x86-64.so.2 است. یک راه مطمئن برای تعیین نام لینکر پویا، بازرسی یک باینری تصادفی از سیستم میزبان با اجرای دستور زیر است: readelf -l <name of binary> | grep interpreter و یادداشت خروجی. مرجع معتبر پوشش دهنده تمام پلتفرم‌ها در یک صفحه ویکی Glibc است.

برای جعل یک کراس کامپایل در LFS، نام سه‌تایی میزبان با تغییر فیلد "فروشنده" در متغیر LFS_TGT کمی تنظیم می‌شود تا بگوید "lfs". ما همچنین از گزینه --with-sysroot هنگام ساخت کراس لینکر و کراس کامپایلر استفاده می‌کنیم تا به آنها بگوییم کجا فایل‌های مورد نیاز میزبان را پیدا کنند. این اطمینان حاصل می‌کند که هیچ یک از برنامه‌های دیگر ساخته شده در فصل 6 نمی‌توانند به کتابخانه‌های روی ماشین ساخت پیوند شوند. فقط دو مرحله اجباری است، به علاوه یک مرحله دیگر برای آزمون‌ها.

| مرحله | ساخت | میزبان | هدف | اقدام |
|-------|------|--------|------|-------|
| 1 | pc | pc | lfs | ساخت کراس کامپایلر cc1 با استفاده از cc-pc روی pc. |
| 2 | pc | lfs | ساخت کامپایلر cc-lfs با استفاده از cc1 روی pc |
| 3 | lfs | lfs | بازسازی و آزمایش cc-lfs با استفاده از cc-lfs روی lfs |

در جدول فوق، "روی pc" به معنای اجرای دستورات روی یک ماشین با استفاده از توزیع از قبل نصب شده است. "روی lfs" به معنای اجرای دستورات در یک محیط chroot است.

این هنوز پایان داستان نیست. زبان C صرفاً یک کامپایلر نیست؛ بلکه یک کتابخانه استاندارد نیز تعریف می‌کند. در این کتاب، از کتابخانه C گنو به نام glibc استفاده می‌شود (یک جایگزین به نام "musl" وجود دارد). این کتابخانه باید برای ماشین LFS کامپایل شود؛ یعنی با استفاده از کراس کامپایلر cc1. اما خود کامپایلر از یک کتابخانه داخلی استفاده می‌کند که زیرروال‌های پیچیده‌ای را برای توابعی که در مجموعه دستورالعمل‌های اسمبلر موجود نیستند، فراهم می‌کند. این کتابخانه داخلی libgcc نام دارد و باید با کتابخانه glibc پیوند داده شود تا کاملاً کاربردی باشد. علاوه بر این، کتابخانه استاندارد برای ++C (libstdc++) نیز باید با glibc پیوند داده شود. راه حل این مشکل مرغ و تخم مرغ این است که ابتدا یک libgcc تنزل یافته مبتنی بر cc1 بسازیم که برخی قابلیت‌ها مانند نخ‌ها و مدیریت استثناء را ندارد، و سپس glibc را با استفاده از این کامپایلر تنزل یافته بسازیم (خود glibc تنزل نمی‌یابد)، و همچنین libstdc++ را بسازیم. این کتابخانه آخر فاقد برخی از قابلیت‌های libgcc خواهد بود.

نتیجه پاراگراف قبلی این است که cc1 قادر به ساخت یک libstdc++ کاملاً کاربردی با libgcc تنزل یافته نیست، اما cc1 تنها کامپایلر موجود برای ساخت کتابخانه‌های C/C++ در مرحله 2 است. دو دلیل وجود دارد که ما بلافاصله از کامپایلر ساخته شده در مرحله 2، cc-lfs، برای ساخت این کتابخانه‌ها استفاده نمی‌کنیم.

- به طور کلی، cc-lfs نمی‌تواند روی pc (سیستم میزبان) اجرا شود. حتی اگر سه‌تایی‌های pc و lfs با یکدیگر سازگار باشند، یک اجرایی برای lfs باید به glibc-2.40 وابسته باشد؛ توزیع میزبان ممکن است از یک پیاده‌سازی متفاوت libc (به عنوان مثال، musl) یا یک نسخه قبلی glibc (به عنوان مثال، glibc-2.13) استفاده کند.

- حتی اگر cc-lfs بتواند روی pc اجرا شود، استفاده از آن روی pc خطر پیوند با کتابخانه‌های pc را ایجاد می‌کند، زیرا cc-lfs یک کامپایلر بومی است.

بنابراین وقتی gcc مرحله 2 را می‌سازیم، به سیستم ساخت دستور می‌دهیم که libgcc و libstdc++ را با cc1 بازسازی کند، اما libstdc++ را به جای ساخت قدیمی و تنزل یافته، به libgcc تازه بازسازی شده پیوند می‌دهیم. این کار libstdc++ بازسازی شده را کاملاً کاربردی می‌کند.

در فصل 8 (یا "مرحله 3")، تمام بسته‌های مورد نیاز برای سیستم LFS ساخته می‌شوند. حتی اگر یک بسته قبلاً در یک فصل قبلی در سیستم LFS نصب شده باشد، ما همچنان آن بسته را بازسازی می‌کنیم. دلیل اصلی بازسازی این بسته‌ها این است که آنها را پایدار کنیم: اگر ما یک بسته LFS را روی یک سیستم LFS تکمیل شده مجدداً نصب کنیم، محتوای نصب مجدد بسته باید همان محتوای همان بسته باشد که اولین بار در فصل 8 نصب شده است. بسته‌های موقتی نصب شده در فصل 6 یا فصل 7 نمی‌توانند این الزام را برآورده کنند، زیرا برخی از آنها بدون وابستگی‌های اختیاری ساخته می‌شوند، و autoconf نمی‌تواند برخی بررسی‌های ویژگی را در فصل 6 به دلیل کراس کامپایل انجام دهد، که باعث می‌شود بسته‌های موقتی فاقد ویژگی‌های اختیاری باشند یا از روال‌های کد زیربهینه استفاده کنند. علاوه بر این، یک دلیل جزئی برای بازسازی بسته‌ها، اجرای مجموعه‌های آزمون است.

## سایر جزئیات روند کار

کراس کامپایلر در یک دایرکتوری جداگانه $LFS/tools نصب خواهد شد، زیرا بخشی از سیستم نهایی نخواهد بود.
Binutils اول نصب می‌شود زیرا پیکربندی هر دو gcc و glibc آزمایش‌های مختلفی روی اسمبلر و لینکر انجام می‌دهند تا مشخص کنند کدام ویژگی‌های نرم‌افزاری را فعال یا غیرفعال کنند. این مهم‌تر از آن چیزی است که ممکن است در ابتدا تصور کنید. یک gcc یا glibc نادرست پیکربندی شده می‌تواند منجر به یک زنجیره ابزار به طور ظریف شکسته شود، که تأثیر چنین شکستگی ممکن است تا نزدیک پایان ساخت یک توزیع کامل نمایان نشود. یک شکست در مجموعه آزمون معمولاً این خطا را قبل از انجام کار اضافی زیاد برجسته می‌کند.

Binutils اسمبلر و لینکر خود را در دو مکان نصب می‌کند، $LFS/tools/bin و $LFS/tools/$LFS_TGT/bin. ابزارها در یک مکان به صورت سخت به مکان دیگر پیوند داده شده‌اند. یک جنبه مهم لینکر، ترتیب جستجوی کتابخانه آن است. اطلاعات دقیق را می‌توان با ارسال پرچم --verbose به ld به دست آورد. به عنوان مثال، $LFS_TGT-ld --verbose | grep SEARCH مسیرهای جستجوی فعلی و ترتیب آنها را نشان خواهد داد. (توجه داشته باشید که این مثال را فقط زمانی که به عنوان کاربر lfs وارد شده‌اید می‌توان اجرا کرد. اگر بعداً به این صفحه برگشتید، $LFS_TGT-ld را با ld جایگزین کنید).

بسته بعدی که نصب می‌شود gcc است. نمونه‌ای از آنچه می‌توان در طول اجرای پیکربندی آن دید:

```
checking what assembler to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld
```

این به دلایلی که در بالا ذکر شد مهم است. همچنین نشان می‌دهد که اسکریپت پیکربندی gcc دایرکتوری‌های PATH را برای یافتن ابزارهایی که باید استفاده شود جستجو نمی‌کند. با این حال، در طول عملیات واقعی خود gcc، لزوماً از همان مسیرهای جستجو استفاده نمی‌شود. برای فهمیدن اینکه gcc از کدام لینکر استاندارد استفاده خواهد کرد، اجرا کنید: $LFS_TGT-gcc -print-prog-name=ld. (دوباره، اگر بعداً به این برمی‌گردید، پیشوند $LFS_TGT- را حذف کنید.)

اطلاعات دقیق را می‌توان با ارسال گزینه خط فرمان -v به gcc هنگام کامپایل یک برنامه به دست آورد. به عنوان مثال، $LFS_TGT-gcc -v example.c (یا بدون $LFS_TGT- اگر بعداً برمی‌گردید) اطلاعات دقیقی در مورد مراحل پیش‌پردازنده، کامپایل و اسمبلی، از جمله مسیرهای جستجوی gcc برای هدرهای شامل شده و ترتیب آنها نشان خواهد داد.

بعدی: هدرهای API لینوکس پاکسازی شده. اینها به کتابخانه استاندارد C (glibc) اجازه می‌دهند با ویژگی‌هایی که هسته لینوکس فراهم خواهد کرد ارتباط برقرار کند.

بعد از آن glibc می‌آید. مهم‌ترین ملاحظات برای ساخت glibc کامپایلر، ابزارهای باینری و هدرهای هسته هستند. کامپایلر و ابزارهای باینری معمولاً مشکلی ندارند زیرا glibc همیشه از آنهایی استفاده می‌کند که مربوط به پارامتر --host ارسال شده به اسکریپت پیکربندی آن هستند؛ به عنوان مثال، در مورد ما، کامپایلر $LFS_TGT-gcc خواهد بود و ابزار readelf $LFS_TGT-readelf خواهد بود. هدرهای هسته می‌توانند کمی پیچیده‌تر باشند. بنابراین، ما هیچ ریسکی نمی‌کنیم و از سوئیچ پیکربندی موجود برای اجبار انتخاب صحیح استفاده می‌کنیم. پس از اجرای پیکربندی، محتویات فایل config.make را در دایرکتوری ساخت برای تمام جزئیات مهم بررسی کنید. این موارد جنبه مهمی از بسته glibc را برجسته می‌کنند - از نظر ماشین ساخت خود بسیار خودکفا است و معمولاً به پیش‌فرض‌های زنجیره ابزار متکی نیست.

همانطور که در بالا ذکر شد، کتابخانه استاندارد ++C بعداً کامپایل می‌شود، و در فصل 6 با برنامه‌های دیگری که باید برای شکستن وابستگی‌های دایره‌ای در زمان ساخت به صورت متقابل کامپایل شوند دنبال می‌شود. مرحله نصب تمام این بسته‌ها از متغیر DESTDIR برای اجبار نصب در سیستم فایل LFS استفاده می‌کند.

در پایان فصل 6، کامپایلر بومی LFS نصب می‌شود. ابتدا binutils-pass2 در همان دایرکتوری DESTDIR مانند سایر برنامه‌ها ساخته می‌شود، سپس دومین گذر gcc ساخته می‌شود و برخی از کتابخانه‌های غیر حیاتی حذف می‌شوند. به دلیل منطق عجیبی در اسکریپت پیکربندی gcc، CC_FOR_TARGET به cc تبدیل می‌شود وقتی میزبان همان هدف است، اما با سیستم ساخت متفاות است. به همین دلیل است که CC_FOR_TARGET=$LFS_TGT-gcc به صراحت به عنوان یکی از گزینه‌های پیکربندی اعلام می‌شود.

با ورود به محیط chroot در فصل 7، نصب‌های موقت برنامه‌های مورد نیاز برای عملکرد صحیح زنجیره ابزار انجام می‌شود. از این نقطه به بعد، زنجیره ابزار اصلی خودکفا و خودمیزبان است.

در فصل 8، نسخه‌های نهایی تمام بسته‌های مورد نیاز برای یک سیستم کاملاً کاربردی ساخته، آزمایش و نصب می‌شوند.

# دستورالعمل‌های کلی کامپایل

## احتیاط
در طول یک چرخه توسعه LFS، دستورالعمل‌های کتاب اغلب برای تطبیق با به‌روزرسانی یک بسته یا بهره‌برداری از ویژگی‌های جدید بسته‌های به‌روز شده تغییر می‌کنند. ترکیب دستورالعمل‌های نسخه‌های مختلف کتاب LFS می‌تواند باعث خرابی‌های ظریفی شود. این نوع مشکل معمولاً نتیجه استفاده مجدد از اسکریپت‌هایی است که برای انتشار قبلی LFS ایجاد شده‌اند. چنین استفاده مجددی به شدت توصیه نمی‌شود. اگر به هر دلیلی از اسکریپت‌های مربوط به انتشار قبلی LFS استفاده می‌کنید، باید بسیار مراقب باشید تا اسکریپت‌ها را با نسخه فعلی کتاب LFS مطابقت دهید.

در اینجا مواردی وجود دارد که باید درباره ساخت هر بسته بدانید:

- چندین بسته قبل از کامپایل وصله می‌شوند، اما فقط زمانی که وصله برای رفع مشکلی لازم باشد. یک وصله اغلب هم در فصل فعلی و هم در فصل بعدی مورد نیاز است، اما گاهی اوقات، وقتی همان بسته بیش از یک بار ساخته می‌شود، وصله بلافاصله مورد نیاز نیست. بنابراین، اگر به نظر می‌رسد دستورالعمل‌های مربوط به یک وصله دانلود شده وجود ندارد، نگران نباشید. پیام‌های هشدار درباره آفست یا فاز نیز ممکن است هنگام اعمال یک وصله مشاهده شود. نگران این هشدارها نباشید؛ وصله همچنان با موفقیت اعمال شده است.

- در حین کامپایل اکثر بسته‌ها، برخی هشدارها روی صفحه نمایش ظاهر می‌شوند. این‌ها طبیعی هستند و می‌توان به راحتی از آنها چشم‌پوشی کرد. این هشدارها معمولاً درباره استفاده منسوخ شده، اما نه نامعتبر، از نحو C یا ++C هستند. استانداردهای C نسبتاً اغلب تغییر می‌کنند و برخی از بسته‌ها هنوز به‌روز نشده‌اند. این مشکل جدی نیست، اما باعث ظاهر شدن هشدارها می‌شود.

- یک بار دیگر بررسی کنید که متغیر محیطی LFS به درستی تنظیم شده باشد:
  ```
  echo $LFS
  ```
  اطمینان حاصل کنید که خروجی مسیر نقطه اتصال پارتیشن LFS را نشان می‌دهد، که در مثال ما /mnt/lfs است.

- در نهایت، باید بر دو مورد مهم تأکید کرد:

## مهم
دستورالعمل‌های ساخت فرض می‌کنند که الزامات سیستم میزبان، از جمله پیوندهای نمادین، به درستی تنظیم شده‌اند:

- bash پوسته مورد استفاده است.
- sh یک پیوند نمادین به bash است.
- /usr/bin/awk یک پیوند نمادین به gawk است.
- /usr/bin/yacc یک پیوند نمادین به bison، یا به یک اسکریپت کوچک که bison را اجرا می‌کند، است.

## مهم
در اینجا خلاصه‌ای از فرآیند ساخت آمده است:

1. تمام منابع و وصله‌ها را در پوشه‌ای قرار دهید که از محیط chroot قابل دسترسی باشد، مانند /mnt/lfs/sources/.

2. به پوشه /mnt/lfs/sources/ تغییر مسیر دهید.

3. برای هر بسته:
   a. با استفاده از برنامه tar، بسته‌ای را که باید ساخته شود استخراج کنید. در فصل 5 و فصل 6، اطمینان حاصل کنید که هنگام استخراج بسته، کاربر lfs هستید. از هیچ روشی به جز دستور tar برای استخراج کد منبع استفاده نکنید. به ویژه، استفاده از دستور cp -R برای کپی کردن درخت کد منبع به جای دیگر می‌تواند مهرهای زمانی را در درخت منبع از بین ببرد و باعث شکست ساخت شود.
   
   b. به پوشه‌ای که هنگام استخراج بسته ایجاد شده تغییر مسیر دهید.
   
   c. دستورالعمل‌های ساخت بسته را دنبال کنید.
   
   d. پس از اتمام ساخت، به پوشه منابع برگردید.
   
   e. پوشه منبع استخراج شده را حذف کنید مگر اینکه دستور دیگری داده شده باشد.
