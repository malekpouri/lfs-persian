# فصل ۷. ورود به Chroot و ساخت ابزارهای موقتی اضافی

## ۷.۱. مقدمه

این فصل نشان می‌دهد چگونه آخرین قطعات گمشده سیستم موقتی را بسازیم: ابزارهایی که برای ساخت بسته‌های مختلف مورد نیاز هستند. حالا که تمام وابستگی‌های دوری حل شده‌اند، می‌توان از یک محیط "chroot"، که کاملاً از سیستم عامل میزبان جدا شده است (به جز هسته در حال اجرا)، برای ساخت استفاده کرد.

برای عملکرد صحیح محیط ایزوله، باید ارتباطی با هسته در حال اجرا برقرار شود. این کار از طریق سیستم فایل‌های مجازی هسته انجام می‌شود، که قبل از ورود به محیط chroot نصب خواهند شد. می‌توانید با اجرای دستور `findmnt` بررسی کنید که آیا آنها نصب شده‌اند یا خیر.

تا بخش ۷.۴ "ورود به محیط Chroot"، دستورات باید به عنوان کاربر root، با متغیر LFS تنظیم شده، اجرا شوند. پس از ورود به chroot، تمام دستورات به عنوان root اجرا می‌شوند، خوشبختانه بدون دسترسی به سیستم عامل کامپیوتری که LFS را روی آن ساخته‌اید. با این حال مراقب باشید، زیرا با دستورات اشتباه به راحتی می‌توان کل سیستم LFS را نابود کرد.

## ۷.۲. تغییر مالکیت

**نکته**: دستورات باقیمانده این کتاب باید در حالی که به عنوان کاربر root وارد شده‌اید اجرا شوند، نه دیگر به عنوان کاربر lfs. همچنین، دوباره بررسی کنید که $LFS در محیط root تنظیم شده باشد.

در حال حاضر، کل ساختار دایرکتوری در $LFS متعلق به کاربر lfs است، کاربری که فقط در سیستم میزبان وجود دارد. اگر دایرکتوری‌ها و فایل‌های زیر $LFS همانطور که هستند نگه داشته شوند، متعلق به یک شناسه کاربری بدون حساب مربوطه خواهند بود. این خطرناک است زیرا یک حساب کاربری که بعداً ایجاد می‌شود ممکن است همان شناسه کاربری را دریافت کند و مالک تمام فایل‌های زیر $LFS شود، در نتیجه این فایل‌ها را در معرض دستکاری‌های احتمالی بدخواهانه قرار می‌دهد.

برای رفع این مشکل، مالکیت دایرکتوری‌های $LFS/* را به کاربر root تغییر دهید با اجرای دستور زیر:

```bash
chown --from lfs -R root:root $LFS/{usr,lib,var,etc,bin,sbin,tools}
case $(uname -m) in
x86_64) chown --from lfs -R root:root $LFS/lib64 ;;
esac
```

## ۷.۳. آماده‌سازی سیستم فایل‌های مجازی هسته

برنامه‌های اجرا شده در فضای کاربر از سیستم فایل‌های مختلفی که توسط هسته ایجاد شده‌اند استفاده می‌کنند تا با خود هسته ارتباط برقرار کنند. این سیستم فایل‌ها مجازی هستند: هیچ فضای دیسکی برای آنها استفاده نمی‌شود. محتوای این سیستم فایل‌ها در حافظه قرار دارد. این سیستم فایل‌ها باید در درخت دایرکتوری $LFS نصب شوند تا برنامه‌ها بتوانند آنها را در محیط chroot پیدا کنند.

ابتدا با ایجاد دایرکتوری‌هایی که این سیستم فایل‌های مجازی روی آنها نصب خواهند شد شروع کنید:

```bash
mkdir -pv $LFS/{dev,proc,sys,run}
```

### ۷.۳.۱. نصب و پر کردن /dev

در طول یک راه‌اندازی عادی سیستم LFS، هسته به طور خودکار سیستم فایل devtmpfs را روی دایرکتوری /dev نصب می‌کند؛ هسته گره‌های دستگاه را روی آن سیستم فایل مجازی در طول فرآیند راه‌اندازی، یا زمانی که یک دستگاه برای اولین بار شناسایی یا دسترسی پیدا می‌کند، ایجاد می‌کند. دیمون udev ممکن است مالکیت یا مجوزهای گره‌های دستگاه ایجاد شده توسط هسته را تغییر دهد، و گره‌های دستگاه جدید یا پیوندهای نمادین ایجاد کند، تا کار نگهدارندگان توزیع و مدیران سیستم را آسان کند. (برای جزئیات به بخش ۹.۳.۲.۲ "ایجاد گره دستگاه" مراجعه کنید.) اگر هسته میزبان از devtmpfs پشتیبانی کند، می‌توانیم به سادگی یک devtmpfs را در $LFS/dev نصب کنیم و به هسته اعتماد کنیم که آن را پر کند.

اما برخی از هسته‌های میزبان فاقد پشتیبانی از devtmpfs هستند؛ این توزیع‌های میزبان از روش‌های مختلفی برای ایجاد محتوای /dev استفاده می‌کنند. بنابراین تنها راه مستقل از میزبان برای پر کردن دایرکتوری $LFS/dev، نصب bind دایرکتوری /dev سیستم میزبان است. یک نصب bind نوع خاصی از نصب است که یک زیر درخت دایرکتوری یا یک فایل را در مکان دیگری قابل مشاهده می‌کند. از دستور زیر برای انجام این کار استفاده کنید.

```bash
mount -v --bind /dev $LFS/dev
```

### ۷.۳.۲. نصب سیستم فایل‌های مجازی هسته

حالا سیستم فایل‌های مجازی هسته باقیمانده را نصب کنید:

```bash
mount -vt devpts devpts -o gid=5,mode=0620 $LFS/dev/pts
mount -vt proc proc $LFS/proc
mount -vt sysfs sysfs $LFS/sys
mount -vt tmpfs tmpfs $LFS/run
```

معنی گزینه‌های نصب برای devpts:

**gid=5**
این اطمینان می‌دهد که تمام گره‌های دستگاه ایجاد شده توسط devpts متعلق به شناسه گروه 5 هستند. این شناسه‌ای است که بعداً برای گروه tty استفاده خواهیم کرد. ما از شناسه گروه به جای نام استفاده می‌کنیم، زیرا سیستم میزبان ممکن است از شناسه متفاوتی برای گروه tty خود استفاده کند.

**mode=0620**
این اطمینان می‌دهد که تمام گره‌های دستگاه ایجاد شده توسط devpts دارای مجوز 0620 هستند (قابل خواندن و نوشتن توسط کاربر، قابل نوشتن توسط گروه). همراه با گزینه بالا، این اطمینان می‌دهد که devpts گره‌های دستگاهی ایجاد می‌کند که الزامات grantpt() را برآورده می‌کنند، به این معنی که باینری کمکی pt_chown از Glibc (که به طور پیش‌فرض نصب نشده است) ضروری نیست.

در برخی سیستم‌های میزبان، /dev/shm یک پیوند نمادین به یک دایرکتوری است، معمولاً /run/shm. tmpfs /run در بالا نصب شد بنابراین در این مورد فقط نیاز به ایجاد یک دایرکتوری با مجوزهای صحیح است.

در سیستم‌های میزبان دیگر /dev/shm یک نقطه نصب برای یک tmpfs است. در آن صورت نصب /dev در بالا فقط /dev/shm را به عنوان یک دایرکتوری در محیط chroot ایجاد می‌کند. در این وضعیت باید به صراحت یک tmpfs نصب کنیم:

```bash
if [ -h $LFS/dev/shm ]; then
  install -v -d -m 1777 $LFS$(realpath /dev/shm)
else
  mount -vt tmpfs -o nosuid,nodev tmpfs $LFS/dev/shm
fi
```

## ۷.۴. ورود به محیط Chroot

حالا که تمام بسته‌هایی که برای ساخت بقیه ابزارهای مورد نیاز لازم هستند در سیستم قرار دارند، وقت آن است که وارد محیط chroot شویم و نصب ابزارهای موقتی را تمام کنیم. این محیط همچنین برای نصب سیستم نهایی استفاده خواهد شد. به عنوان کاربر root، دستور زیر را برای ورود به محیطی که در حال حاضر فقط با ابزارهای موقتی پر شده است اجرا کنید:

```bash
chroot "$LFS" /usr/bin/env -i \
    HOME=/root \
    TERM="$TERM" \
    PS1='(lfs chroot) \u:\w\$ ' \
    PATH=/usr/bin:/usr/sbin \
    MAKEFLAGS="-j$(nproc)" \
    TESTSUITEFLAGS="-j$(nproc)" \
    /bin/bash --login
```
اگر نمی‌خواهید از تمام هسته‌های منطقی موجود استفاده کنید، `$(nproc)` را با تعداد هسته‌های منطقی که می‌خواهید برای ساخت بسته‌ها در این فصل و فصل‌های بعدی استفاده کنید، جایگزین کنید. آزمون‌های برخی از بسته‌ها (به ویژه Autoconf، Libtool و Tar) در فصل ۸ تحت تأثیر `MAKEFLAGS` قرار نمی‌گیرند، آنها به جای آن از یک متغیر محیطی `TESTSUITEFLAGS` استفاده می‌کنند. ما آن را نیز اینجا برای اجرای این آزمون‌ها با چندین هسته تنظیم می‌کنیم.

گزینه `-i` داده شده به دستور **env** تمام متغیرها را در محیط chroot پاک می‌کند. پس از آن، فقط متغیرهای `HOME`، `TERM`، `PS1` و `PATH` دوباره تنظیم می‌شوند. ساختار `TERM=$TERM` متغیر `TERM` را داخل chroot به همان مقدار خارج از chroot تنظیم می‌کند. این متغیر برای عملکرد صحیح برنامه‌هایی مانند **vim** و **less** مورد نیاز است. اگر متغیرهای دیگری مورد نیاز باشند، مانند `CFLAGS` یا `CXXFLAGS`، این مکان مناسبی برای تنظیم آنهاست.

از این نقطه به بعد، نیازی به استفاده از متغیر `LFS` نیست زیرا تمام کارها به سیستم فایل LFS محدود خواهد شد؛ دستور **chroot** پوسته Bash را با دایرکتوری ریشه (`/`) تنظیم شده به `$LFS` اجرا می‌کند.

توجه کنید که `/tools/bin` در `PATH` نیست. این به این معنی است که toolchain متقاطع دیگر استفاده نخواهد شد.

همچنین توجه کنید که پیام bash خواهد گفت `I have no name!`. این طبیعی است زیرا فایل `/etc/passwd` هنوز ایجاد نشده است.

**نکته**: مهم است که تمام دستورات در بقیه این فصل و فصل‌های بعدی از درون محیط chroot اجرا شوند. اگر به هر دلیلی این محیط را ترک کردید (مثلاً راه‌اندازی مجدد)، اطمینان حاصل کنید که سیستم فایل‌های مجازی هسته همانطور که در بخش ۷.۳.۱، "نصب و پر کردن /dev" و بخش ۷.۳.۲، "نصب سیستم فایل‌های مجازی هسته" توضیح داده شده، نصب شده‌اند و قبل از ادامه نصب دوباره وارد chroot شوید.

## ۷.۵. ایجاد دایرکتوری‌ها

زمان آن رسیده است که ساختار کامل دایرکتوری را در سیستم فایل LFS ایجاد کنیم.

**نکته**: برخی از دایرکتوری‌های ذکر شده در این بخش ممکن است قبلاً با دستورالعمل‌های صریح یا هنگام نصب برخی بسته‌ها ایجاد شده باشند. آنها برای کامل بودن در زیر تکرار شده‌اند.

برخی دایرکتوری‌های سطح ریشه را که در مجموعه محدود مورد نیاز در فصل‌های قبلی نیستند، با اجرای دستور زیر ایجاد کنید:

```bash
mkdir -pv /{boot,home,mnt,opt,srv}
```

مجموعه مورد نیاز از زیردایرکتوری‌ها را زیر سطح ریشه با اجرای دستورات زیر ایجاد کنید:

```bash
mkdir -pv /etc/{opt,sysconfig}
mkdir -pv /lib/firmware
mkdir -pv /media/{floppy,cdrom}
mkdir -pv /usr/{,local/}{include,src}
mkdir -pv /usr/lib/locale
mkdir -pv /usr/local/{bin,lib,sbin}
mkdir -pv /usr/{,local/}share/{color,dict,doc,info,locale,man}
mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}
mkdir -pv /usr/{,local/}share/man/man{1..8}
mkdir -pv /var/{cache,local,log,mail,opt,spool}
mkdir -pv /var/lib/{color,misc,locate}

ln -sfv /run /var/run
ln -sfv /run/lock /var/lock

install -dv -m 0750 /root
install -dv -m 1777 /tmp /var/tmp
```

دایرکتوری‌ها به طور پیش‌فرض با مجوز 755 ایجاد می‌شوند، اما این در همه جا مطلوب نیست. در دستورات بالا، دو تغییر انجام می‌شود - یکی در دایرکتوری خانه کاربر `root`، و دیگری در دایرکتوری‌های فایل‌های موقت.

اولین تغییر حالت اطمینان می‌دهد که هر کسی نمی‌تواند وارد دایرکتوری `/root` شود - درست مانند یک کاربر عادی که با دایرکتوری خانه خود این کار را انجام می‌دهد. دومین تغییر حالت اطمینان می‌دهد که هر کاربری می‌تواند در دایرکتوری‌های `/tmp` و `/var/tmp` بنویسد، اما نمی‌تواند فایل‌های کاربر دیگری را از آنها حذف کند. این آخری توسط به اصطلاح "بیت چسبنده" ممنوع شده است، بالاترین بیت (1) در ماسک بیت 1777.

### ۷.۵.۱. یادداشت انطباق با FHS

این درخت دایرکتوری بر اساس استاندارد سلسله مراتب سیستم فایل (FHS) است (در دسترس در https://refspecs.linuxfoundation.org/fhs.shtml). FHS همچنین وجود اختیاری دایرکتوری‌های اضافی مانند `/usr/local/games` و `/usr/share/games` را مشخص می‌کند. در LFS، ما فقط دایرکتوری‌هایی را که واقعاً ضروری هستند ایجاد می‌کنیم. با این حال، اگر مایل هستید، آزادانه دایرکتوری‌های بیشتری ایجاد کنید.

**هشدار**: FHS وجود دایرکتوری `/usr/lib64` را الزامی نمی‌کند، و ویراستاران LFS تصمیم گرفته‌اند از آن استفاده نکنند. برای اینکه دستورالعمل‌های LFS و BLFS به درستی کار کنند، ضروری است که این دایرکتوری وجود نداشته باشد. هر از گاهی باید بررسی کنید که وجود ندارد، زیرا ایجاد ناخواسته آن آسان است و این احتمالاً سیستم شما را خراب خواهد کرد.

## ۷.۶. ایجاد فایل‌ها و پیوندهای نمادین ضروری

از نظر تاریخی، لینوکس فهرستی از سیستم فایل‌های نصب شده را در فایل /etc/mtab نگهداری می‌کرد. هسته‌های مدرن این فهرست را به صورت داخلی نگهداری می‌کنند و آن را از طریق سیستم فایل /proc به کاربر نمایش می‌دهند. برای رضایت برنامه‌هایی که انتظار دارند /etc/mtab را پیدا کنند، پیوند نمادین زیر را ایجاد کنید:

```bash
ln -sv /proc/self/mounts /etc/mtab
```

یک فایل /etc/hosts اولیه برای استفاده در برخی آزمون‌ها و همچنین در یکی از فایل‌های پیکربندی Perl ایجاد کنید:

```bash
cat > /etc/hosts << EOF
127.0.0.1  localhost $(hostname)
::1        localhost
EOF
```

برای اینکه کاربر root بتواند وارد سیستم شود و نام "root" شناخته شود، باید ورودی‌های مربوطه در فایل‌های /etc/passwd و /etc/group وجود داشته باشد.

فایل /etc/passwd را با اجرای دستور زیر ایجاد کنید:

```bash
cat > /etc/passwd << "EOF"
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/usr/bin/false
daemon:x:6:6:Daemon User:/dev/null:/usr/bin/false
messagebus:x:18:18:D-Bus Message Daemon User:/run/dbus:/usr/bin/false
uuidd:x:80:80:UUID Generation Daemon User:/dev/null:/usr/bin/false
nobody:x:65534:65534:Unprivileged User:/dev/null:/usr/bin/false
EOF
```

رمز عبور واقعی برای root بعداً تنظیم خواهد شد.

فایل /etc/group را با اجرای دستور زیر ایجاد کنید:

```bash
cat > /etc/group << "EOF"
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11:
video:x:12:
utmp:x:13:
cdrom:x:15:
adm:x:16:
messagebus:x:18:
input:x:24:
mail:x:34:
kvm:x:61:
uuidd:x:80:
wheel:x:97:
users:x:999:
nogroup:x:65534:
EOF
```

گروه‌های ایجاد شده بخشی از هیچ استانداردی نیستند - آنها گروه‌هایی هستند که تا حدی بر اساس نیازهای پیکربندی Udev در فصل ۹ و تا حدی بر اساس قراردادهای رایج استفاده شده توسط تعدادی از توزیع‌های لینوکس موجود تصمیم گرفته شده‌اند. علاوه بر این، برخی از آزمون‌ها به کاربران یا گروه‌های خاصی متکی هستند. استاندارد پایه لینوکس (LSB، در دسترس در https://refspecs.linuxfoundation.org/lsb.shtml) فقط توصیه می‌کند که علاوه بر گروه root با شناسه گروه (GID) 0، یک گروه bin با GID 1 وجود داشته باشد. GID 5 به طور گسترده برای گروه tty استفاده می‌شود، و عدد 5 همچنین در /etc/fstab برای سیستم فایل devpts استفاده می‌شود. تمام نام‌ها و GID‌های گروه دیگر را می‌توان آزادانه توسط مدیر سیستم انتخاب کرد زیرا برنامه‌های خوب نوشته شده به شماره‌های GID وابسته نیستند، بلکه از نام گروه استفاده می‌کنند.

شناسه 65534 توسط هسته برای NFS و فضای نام‌های کاربری جداگانه برای کاربران و گروه‌های نگاشت نشده استفاده می‌شود (آنها روی سرور NFS یا فضای نام کاربری والد وجود دارند، اما "در ماشین محلی یا در فضای نام جداگانه وجود ندارند"). ما nobody و nogroup را اختصاص می‌دهیم تا از یک شناسه بدون نام جلوگیری کنیم. اما توزیع‌های دیگر ممکن است با این شناسه به طور متفاوتی رفتار کنند، بنابراین هر برنامه قابل حمل نباید به این تخصیص وابسته باشد.

برخی از بسته‌ها به یک locale نیاز دارند.

```bash
localedef -i C -f UTF-8 C.UTF-8
```

برخی از آزمون‌ها در فصل ۸ به یک کاربر عادی نیاز دارند. ما این کاربر را اینجا اضافه می‌کنیم و در پایان آن فصل این حساب را حذف می‌کنیم.

```bash
echo "tester:x:101:101::/home/tester:/bin/bash" >> /etc/passwd
echo "tester:x:101:" >> /etc/group
install -o tester -d /home/tester
```

برای حذف پیام "I have no name!"، یک پوسته جدید را شروع کنید. از آنجا که فایل‌های /etc/passwd و /etc/group ایجاد شده‌اند، حل نام کاربر و نام گروه اکنون کار خواهد کرد:

```bash
exec /usr/bin/bash --login
```

برنامه‌های login، agetty و init (و دیگران) از تعدادی فایل ثبت برای ثبت اطلاعاتی مانند اینکه چه کسی و چه زمانی وارد سیستم شده است استفاده می‌کنند. با این حال، این برنامه‌ها اگر فایل‌های ثبت از قبل وجود نداشته باشند، در آنها نمی‌نویسند. فایل‌های ثبت را مقداردهی اولیه کنید و مجوزهای مناسب را به آنها بدهید:

```bash
touch /var/log/{btmp,lastlog,faillog,wtmp}
chgrp -v utmp /var/log/lastlog
chmod -v 664  /var/log/lastlog
chmod -v 600  /var/log/btmp
```

فایل /var/log/wtmp تمام ورودها و خروج‌ها را ثبت می‌کند. فایل /var/log/lastlog آخرین ورود هر کاربر را ثبت می‌کند. فایل /var/log/faillog تلاش‌های ناموفق ورود را ثبت می‌کند. فایل /var/log/btmp تلاش‌های ورود نامعتبر را ثبت می‌کند.

>**نکته**: فایل /run/utmp کاربرانی را که در حال حاضر وارد سیستم شده‌اند ثبت می‌کند. این فایل به صورت پویا در اسکریپت‌های راه‌اندازی ایجاد می‌شود.

>**نکته**: فایل‌های utmp، wtmp، btmp و lastlog از اعداد صحیح 32 بیتی برای مهرهای زمانی استفاده می‌کنند و پس از سال 2038 به طور اساسی خراب خواهند شد. بسیاری از بسته‌ها استفاده از آنها را متوقف کرده‌اند و بسته‌های دیگر نیز قصد دارند استفاده از آنها را متوقف کنند. احتمالاً بهتر است آنها را منسوخ شده در نظر بگیرید.
# ۷.۷. Gettext-0.22.5

بسته Gettext شامل ابزارهایی برای بین‌المللی‌سازی و محلی‌سازی است. این ابزارها به برنامه‌ها اجازه می‌دهند با پشتیبانی از زبان بومی (NLS) کامپایل شوند، که به آنها امکان می‌دهد پیام‌ها را به زبان بومی کاربر نمایش دهند.

**زمان تقریبی ساخت:** 1.1 SBU
**فضای دیسک مورد نیاز:** 321 مگابایت

## ۷.۷.۱. نصب Gettext

برای مجموعه ابزارهای موقتی ما، فقط نیاز به نصب سه برنامه از Gettext داریم.

Gettext را برای کامپایل آماده کنید:

```bash
./configure --disable-shared
```

**معنی گزینه پیکربندی:**
`--disable-shared`
ما در حال حاضر نیازی به نصب هیچ یک از کتابخانه‌های اشتراکی Gettext نداریم، بنابراین نیازی به ساخت آنها نیست.

بسته را کامپایل کنید:

```bash
make
```

برنامه‌های **msgfmt**، **msgmerge** و **xgettext** را نصب کنید:

```bash
cp -v gettext-tools/src/{msgfmt,msgmerge,xgettext} /usr/bin
```

جزئیات مربوط به این بسته در بخش 8.33.2، "محتویات Gettext" قرار دارد.

# ۷.۸. Bison-3.8.2

بسته Bison شامل یک مولد تجزیه‌کننده است.

**زمان تقریبی ساخت:** 0.2 SBU
**فضای دیسک مورد نیاز:** 57 مگابایت

## ۷.۸.۱. نصب Bison

Bison را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr \
            --docdir=/usr/share/doc/bison-3.8.2
```

**معنی گزینه جدید پیکربندی:**
`--docdir=/usr/share/doc/bison-3.8.2`
این به سیستم ساخت می‌گوید که مستندات bison را در یک دایرکتوری نسخه‌دار نصب کند.

بسته را کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

```bash
make install
```

جزئیات مربوط به این بسته در بخش 8.34.2، "محتویات Bison" قرار دارد.

# ۷.۹. Perl-5.40.0

بسته Perl شامل زبان استخراج و گزارش‌دهی عملی است.

**زمان تقریبی ساخت:** 0.6 SBU
**فضای دیسک مورد نیاز:** 285 مگابایت

## ۷.۹.۱. نصب Perl

Perl را برای کامپایل آماده کنید:

```bash
sh Configure -des                                         \
             -D prefix=/usr                               \
             -D vendorprefix=/usr                         \
             -D useshrplib                                \
             -D privlib=/usr/lib/perl5/5.40/core_perl     \
             -D archlib=/usr/lib/perl5/5.40/core_perl     \
             -D sitelib=/usr/lib/perl5/5.40/site_perl     \
             -D sitearch=/usr/lib/perl5/5.40/site_perl    \
             -D vendorlib=/usr/lib/perl5/5.40/vendor_perl \
             -D vendorarch=/usr/lib/perl5/5.40/vendor_perl
```

**معنی گزینه‌های Configure:**
`-des`
این ترکیبی از سه گزینه است: -d از پیش‌فرض‌ها برای همه موارد استفاده می‌کند؛ -e اتمام تمام وظایف را تضمین می‌کند؛ -s خروجی غیرضروری را ساکت می‌کند.
`-D vendorprefix=/usr`
این اطمینان می‌دهد که **perl** می‌داند چگونه به بسته‌ها بگوید که باید ماژول‌های Perl خود را کجا نصب کنند.
`-D useshrplib`
`libperl` مورد نیاز برخی از ماژول‌های Perl را به عنوان یک کتابخانه اشتراکی به جای یک کتابخانه استاتیک می‌سازد.
`-D privlib,-D archlib,-D sitelib,...`
این تنظیمات مشخص می‌کنند که Perl ماژول‌های نصب شده را کجا جستجو کند. ویراستاران LFS تصمیم گرفتند آنها را در یک ساختار دایرکتوری بر اساس نسخه MAJOR.MINOR از Perl (5.40) قرار دهند که امکان ارتقاء Perl به نسخه‌های وصله جدیدتر را بدون نیاز به نصب مجدد تمام ماژول‌ها فراهم می‌کند.

بسته را کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

```bash
make install
```

جزئیات مربوط به این بسته در بخش 8.43.2، "محتویات Perl" قرار دارد.

# ۷.۱۰. Python-3.12.5

بسته Python 3 شامل محیط توسعه Python است. این برای برنامه‌نویسی شی‌گرا، نوشتن اسکریپت‌ها، پیش‌نمونه‌سازی برنامه‌های بزرگ و توسعه برنامه‌های کامل مفید است. Python یک زبان برنامه‌نویسی تفسیری است.

**زمان تقریبی ساخت:** 0.4 SBU
**فضای دیسک مورد نیاز:** 603 مگابایت

## ۷.۱۰.۱. نصب Python

**نکته**
دو فایل بسته وجود دارد که نام آنها با پیشوند "python" شروع می‌شود. فایلی که باید استخراج شود `Python-3.12.5.tar.xz` است (توجه کنید که حرف اول بزرگ است).

Python را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr   \
            --enable-shared \
            --without-ensurepip
```

**معنی گزینه‌های پیکربندی:**
`--enable-shared`
این سوئیچ از نصب کتابخانه‌های استاتیک جلوگیری می‌کند.
`--without-ensurepip`
این سوئیچ نصب‌کننده بسته Python را غیرفعال می‌کند، که در این مرحله مورد نیاز نیست.

بسته را کامپایل کنید:

```bash
make
```

**نکته**
برخی از ماژول‌های Python 3 در حال حاضر قابل ساخت نیستند زیرا وابستگی‌ها هنوز نصب نشده‌اند. برای ماژول `ssl`، پیام `Python requires a OpenSSL 1.1.1 or newer` نمایش داده می‌شود. این پیام را باید نادیده گرفت. فقط مطمئن شوید که دستور **make** سطح بالا شکست نخورده است. ماژول‌های اختیاری در حال حاضر مورد نیاز نیستند و در فصل 8 ساخته خواهند شد.

بسته را نصب کنید:

```bash
make install
```

جزئیات مربوط به این بسته در بخش 8.52.2، "محتویات Python 3" قرار دارد.

# ۷.۱۱. Texinfo-7.1

بسته Texinfo شامل برنامه‌هایی برای خواندن، نوشتن و تبدیل صفحات اطلاعاتی است.

**زمان تقریبی ساخت:** 0.2 SBU
**فضای دیسک مورد نیاز:** 130 مگابایت

## ۷.۱۱.۱. نصب Texinfo

Texinfo را برای کامپایل آماده کنید:

```bash
./configure --prefix=/usr
```

بسته را کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

```bash
make install
```

جزئیات مربوط به این بسته در بخش 8.72.2، "محتویات Texinfo" قرار دارد.

# ۷.۱۲. Util-linux-2.40.2

بسته Util-linux شامل برنامه‌های مختلف کاربردی است.

**زمان تقریبی ساخت:** 0.2 SBU
**فضای دیسک مورد نیاز:** 180 مگابایت

## ۷.۱۲.۱. نصب Util-linux

FHS استفاده از دایرکتوری `/var/lib/hwclock` را به جای دایرکتوری معمول `/etc` به عنوان مکان فایل `adjtime` توصیه می‌کند. این دایرکتوری را با دستور زیر ایجاد کنید:

```bash
mkdir -pv /var/lib/hwclock
```

Util-linux را برای کامپایل آماده کنید:

```bash
./configure --libdir=/usr/lib     \
            --runstatedir=/run    \
            --disable-chfn-chsh   \
            --disable-login       \
            --disable-nologin     \
            --disable-su          \
            --disable-setpriv     \
            --disable-runuser     \
            --disable-pylibmount  \
            --disable-static      \
            --disable-liblastlog2 \
            --without-python      \
            ADJTIME_PATH=/var/lib/hwclock/adjtime \
            --docdir=/usr/share/doc/util-linux-2.40.2
```

**معنی گزینه‌های پیکربندی:**
`ADJTIME_PATH=/var/lib/hwclock/adjtime`
این مکان فایل ثبت اطلاعات مربوط به ساعت سخت‌افزاری را مطابق با FHS تنظیم می‌کند. این برای این ابزار موقتی ضروری نیست، اما از ایجاد فایل در مکان دیگری که بعداً هنگام ساخت بسته نهایی util-linux بازنویسی یا حذف نمی‌شود، جلوگیری می‌کند.
`--libdir=/usr/lib`
این سوئیچ اطمینان می‌دهد که پیوندهای نمادین `.so` مستقیماً به فایل کتابخانه اشتراکی در همان دایرکتوری (`/usr/lib`) اشاره می‌کنند.
`--disable-*`
این سوئیچ‌ها از هشدارها درباره ساخت اجزایی که به بسته‌هایی که در LFS نیستند یا هنوز نصب نشده‌اند نیاز دارند، جلوگیری می‌کنند.
`--without-python`
این سوئیچ استفاده از Python را غیرفعال می‌کند. از تلاش برای ساخت اتصال‌های غیرضروری جلوگیری می‌کند.
`runstatedir=/run`
این سوئیچ مکان سوکت مورد استفاده توسط **uuidd** و `libuuid` را به درستی تنظیم می‌کند.

بسته را کامپایل کنید:

```bash
make
```

بسته را نصب کنید:

```bash
make install
```

جزئیات مربوط به این بسته در بخش 8.79.2، "محتویات Util-linux" قرار دارد.

# ۷.۱۳. پاکسازی و ذخیره سیستم موقت

## ۷.۱۳.۱. پاکسازی

ابتدا، فایل‌های مستندات نصب شده فعلی را حذف کنید تا از قرار گرفتن آنها در سیستم نهایی جلوگیری شود و حدود 35 مگابایت صرفه‌جویی شود:

```bash
rm -rf /usr/share/{info,man,doc}/*
```

دوم، در یک سیستم لینوکس مدرن، فایل‌های .la لیبتول فقط برای libltdl مفید هستند. هیچ کتابخانه‌ای در LFS توسط libltdl بارگذاری نمی‌شود، و مشخص شده است که برخی از فایل‌های .la می‌توانند باعث شکست بسته‌های BLFS شوند. این فایل‌ها را اکنون حذف کنید:

```bash
find /usr/{lib,libexec} -name \*.la -delete
```

اندازه سیستم فعلی اکنون حدود 3 گیگابایت است، با این حال دایرکتوری /tools دیگر مورد نیاز نیست. این حدود 1 گیگابایت فضای دیسک استفاده می‌کند. آن را اکنون حذف کنید:

```bash
rm -rf /tools
```

## ۷.۱۳.۲. پشتیبان‌گیری

در این نقطه، برنامه‌ها و کتابخانه‌های ضروری ایجاد شده‌اند و سیستم LFS فعلی شما در وضعیت خوبی است. سیستم شما اکنون می‌تواند برای استفاده بعدی پشتیبان‌گیری شود. در صورت بروز خطاهای جدی در فصل‌های بعدی، اغلب مشخص می‌شود که حذف همه چیز و شروع مجدد (با دقت بیشتر) بهترین راه برای بازیابی است. متأسفانه، تمام فایل‌های موقتی نیز حذف خواهند شد. برای جلوگیری از صرف زمان اضافی برای انجام مجدد کاری که با موفقیت انجام شده است، ایجاد یک پشتیبان از سیستم LFS فعلی ممکن است مفید باشد.

**نکته**: تمام مراحل باقیمانده در این بخش اختیاری هستند. با این حال، به محض شروع نصب بسته‌ها در فصل 8، فایل‌های موقتی بازنویسی خواهند شد. بنابراین ممکن است ایده خوبی باشد که از سیستم فعلی همانطور که در زیر توضیح داده شده است پشتیبان‌گیری کنید.

مراحل زیر از خارج از محیط chroot انجام می‌شوند. این بدان معناست که قبل از ادامه باید ابتدا محیط chroot را ترک کنید. دلیل آن دسترسی به مکان‌های سیستم فایل خارج از محیط chroot برای ذخیره/خواندن آرشیو پشتیبان است، که نباید در سلسله مراتب $LFS قرار گیرد.

اگر تصمیم به تهیه پشتیبان گرفته‌اید، محیط chroot را ترک کنید:

```bash
exit
```

**مهم**: تمام دستورالعمل‌های زیر توسط root در سیستم میزبان شما اجرا می‌شوند. در مورد دستوراتی که قرار است اجرا کنید بسیار مراقب باشید زیرا اشتباهات انجام شده در اینجا می‌توانند سیستم میزبان شما را تغییر دهند. آگاه باشید که متغیر محیطی LFS به طور پیش‌فرض برای کاربر lfs تنظیم شده است اما ممکن است برای root تنظیم نشده باشد.

هر زمان که قرار است دستورات توسط root اجرا شوند، مطمئن شوید که LFS را تنظیم کرده‌اید.

این موضوع در بخش 2.6، "تنظیم متغیر $LFS" مورد بحث قرار گرفته است.

قبل از تهیه پشتیبان، سیستم فایل‌های مجازی را غیرفعال کنید:

```bash
mountpoint -q $LFS/dev/shm && umount $LFS/dev/shm
umount $LFS/dev/pts
umount $LFS/{sys,proc,run,dev}
```

مطمئن شوید که حداقل 1 گیگابایت فضای دیسک آزاد (تارهای منبع در آرشیو پشتیبان گنجانده خواهند شد) در سیستم فایلی که شامل دایرکتوری است که در آن آرشیو پشتیبان را ایجاد می‌کنید، داشته باشید.

توجه داشته باشید که دستورالعمل‌های زیر دایرکتوری خانه کاربر root سیستم میزبان را مشخص می‌کنند، که معمولاً در سیستم فایل ریشه یافت می‌شود. اگر نمی‌خواهید پشتیبان در دایرکتوری خانه root ذخیره شود، $HOME را با دایرکتوری دلخواه خود جایگزین کنید.

با اجرای دستور زیر آرشیو پشتیبان را ایجاد کنید:

**نکته**: از آنجا که آرشیو پشتیبان فشرده شده است، حتی در یک سیستم نسبتاً سریع زمان نسبتاً طولانی (بیش از 10 دقیقه) می‌گیرد.

```bash
cd $LFS
tar -cJpf $HOME/lfs-temp-tools-12.2.tar.xz .
```

**نکته**: اگر به فصل 8 ادامه می‌دهید، فراموش نکنید که دوباره وارد محیط chroot شوید، همانطور که در کادر "مهم" زیر توضیح داده شده است.

## ۷.۱۳.۳. بازیابی

در صورتی که اشتباهاتی رخ داده باشد و نیاز به شروع مجدد داشته باشید، می‌توانید از این پشتیبان برای بازیابی سیستم استفاده کنید و در زمان بازیابی صرفه‌جویی کنید. از آنجا که منابع در $LFS قرار دارند، آنها نیز در آرشیو پشتیبان گنجانده شده‌اند، بنابراین نیازی به دانلود مجدد آنها نیست. پس از بررسی اینکه $LFS به درستی تنظیم شده است، می‌توانید پشتیبان را با اجرای دستورات زیر بازیابی کنید:

**هشدار**: دستورات زیر بسیار خطرناک هستند. اگر rm -rf ./* را به عنوان کاربر root اجرا کنید و به دایرکتوری $LFS تغییر نکنید یا متغیر محیطی LFS برای کاربر root تنظیم نشده باشد، کل سیستم میزبان شما را نابود خواهد کرد. شما هشدار داده شده‌اید.

```bash
cd $LFS
rm -rf ./*
tar -xpf $HOME/lfs-temp-tools-12.2.tar.xz
```

دوباره دقت کنید که محیط به درستی تنظیم شده باشد و به ساخت بقیه سیستم ادامه دهید.

>**مهم**: اگر برای ایجاد پشتیبان یا شروع مجدد ساخت با استفاده از بازیابی، محیط chroot را ترک کردید، به یاد داشته باشید که بررسی کنید آیا سیستم فایل‌های مجازی هنوز نصب شده‌اند (findmnt | grep $LFS). اگر نصب نشده‌اند، اکنون آنها را دوباره نصب کنید همانطور که در بخش 7.3، "آماده‌سازی سیستم فایل‌های مجازی هسته" توضیح داده شده است و قبل از ادامه دوباره وارد محیط chroot شوید (به بخش 7.4، "ورود به محیط Chroot" مراجعه کنید).